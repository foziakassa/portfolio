"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@monogrid";
exports.ids = ["vendor-chunks/@monogrid"];
exports.modules = {

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-B3h-sJtp.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-B3h-sJtp.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ QuadRenderer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.0.6\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */ \nconst getBufferForType = (type, width, height)=>{\n    let out;\n    switch(type){\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error(\"Unsupported data type\");\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */ const canReadPixels = (type, renderer, camera, renderTargetOptions)=>{\n    if (_canReadPixelsResult !== undefined) return _canReadPixelsResult;\n    const testRT = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n        color: 0xffffff\n    }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */ class QuadRenderer {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */ constructor(options){\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n         * Renders the input texture using the specified material\n         */ this.render = ()=>{\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            } catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type,\n            colorSpace: this._colorSpace,\n            anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,\n            generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,\n            magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,\n            wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n            wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        } else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        this._camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch(this._type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    alternativeType = this._renderer.extensions.has(\"EXT_color_buffer_float\") ? three__WEBPACK_IMPORTED_MODULE_0__.FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${three__WEBPACK_IMPORTED_MODULE_0__.FloatType}`);\n                this._type = alternativeType;\n            } else {\n                this._supportsReadPixels = false;\n                console.warn(\"This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown\");\n            }\n        }\n        this._quad = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : three__WEBPACK_IMPORTED_MODULE_0__.UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */ static instantiateRenderer() {\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */ toArray() {\n        if (!this._supportsReadPixels) throw new Error(\"Can't read pixels in this browser\");\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @param options options\n     * @returns\n     */ toDataTexture(options) {\n        const returnValue = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(// fixed values\n        this.toArray(), this.width, this.height, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, this._type, // user values\n        (options === null || options === void 0 ? void 0 : options.mapping) || three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, (options === null || options === void 0 ? void 0 : options.wrapS) || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.wrapT) || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.magFilter) || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, (options === null || options === void 0 ? void 0 : options.minFilter) || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, // fixed value\n        three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */ disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */ dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach((v)=>{\n                if (v.value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach((value)=>{\n            if (value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */ get width() {\n        return this._width;\n    }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */ get height() {\n        return this._height;\n    }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */ get renderer() {\n        return this._renderer;\n    }\n    /**\n     * The `WebGLRenderTarget` used.\n     */ get renderTarget() {\n        return this._renderTarget;\n    }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n    // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */ get material() {\n        return this._material;\n    }\n    /**\n     *\n     */ get type() {\n        return this._type;\n    }\n    get colorSpace() {\n        return this._colorSpace;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9RdWFkUmVuZGVyZXItQjNoLXNKdHAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FFNFU7QUFFN1UsTUFBTXNCLG1CQUFtQixDQUFDQyxNQUFNQyxPQUFPQztJQUNuQyxJQUFJQztJQUNKLE9BQVFIO1FBQ0osS0FBS0gsbURBQWdCQTtZQUNqQk0sTUFBTSxJQUFJQyxrQkFBa0JILFFBQVFDLFNBQVM7WUFDN0M7UUFDSixLQUFLcEIsZ0RBQWFBO1lBQ2RxQixNQUFNLElBQUlFLFlBQVlKLFFBQVFDLFNBQVM7WUFDdkM7UUFDSixLQUFLTixrREFBZUE7WUFDaEJPLE1BQU0sSUFBSUcsWUFBWUwsUUFBUUMsU0FBUztZQUN2QztRQUNKLEtBQUtQLDJDQUFRQTtZQUNUUSxNQUFNLElBQUlJLFVBQVVOLFFBQVFDLFNBQVM7WUFDckM7UUFDSixLQUFLUiw0Q0FBU0E7WUFDVlMsTUFBTSxJQUFJSyxXQUFXUCxRQUFRQyxTQUFTO1lBQ3RDO1FBQ0osS0FBS1QsMENBQU9BO1lBQ1JVLE1BQU0sSUFBSU0sV0FBV1IsUUFBUUMsU0FBUztZQUN0QztRQUNKLEtBQUtuQiw0Q0FBU0E7WUFDVm9CLE1BQU0sSUFBSU8sYUFBYVQsUUFBUUMsU0FBUztZQUN4QztRQUNKO1lBQ0ksTUFBTSxJQUFJUyxNQUFNO0lBQ3hCO0lBQ0EsT0FBT1I7QUFDWDtBQUNBLElBQUlTO0FBQ0o7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxNQUFNQyxnQkFBZ0IsQ0FBQ2IsTUFBTWMsVUFBVUMsUUFBUUM7SUFDM0MsSUFBSUoseUJBQXlCSyxXQUN6QixPQUFPTDtJQUNYLE1BQU1NLFNBQVMsSUFBSWhDLG9EQUFpQkEsQ0FBQyxHQUFHLEdBQUc4QjtJQUMzQ0YsU0FBU0ssZUFBZSxDQUFDRDtJQUN6QixNQUFNRSxPQUFPLElBQUlwQyx1Q0FBSUEsQ0FBQyxJQUFJQyxnREFBYUEsSUFBSSxJQUFJYSxvREFBaUJBLENB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SSxDQUFDbkMsTUFBTSxFQUFFLElBQUksQ0FBQ0MsT0FBTztJQUN4RDtJQUNBOztLQUVDLEdBQ0QsSUFBSXBELFNBQVM7UUFBRSxPQUFPLElBQUksQ0FBQ29ELE9BQU87SUFBRTtJQUNwQyxJQUFJcEQsT0FBT21HLEtBQUssRUFBRTtRQUNkLElBQUksQ0FBQy9DLE9BQU8sR0FBRytDO1FBQ2YsSUFBSSxDQUFDcEQsYUFBYSxDQUFDdUMsT0FBTyxDQUFDLElBQUksQ0FBQ25DLE1BQU0sRUFBRSxJQUFJLENBQUNDLE9BQU87SUFDeEQ7SUFDQTs7S0FFQyxHQUNELElBQUl4QyxXQUFXO1FBQUUsT0FBTyxJQUFJLENBQUNrQyxTQUFTO0lBQUU7SUFDeEM7O0tBRUMsR0FDRCxJQUFJK0MsZUFBZTtRQUFFLE9BQU8sSUFBSSxDQUFDOUMsYUFBYTtJQUFFO0lBQ2hELElBQUk4QyxhQUFhTSxLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDcEQsYUFBYSxHQUFHb0Q7UUFDckIsSUFBSSxDQUFDaEQsTUFBTSxHQUFHZ0QsTUFBTXBHLEtBQUs7UUFDekIsSUFBSSxDQUFDcUQsT0FBTyxHQUFHK0MsTUFBTW5HLE1BQU07SUFDM0Isa0NBQWtDO0lBQ3RDO0lBQ0E7O0tBRUMsR0FDRCxJQUFJd0IsV0FBVztRQUFFLE9BQU8sSUFBSSxDQUFDMkMsU0FBUztJQUFFO0lBQ3hDOztLQUVDLEdBQ0QsSUFBSXJFLE9BQU87UUFBRSxPQUFPLElBQUksQ0FBQ3VELEtBQUs7SUFBRTtJQUNoQyxJQUFJRSxhQUFhO1FBQUUsT0FBTyxJQUFJLENBQUNELFdBQVc7SUFBRTtBQUNoRDtBQUU2QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jcmVhdGl2ZS1wb3J0Zm9saW8tc3RhcnRlci1jb2RlLWZpbGVzLy4vbm9kZV9tb2R1bGVzL0Btb25vZ3JpZC9nYWlubWFwLWpzL2Rpc3QvUXVhZFJlbmRlcmVyLUIzaC1zSnRwLmpzPzM1ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9ub2dyaWQvZ2Fpbm1hcC1qcyB2My4wLjZcbiAqIFdpdGgg4p2k77iPLCBieSBNT05PR1JJRCA8cm5kQG1vbm9ncmlkLmNvbT5cbiAqL1xuXG5pbXBvcnQgeyBSR0JBRm9ybWF0LCBMaW5lYXJGaWx0ZXIsIENsYW1wVG9FZGdlV3JhcHBpbmcsIFNjZW5lLCBPcnRob2dyYXBoaWNDYW1lcmEsIEhhbGZGbG9hdFR5cGUsIEZsb2F0VHlwZSwgTWVzaCwgUGxhbmVHZW9tZXRyeSwgV2ViR0xSZW5kZXJUYXJnZXQsIFVWTWFwcGluZywgV2ViR0xSZW5kZXJlciwgRGF0YVRleHR1cmUsIExpbmVhclNSR0JDb2xvclNwYWNlLCBTaGFkZXJNYXRlcmlhbCwgVGV4dHVyZSwgSW50VHlwZSwgU2hvcnRUeXBlLCBCeXRlVHlwZSwgVW5zaWduZWRJbnRUeXBlLCBVbnNpZ25lZEJ5dGVUeXBlLCBNZXNoQmFzaWNNYXRlcmlhbCB9IGZyb20gJ3RocmVlJztcblxuY29uc3QgZ2V0QnVmZmVyRm9yVHlwZSA9ICh0eXBlLCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgbGV0IG91dDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBVbnNpZ25lZEJ5dGVUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IFVpbnQxNkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBVbnNpZ25lZEludFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgVWludDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJ5dGVUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IEludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2hvcnRUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IEludDE2QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgSW50MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgdHlwZScpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbmxldCBfY2FuUmVhZFBpeGVsc1Jlc3VsdDtcbi8qKlxuICogVGVzdCBpZiB0aGlzIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gY2FuIGNvcnJlY3RseSByZWFkIHBpeGVscyBmcm9tIHRoZSBzcGVjaWZpZWRcbiAqIFJlbmRlciB0YXJnZXQgdHlwZS5cbiAqXG4gKiBSdW5zIG9ubHkgb25jZVxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gcmVuZGVyZXJcbiAqIEBwYXJhbSBjYW1lcmFcbiAqIEBwYXJhbSByZW5kZXJUYXJnZXRPcHRpb25zXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBjYW5SZWFkUGl4ZWxzID0gKHR5cGUsIHJlbmRlcmVyLCBjYW1lcmEsIHJlbmRlclRhcmdldE9wdGlvbnMpID0+IHtcbiAgICBpZiAoX2NhblJlYWRQaXhlbHNSZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIF9jYW5SZWFkUGl4ZWxzUmVzdWx0O1xuICAgIGNvbnN0IHRlc3RSVCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCgxLCAxLCByZW5kZXJUYXJnZXRPcHRpb25zKTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGVzdFJUKTtcbiAgICBjb25zdCBtZXNoID0gbmV3IE1lc2gobmV3IFBsYW5lR2VvbWV0cnkoKSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmZmIH0pKTtcbiAgICByZW5kZXJlci5yZW5kZXIobWVzaCwgY2FtZXJhKTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgY29uc3Qgb3V0ID0gZ2V0QnVmZmVyRm9yVHlwZSh0eXBlLCB0ZXN0UlQud2lkdGgsIHRlc3RSVC5oZWlnaHQpO1xuICAgIHJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHModGVzdFJULCAwLCAwLCB0ZXN0UlQud2lkdGgsIHRlc3RSVC5oZWlnaHQsIG91dCk7XG4gICAgdGVzdFJULmRpc3Bvc2UoKTtcbiAgICBtZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICBtZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICBfY2FuUmVhZFBpeGVsc1Jlc3VsdCA9IG91dFswXSAhPT0gMDtcbiAgICByZXR1cm4gX2NhblJlYWRQaXhlbHNSZXN1bHQ7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIHVzZWQgZm9yIHJlbmRlcmluZyBhIHRleHR1cmUgd2l0aCBhIG1hdGVyaWFsXG4gKlxuICogQGNhdGVnb3J5IENvcmVcbiAqIEBncm91cCBDb3JlXG4gKi9cbmNsYXNzIFF1YWRSZW5kZXJlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBRdWFkUmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFBhcmFtZXRlcnMgZm9yIHRoaXMgUXVhZFJlbmRlcmVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3I7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVySXNEaXNwb3NhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N1cHBvcnRzUmVhZFBpeGVscyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIHRoZSBpbnB1dCB0ZXh0dXJlIHVzaW5nIHRoZSBzcGVjaWZpZWQgbWF0ZXJpYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMuX3JlbmRlclRhcmdldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9zY2VuZSwgdGhpcy5fY2FtZXJhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3dpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgICAgIHRoaXMuX2NvbG9yU3BhY2UgPSBvcHRpb25zLmNvbG9yU3BhY2U7XG4gICAgICAgIGNvbnN0IHJ0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vIGZpeGVkIG9wdGlvbnNcbiAgICAgICAgICAgIGZvcm1hdDogUkdCQUZvcm1hdCxcbiAgICAgICAgICAgIGRlcHRoQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIHN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgLy8gdXNlciBvcHRpb25zXG4gICAgICAgICAgICB0eXBlOiB0aGlzLl90eXBlLCAvLyBzZXQgaW4gY2xhc3MgcHJvcGVydHlcbiAgICAgICAgICAgIGNvbG9yU3BhY2U6IHRoaXMuX2NvbG9yU3BhY2UsIC8vIHNldCBpbiBjbGFzcyBwcm9wZXJ0eVxuICAgICAgICAgICAgYW5pc290cm9weTogKChfYSA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFuaXNvdHJvcHkpICE9PSB1bmRlZmluZWQgPyAoX2IgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hbmlzb3Ryb3B5IDogMSxcbiAgICAgICAgICAgIGdlbmVyYXRlTWlwbWFwczogKChfYyA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdlbmVyYXRlTWlwbWFwcykgIT09IHVuZGVmaW5lZCA/IChfZCA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlLFxuICAgICAgICAgICAgbWFnRmlsdGVyOiAoKF9lID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubWFnRmlsdGVyKSAhPT0gdW5kZWZpbmVkID8gKF9mID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YubWFnRmlsdGVyIDogTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgbWluRmlsdGVyOiAoKF9nID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubWluRmlsdGVyKSAhPT0gdW5kZWZpbmVkID8gKF9oID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gubWluRmlsdGVyIDogTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgc2FtcGxlczogKChfaiA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLnNhbXBsZXMpICE9PSB1bmRlZmluZWQgPyAoX2sgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5zYW1wbGVzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgd3JhcFM6ICgoX2wgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9sID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbC53cmFwUykgIT09IHVuZGVmaW5lZCA/IChfbSA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLndyYXBTIDogQ2xhbXBUb0VkZ2VXcmFwcGluZyxcbiAgICAgICAgICAgIHdyYXBUOiAoKF9vID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX28ud3JhcFQpICE9PSB1bmRlZmluZWQgPyAoX3AgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcC53cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmdcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xuICAgICAgICBpZiAob3B0aW9ucy5yZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBRdWFkUmVuZGVyZXIuaW5zdGFudGlhdGVSZW5kZXJlcigpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NjZW5lID0gbmV3IFNjZW5lKCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoKTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCAxMCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYS5sZWZ0ID0gLTAuNTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnJpZ2h0ID0gMC41O1xuICAgICAgICB0aGlzLl9jYW1lcmEudG9wID0gMC41O1xuICAgICAgICB0aGlzLl9jYW1lcmEuYm90dG9tID0gLTAuNTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgaWYgKCFjYW5SZWFkUGl4ZWxzKHRoaXMuX3R5cGUsIHRoaXMuX3JlbmRlcmVyLCB0aGlzLl9jYW1lcmEsIHJ0T3B0aW9ucykpIHtcbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGl2ZVR5cGU7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlVHlwZSA9IHRoaXMuX3JlbmRlcmVyLmV4dGVuc2lvbnMuaGFzKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JykgPyBGbG9hdFR5cGUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsdGVybmF0aXZlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIHBpeGVscyBmcm9tICR7dGhpcy5fdHlwZX0gUmVuZGVyVGFyZ2V0cywgc3dpdGNoaW5nIHRvICR7RmxvYXRUeXBlfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBhbHRlcm5hdGl2ZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdXBwb3J0c1JlYWRQaXhlbHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoaXMgYnJvd3NlciBkb3Mgbm90IHN1cHBvcnQgdG9BcnJheSBvciB0b0RhdGFUZXh0dXJlLCBjYWxscyB0byB0aG9zZSBtZXRob2RzIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIHRocm93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3F1YWQgPSBuZXcgTWVzaChuZXcgUGxhbmVHZW9tZXRyeSgpLCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuX3F1YWQuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgICAgIHRoaXMuX3NjZW5lLmFkZCh0aGlzLl9xdWFkKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBydE9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQudGV4dHVyZS5tYXBwaW5nID0gKChfcSA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX3EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9xLm1hcHBpbmcpICE9PSB1bmRlZmluZWQgPyAoX3IgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfci5tYXBwaW5nIDogVVZNYXBwaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYSB0ZW1wb3JhcnkgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGluc3RhbnRpYXRlUmVuZGVyZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSgxMjgsIDEyOCk7XG4gICAgICAgIC8vIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZVxuICAgICAgICAvLyByZW5kZXJlci50b25lTWFwcGluZyA9IExpbmVhclRvbmVNYXBwaW5nXG4gICAgICAgIC8vIHJlbmRlcmVyLmRlYnVnLmNoZWNrU2hhZGVyRXJyb3JzID0gZmFsc2VcbiAgICAgICAgLy8gdGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUgPSB0cnVlXG4gICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2J0YWlucyBhIEJ1ZmZlciBjb250YWluaW5nIHRoZSByZW5kZXJlZCB0ZXh0dXJlLlxuICAgICAqXG4gICAgICogQHRocm93cyBFcnJvciBpZiB0aGUgYnJvd3NlciBjYW5ub3QgcmVhZCBwaXhlbHMgZnJvbSB0aGlzIFJlbmRlclRhcmdldCB0eXBlLlxuICAgICAqIEByZXR1cm5zIGEgVHlwZWRBcnJheSBjb250YWluaW5nIFJHQkEgdmFsdWVzIGZyb20gdGhpcyByZW5kZXJlclxuICAgICAqL1xuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3VwcG9ydHNSZWFkUGl4ZWxzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHJlYWQgcGl4ZWxzIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgICBjb25zdCBvdXQgPSBnZXRCdWZmZXJGb3JUeXBlKHRoaXMuX3R5cGUsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzKHRoaXMuX3JlbmRlclRhcmdldCwgMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgb3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSByZWFkUGl4ZWwgb3BlcmF0aW9uIGluIHRoZSByZW5kZXJUYXJnZXRcbiAgICAgKiBhbmQgcmV0dXJucyBhIERhdGFUZXh0dXJlIGNvbnRhaW5pbmcgdGhlIHJlYWQgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgdG9EYXRhVGV4dHVyZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gbmV3IERhdGFUZXh0dXJlKFxuICAgICAgICAvLyBmaXhlZCB2YWx1ZXNcbiAgICAgICAgdGhpcy50b0FycmF5KCksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBSR0JBRm9ybWF0LCB0aGlzLl90eXBlLCBcbiAgICAgICAgLy8gdXNlciB2YWx1ZXNcbiAgICAgICAgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXBwaW5nKSB8fCBVVk1hcHBpbmcsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud3JhcFMpIHx8IENsYW1wVG9FZGdlV3JhcHBpbmcsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud3JhcFQpIHx8IENsYW1wVG9FZGdlV3JhcHBpbmcsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFnRmlsdGVyKSB8fCBMaW5lYXJGaWx0ZXIsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWluRmlsdGVyKSB8fCBMaW5lYXJGaWx0ZXIsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYW5pc290cm9weSkgfHwgMSwgXG4gICAgICAgIC8vIGZpeGVkIHZhbHVlXG4gICAgICAgIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgLy8gc2V0IHRoaXMgYWZ0ZXJ3YXJkcywgd2UgY2FuJ3Qgc2V0IGl0IGluIGNvbnN0cnVjdG9yXG4gICAgICAgIHJldHVyblZhbHVlLmdlbmVyYXRlTWlwbWFwcyA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzKSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHVzaW5nIGEgZGlzcG9zYWJsZSByZW5kZXJlciwgaXQgd2lsbCBkaXNwb3NlIGl0LlxuICAgICAqL1xuICAgIGRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJlcklzRGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZm9yY2VDb250ZXh0TG9zcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgZGlzcG9zZSBvZiAqKmFsbCoqIGFzc2V0cyB1c2VkIGJ5IHRoaXMgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXNwb3NlUmVuZGVyVGFyZ2V0IHdpbGwgZGlzcG9zZSBvZiB0aGUgcmVuZGVyVGFyZ2V0IHdoaWNoIHdpbGwgbm90IGJlIHVzYWJsZSBsYXRlclxuICAgICAqIHNldCB0aGlzIHRvIHRydWUgaWYgeW91IHBhc3NlZCB0aGUgYHJlbmRlclRhcmdldC50ZXh0dXJlYCB0byBhIGBQTVJFTUdlbmVyYXRvcmBcbiAgICAgKiBvciBhcmUgb3RoZXJ3aXNlIGRvbmUgd2l0aCBpdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBsb2FkZXIgPSBuZXcgSERSSlBHTG9hZGVyKHJlbmRlcmVyKVxuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoJ2dhaW5tYXAuanBlZycpXG4gICAgICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSB9KSApXG4gICAgICogLy8gRE8gTk9UIGRpc3Bvc2UgdGhlIHJlbmRlclRhcmdldCBoZXJlLFxuICAgICAqIC8vIGl0IGlzIHVzZWQgZGlyZWN0bHkgaW4gdGhlIG1hdGVyaWFsXG4gICAgICogcmVzdWx0LmRpc3Bvc2UoKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGxvYWRlciA9IG5ldyBIRFJKUEdMb2FkZXIocmVuZGVyZXIpXG4gICAgICogY29uc3QgcG1yZW1HZW5lcmF0b3IgPSBuZXcgUE1SRU1HZW5lcmF0b3IoIHJlbmRlcmVyICk7XG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYygnZ2Fpbm1hcC5qcGVnJylcbiAgICAgKiBjb25zdCBlbnZNYXAgPSBwbXJlbUdlbmVyYXRvci5mcm9tRXF1aXJlY3Rhbmd1bGFyKHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSlcbiAgICAgKiBjb25zdCBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7IGVudk1hcCB9KSApXG4gICAgICogLy8gcmVuZGVyVGFyZ2V0IGNhbiBiZSBkaXNwb3NlZCBoZXJlXG4gICAgICogLy8gYmVjYXVzZSBpdCB3YXMgdXNlZCB0byBnZW5lcmF0ZSBhIFBNUkVNIHRleHR1cmVcbiAgICAgKiByZXN1bHQuZGlzcG9zZSh0cnVlKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRpc3Bvc2UoZGlzcG9zZVJlbmRlclRhcmdldCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgIGlmIChkaXNwb3NlUmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzcG9zZSBzaGFkZXIgbWF0ZXJpYWwgdGV4dHVyZSB1bmlmb3Jtc1xuICAgICAgICBpZiAodGhpcy5tYXRlcmlhbCBpbnN0YW5jZW9mIFNoYWRlck1hdGVyaWFsKSB7XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMubWF0ZXJpYWwudW5pZm9ybXMpLmZvckVhY2godiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHYudmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlKVxuICAgICAgICAgICAgICAgICAgICB2LnZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpc3Bvc2Ugb3RoZXIgbWF0ZXJpYWwgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMubWF0ZXJpYWwpLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGV4dHVyZSlcbiAgICAgICAgICAgICAgICB2YWx1ZS5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fcXVhZC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5fd2lkdGg7IH1cbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0LnNldFNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLl9oZWlnaHQ7IH1cbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQuc2V0U2l6ZSh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlbmRlcmVyIHVzZWRcbiAgICAgKi9cbiAgICBnZXQgcmVuZGVyZXIoKSB7IHJldHVybiB0aGlzLl9yZW5kZXJlcjsgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgV2ViR0xSZW5kZXJUYXJnZXRgIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IHJlbmRlclRhcmdldCgpIHsgcmV0dXJuIHRoaXMuX3JlbmRlclRhcmdldDsgfVxuICAgIHNldCByZW5kZXJUYXJnZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWUud2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlLmhlaWdodDtcbiAgICAgICAgLy8gdGhpcy5fdHlwZSA9IHZhbHVlLnRleHR1cmUudHlwZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYE1hdGVyaWFsYCB1c2VkLlxuICAgICAqL1xuICAgIGdldCBtYXRlcmlhbCgpIHsgcmV0dXJuIHRoaXMuX21hdGVyaWFsOyB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3R5cGU7IH1cbiAgICBnZXQgY29sb3JTcGFjZSgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yU3BhY2U7IH1cbn1cblxuZXhwb3J0IHsgUXVhZFJlbmRlcmVyIGFzIFEgfTtcbiJdLCJuYW1lcyI6WyJSR0JBRm9ybWF0IiwiTGluZWFyRmlsdGVyIiwiQ2xhbXBUb0VkZ2VXcmFwcGluZyIsIlNjZW5lIiwiT3J0aG9ncmFwaGljQ2FtZXJhIiwiSGFsZkZsb2F0VHlwZSIsIkZsb2F0VHlwZSIsIk1lc2giLCJQbGFuZUdlb21ldHJ5IiwiV2ViR0xSZW5kZXJUYXJnZXQiLCJVVk1hcHBpbmciLCJXZWJHTFJlbmRlcmVyIiwiRGF0YVRleHR1cmUiLCJMaW5lYXJTUkdCQ29sb3JTcGFjZSIsIlNoYWRlck1hdGVyaWFsIiwiVGV4dHVyZSIsIkludFR5cGUiLCJTaG9ydFR5cGUiLCJCeXRlVHlwZSIsIlVuc2lnbmVkSW50VHlwZSIsIlVuc2lnbmVkQnl0ZVR5cGUiLCJNZXNoQmFzaWNNYXRlcmlhbCIsImdldEJ1ZmZlckZvclR5cGUiLCJ0eXBlIiwid2lkdGgiLCJoZWlnaHQiLCJvdXQiLCJVaW50OENsYW1wZWRBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkVycm9yIiwiX2NhblJlYWRQaXhlbHNSZXN1bHQiLCJjYW5SZWFkUGl4ZWxzIiwicmVuZGVyZXIiLCJjYW1lcmEiLCJyZW5kZXJUYXJnZXRPcHRpb25zIiwidW5kZWZpbmVkIiwidGVzdFJUIiwic2V0UmVuZGVyVGFyZ2V0IiwibWVzaCIsImNvbG9yIiwicmVuZGVyIiwicmVhZFJlbmRlclRhcmdldFBpeGVscyIsImRpc3Bvc2UiLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiUXVhZFJlbmRlcmVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9qIiwiX2siLCJfbCIsIl9tIiwiX28iLCJfcCIsIl9xIiwiX3IiLCJfcmVuZGVyZXJJc0Rpc3Bvc2FibGUiLCJfc3VwcG9ydHNSZWFkUGl4ZWxzIiwiX3JlbmRlcmVyIiwiX3JlbmRlclRhcmdldCIsIl9zY2VuZSIsIl9jYW1lcmEiLCJlIiwiX3dpZHRoIiwiX2hlaWdodCIsIl90eXBlIiwiX2NvbG9yU3BhY2UiLCJjb2xvclNwYWNlIiwicnRPcHRpb25zIiwiZm9ybWF0IiwiZGVwdGhCdWZmZXIiLCJzdGVuY2lsQnVmZmVyIiwiYW5pc290cm9weSIsImdlbmVyYXRlTWlwbWFwcyIsIm1hZ0ZpbHRlciIsIm1pbkZpbHRlciIsInNhbXBsZXMiLCJ3cmFwUyIsIndyYXBUIiwiX21hdGVyaWFsIiwiaW5zdGFudGlhdGVSZW5kZXJlciIsInBvc2l0aW9uIiwic2V0IiwibGVmdCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsImFsdGVybmF0aXZlVHlwZSIsImV4dGVuc2lvbnMiLCJoYXMiLCJjb25zb2xlIiwid2FybiIsIl9xdWFkIiwiY29tcHV0ZUJvdW5kaW5nQm94IiwiYWRkIiwidGV4dHVyZSIsIm1hcHBpbmciLCJzZXRTaXplIiwidG9BcnJheSIsInRvRGF0YVRleHR1cmUiLCJyZXR1cm5WYWx1ZSIsImRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyIiwiZm9yY2VDb250ZXh0TG9zcyIsImRpc3Bvc2VSZW5kZXJUYXJnZXQiLCJyZW5kZXJUYXJnZXQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJ1bmlmb3JtcyIsImZvckVhY2giLCJ2IiwidmFsdWUiLCJRIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-B3h-sJtp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js":
/*!**********************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/decode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GainMapDecoderMaterial: () => (/* binding */ GainMapDecoderMaterial),\n/* harmony export */   GainMapLoader: () => (/* binding */ GainMapLoader),\n/* harmony export */   HDRJPGLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   JPEGRLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   MPFExtractor: () => (/* binding */ MPFExtractor),\n/* harmony export */   QuadRenderer: () => (/* reexport safe */ _QuadRenderer_B3h_sJtp_js__WEBPACK_IMPORTED_MODULE_1__.Q),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   extractGainmapFromJPEG: () => (/* binding */ extractGainmapFromJPEG),\n/* harmony export */   extractXMP: () => (/* binding */ extractXMP)\n/* harmony export */ });\n/* harmony import */ var _QuadRenderer_B3h_sJtp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./QuadRenderer-B3h-sJtp.js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-B3h-sJtp.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.0.6\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */ \n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */ class GainMapDecoderMaterial extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n     *\n     * @param params\n     */ constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }){\n        super({\n            name: \"GainMapDecoderMaterial\",\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: {\n                    value: sdr\n                },\n                gainMap: {\n                    value: gainMap\n                },\n                gamma: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2])\n                },\n                offsetHdr: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(offsetHdr)\n                },\n                offsetSdr: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(offsetSdr)\n                },\n                gainMapMin: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(gainMapMin)\n                },\n                gainMapMax: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(gainMapMax)\n                },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() {\n        return this.uniforms.sdr.value;\n    }\n    set sdr(value) {\n        this.uniforms.sdr.value = value;\n    }\n    get gainMap() {\n        return this.uniforms.gainMap.value;\n    }\n    set gainMap(value) {\n        this.uniforms.gainMap.value = value;\n    }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */ get offsetHdr() {\n        return this.uniforms.offsetHdr.value.toArray();\n    }\n    set offsetHdr(value) {\n        this.uniforms.offsetHdr.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */ get offsetSdr() {\n        return this.uniforms.offsetSdr.value.toArray();\n    }\n    set offsetSdr(value) {\n        this.uniforms.offsetSdr.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */ get gainMapMin() {\n        return this.uniforms.gainMapMin.value.toArray();\n    }\n    set gainMapMin(value) {\n        this.uniforms.gainMapMin.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */ get gainMapMax() {\n        return this.uniforms.gainMapMax.value.toArray();\n    }\n    set gainMapMax(value) {\n        this.uniforms.gainMapMax.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */ get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [\n            1 / g.x,\n            1 / g.y,\n            1 / g.z\n        ];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */ get hdrCapacityMin() {\n        return this._hdrCapacityMin;\n    }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */ get hdrCapacityMax() {\n        return this._hdrCapacityMax;\n    }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */ get maxDisplayBoost() {\n        return this._maxDisplayBoost;\n    }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */ const decode = (params)=>{\n    const { sdr, gainMap, renderer } = params;\n    if (sdr.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        console.warn(\"SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically\");\n        sdr.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace) {\n        console.warn(\"Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically\");\n        gainMap.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = new GainMapDecoderMaterial({\n        ...params,\n        sdr,\n        gainMap\n    });\n    const quadRenderer = new _QuadRenderer_B3h_sJtp_js__WEBPACK_IMPORTED_MODULE_1__.Q({\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        width: sdr.image.width,\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        height: sdr.image.height,\n        type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n        colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n        material,\n        renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    } catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\nclass GainMapNotFoundError extends Error {\n}\nclass XMPMetadataNotFoundError extends Error {\n}\nconst getAttribute = (description, name, defaultValue)=>{\n    var _a;\n    let returnValue;\n    const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\n    if (!parsedValue) {\n        const node = description.getElementsByTagName(name)[0];\n        if (node) {\n            const values = node.getElementsByTagName(\"rdf:li\");\n            if (values.length === 3) {\n                returnValue = Array.from(values).map((v)=>v.innerHTML);\n            } else {\n                throw new Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`);\n            }\n        } else {\n            if (defaultValue) return defaultValue;\n            else throw new Error(`Can't find ${name} in gainmap metadata`);\n        }\n    } else {\n        returnValue = parsedValue;\n    }\n    return returnValue;\n};\n/**\n *\n * @param input\n * @returns\n */ const extractXMP = (input)=>{\n    var _a, _b;\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== \"undefined\") str = new TextDecoder().decode(input);\n    else str = input.toString();\n    let start = str.indexOf(\"<x:xmpmeta\");\n    const parser = new DOMParser();\n    while(start !== -1){\n        const end = str.indexOf(\"x:xmpmeta>\", start);\n        str.slice(start, end + 10);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const xmlDocument = parser.parseFromString(xmpBlock, \"text/xml\");\n            const description = xmlDocument.getElementsByTagName(\"rdf:Description\")[0];\n            const gainMapMin = getAttribute(description, \"hdrgm:GainMapMin\", \"0\");\n            const gainMapMax = getAttribute(description, \"hdrgm:GainMapMax\");\n            const gamma = getAttribute(description, \"hdrgm:Gamma\", \"1\");\n            const offsetSDR = getAttribute(description, \"hdrgm:OffsetSDR\", \"0.015625\");\n            const offsetHDR = getAttribute(description, \"hdrgm:OffsetHDR\", \"0.015625\");\n            let hdrCapacityMin = (_a = description.attributes.getNamedItem(\"hdrgm:HDRCapacityMin\")) === null || _a === void 0 ? void 0 : _a.nodeValue;\n            if (!hdrCapacityMin) hdrCapacityMin = \"0\";\n            const hdrCapacityMax = (_b = description.attributes.getNamedItem(\"hdrgm:HDRCapacityMax\")) === null || _b === void 0 ? void 0 : _b.nodeValue;\n            if (!hdrCapacityMax) throw new Error(\"Incomplete gainmap metadata\");\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map((v)=>parseFloat(v)) : [\n                    parseFloat(gainMapMin),\n                    parseFloat(gainMapMin),\n                    parseFloat(gainMapMin)\n                ],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map((v)=>parseFloat(v)) : [\n                    parseFloat(gainMapMax),\n                    parseFloat(gainMapMax),\n                    parseFloat(gainMapMax)\n                ],\n                gamma: Array.isArray(gamma) ? gamma.map((v)=>parseFloat(v)) : [\n                    parseFloat(gamma),\n                    parseFloat(gamma),\n                    parseFloat(gamma)\n                ],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map((v)=>parseFloat(v)) : [\n                    parseFloat(offsetSDR),\n                    parseFloat(offsetSDR),\n                    parseFloat(offsetSDR)\n                ],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map((v)=>parseFloat(v)) : [\n                    parseFloat(offsetHDR),\n                    parseFloat(offsetHDR),\n                    parseFloat(offsetHDR)\n                ],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        } catch (e) {}\n        start = str.indexOf(\"<x:xmpmeta\", end);\n    }\n};\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */ class MPFExtractor {\n    constructor(options){\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject)=>{\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error(\"Not a valid jpeg\"));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while(offset < length){\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops 😵`));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug) console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug) console.log(\"Found APP2 marker (0xffe2)\");\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */ if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        } else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        } else {\n                            reject(new Error(\"No valid endianness marker found in TIFF header\"));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error(\"Not valid TIFF data! (no 0x002A marker)\"));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error(\"Not valid TIFF data! (First offset less than 8)\"));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for(let i = entriesStart; i < entriesStart + 12 * count; i += 12){\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for(let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16){\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            } else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([\n                                dataView\n                            ]);\n                            const imgs = [];\n                            for (const image of images){\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, \"image/jpeg\");\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */ const extractGainmapFromJPEG = async (jpegFile)=>{\n    const metadata = extractXMP(jpegFile);\n    if (!metadata) throw new XMPMetadataNotFoundError(\"Gain map XMP metadata not found\");\n    const mpfExtractor = new MPFExtractor({\n        extractFII: true,\n        extractNonFII: true\n    });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2) throw new GainMapNotFoundError(\"Gain map recovery image not found\");\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */ const getHTMLImageFromBlob = (blob)=>{\n    return new Promise((resolve, reject)=>{\n        const img = document.createElement(\"img\");\n        img.onload = ()=>{\n            resolve(img);\n        };\n        img.onerror = (e)=>{\n            reject(e);\n        };\n        img.src = URL.createObjectURL(blob);\n    });\n};\nclass LoaderBase extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    /**\n     *\n     * @param renderer\n     * @param manager\n     */ constructor(renderer, manager){\n        super(manager);\n        if (renderer) this._renderer = renderer;\n        this._internalLoadingManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    }\n    /**\n     * Specify the renderer to use when rendering the gain map\n     *\n     * @param renderer\n     * @returns\n     */ setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    /**\n     * Specify the renderTarget options to use when rendering the gain map\n     *\n     * @param options\n     * @returns\n     */ setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    /**\n     * @private\n     * @returns\n     */ prepareQuadRenderer() {\n        if (!this._renderer) console.warn(\"WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.\");\n        // temporary values\n        const material = new GainMapDecoderMaterial({\n            gainMapMax: [\n                1,\n                1,\n                1\n            ],\n            gainMapMin: [\n                0,\n                0,\n                0\n            ],\n            gamma: [\n                1,\n                1,\n                1\n            ],\n            offsetHdr: [\n                1,\n                1,\n                1\n            ],\n            offsetSdr: [\n                1,\n                1,\n                1\n            ],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new three__WEBPACK_IMPORTED_MODULE_0__.Texture(),\n            sdr: new three__WEBPACK_IMPORTED_MODULE_0__.Texture()\n        });\n        return new _QuadRenderer_B3h_sJtp_js__WEBPACK_IMPORTED_MODULE_1__.Q({\n            width: 16,\n            height: 16,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */ async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        // this is optional, will render a black gain-map if not present\n        const gainMapBlob = gainMapBuffer ? new Blob([\n            gainMapBuffer\n        ], {\n            type: \"image/jpeg\"\n        }) : undefined;\n        const sdrBlob = new Blob([\n            sdrBuffer\n        ], {\n            type: \"image/jpeg\"\n        });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === \"undefined\") {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = true;\n        } else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, {\n                    imageOrientation: \"flipY\"\n                }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, {\n                    imageOrientation: \"flipY\"\n                })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        const gainMap = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(gainMapImage || new ImageData(2, 2), three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(sdrImage, three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n        quadRenderer.render();\n    }\n}\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */ class GainMapLoader extends LoaderBase {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */ load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async ()=>{\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                } catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === \"function\") onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === \"function\") onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = ()=>{\n            if (typeof onProgress === \"function\") {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent(\"progress\", {\n                    lengthComputable,\n                    loaded,\n                    total\n                }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType(\"arraybuffer\");\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof buffer === \"string\") throw new Error(\"Invalid sdr buffer\");\n            sdr = buffer;\n            await loadCheck();\n        }, (e)=>{\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        const gainMapLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType(\"arraybuffer\");\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof buffer === \"string\") throw new Error(\"Invalid gainmap buffer\");\n            gainMap = buffer;\n            await loadCheck();\n        }, (e)=>{\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        const metadataLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof json !== \"string\") throw new Error(\"Invalid metadata string\");\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e)=>{\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        return quadRenderer;\n    }\n}\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */ class HDRJPGLoader extends LoaderBase {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */ load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof jpeg === \"string\") throw new Error(\"Invalid buffer, received [string], was expecting [ArrayBuffer]\");\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            } catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [\n                            0,\n                            0,\n                            0\n                        ],\n                        gainMapMax: [\n                            1,\n                            1,\n                            1\n                        ],\n                        gamma: [\n                            1,\n                            1,\n                            1\n                        ],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [\n                            0,\n                            0,\n                            0\n                        ],\n                        offsetSdr: [\n                            0,\n                            0,\n                            0\n                        ]\n                    };\n                    sdrJPEG = jpegBuffer;\n                } else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n            } catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === \"function\") onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === \"function\") onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error)=>{\n            this.manager.itemError(url);\n            if (typeof onError === \"function\") onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9kZWNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFOEQ7QUFDcU07QUFFcFEsTUFBTWtCLGVBQWUsUUFBUSxHQUFHLENBQUM7Ozs7Ozs7QUFPakMsQ0FBQztBQUNELE1BQU1DLGlCQUFpQixRQUFRLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQm5DLENBQUM7QUFDRDs7Ozs7Q0FLQyxHQUNELE1BQU1DLCtCQUErQmxCLGlEQUFjQTtJQUMvQzs7O0tBR0MsR0FDRG1CLFlBQVksRUFBRUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLGVBQWUsRUFBRUMsY0FBYyxFQUFFQyxjQUFjLEVBQUVDLEdBQUcsRUFBRUMsT0FBTyxFQUFFLENBQUU7UUFDaEksS0FBSyxDQUFDO1lBQ0ZDLE1BQU07WUFDTmQ7WUFDQUM7WUFDQWMsVUFBVTtnQkFDTkgsS0FBSztvQkFBRUksT0FBT0o7Z0JBQUk7Z0JBQ2xCQyxTQUFTO29CQUFFRyxPQUFPSDtnQkFBUTtnQkFDMUJULE9BQU87b0JBQUVZLE9BQU8sSUFBSS9CLDBDQUFPQSxDQUFDLE1BQU1tQixLQUFLLENBQUMsRUFBRSxFQUFFLE1BQU1BLEtBQUssQ0FBQyxFQUFFLEVBQUUsTUFBTUEsS0FBSyxDQUFDLEVBQUU7Z0JBQUU7Z0JBQzVFQyxXQUFXO29CQUFFVyxPQUFPLElBQUkvQiwwQ0FBT0EsR0FBR2dDLFNBQVMsQ0FBQ1o7Z0JBQVc7Z0JBQ3ZEQyxXQUFXO29CQUFFVSxPQUFPLElBQUkvQiwwQ0FBT0EsR0FBR2dDLFNBQVMsQ0FBQ1g7Z0JBQVc7Z0JBQ3ZEQyxZQUFZO29CQUFFUyxPQUFPLElBQUkvQiwwQ0FBT0EsR0FBR2dDLFNBQVMsQ0FBQ1Y7Z0JBQVk7Z0JBQ3pEQyxZQUFZO29CQUFFUSxPQUFPLElBQUkvQiwwQ0FBT0Es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anMtY3JlYXRpdmUtcG9ydGZvbGlvLXN0YXJ0ZXItY29kZS1maWxlcy8uL25vZGVfbW9kdWxlcy9AbW9ub2dyaWQvZ2Fpbm1hcC1qcy9kaXN0L2RlY29kZS5qcz9hMWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vbm9ncmlkL2dhaW5tYXAtanMgdjMuMC42XG4gKiBXaXRoIOKdpO+4jywgYnkgTU9OT0dSSUQgPHJuZEBtb25vZ3JpZC5jb20+XG4gKi9cblxuaW1wb3J0IHsgUSBhcyBRdWFkUmVuZGVyZXIgfSBmcm9tICcuL1F1YWRSZW5kZXJlci1CM2gtc0p0cC5qcyc7XG5pbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgVmVjdG9yMywgTm9CbGVuZGluZywgU1JHQkNvbG9yU3BhY2UsIExpbmVhclNSR0JDb2xvclNwYWNlLCBIYWxmRmxvYXRUeXBlLCBMb2FkZXIsIExvYWRpbmdNYW5hZ2VyLCBUZXh0dXJlLCBVVk1hcHBpbmcsIENsYW1wVG9FZGdlV3JhcHBpbmcsIExpbmVhckZpbHRlciwgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLCBSR0JBRm9ybWF0LCBVbnNpZ25lZEJ5dGVUeXBlLCBGaWxlTG9hZGVyIH0gZnJvbSAndGhyZWUnO1xuXG5jb25zdCB2ZXJ0ZXhTaGFkZXIgPSAvKiBnbHNsICovIGBcbnZhcnlpbmcgdmVjMiB2VXY7XG5cbnZvaWQgbWFpbigpIHtcbiAgdlV2ID0gdXY7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG59XG5gO1xuY29uc3QgZnJhZ21lbnRTaGFkZXIgPSAvKiBnbHNsICovIGBcbi8vIG1pbiBoYWxmIGZsb2F0IHZhbHVlXG4jZGVmaW5lIEhBTEZfRkxPQVRfTUlOIHZlYzMoIC02NTUwNCwgLTY1NTA0LCAtNjU1MDQgKVxuLy8gbWF4IGhhbGYgZmxvYXQgdmFsdWVcbiNkZWZpbmUgSEFMRl9GTE9BVF9NQVggdmVjMyggNjU1MDQsIDY1NTA0LCA2NTUwNCApXG5cbnVuaWZvcm0gc2FtcGxlcjJEIHNkcjtcbnVuaWZvcm0gc2FtcGxlcjJEIGdhaW5NYXA7XG51bmlmb3JtIHZlYzMgZ2FtbWE7XG51bmlmb3JtIHZlYzMgb2Zmc2V0SGRyO1xudW5pZm9ybSB2ZWMzIG9mZnNldFNkcjtcbnVuaWZvcm0gdmVjMyBnYWluTWFwTWluO1xudW5pZm9ybSB2ZWMzIGdhaW5NYXBNYXg7XG51bmlmb3JtIGZsb2F0IHdlaWdodEZhY3RvcjtcblxudmFyeWluZyB2ZWMyIHZVdjtcblxudm9pZCBtYWluKCkge1xuICB2ZWMzIHJnYiA9IHRleHR1cmUyRCggc2RyLCB2VXYgKS5yZ2I7XG4gIHZlYzMgcmVjb3ZlcnkgPSB0ZXh0dXJlMkQoIGdhaW5NYXAsIHZVdiApLnJnYjtcbiAgdmVjMyBsb2dSZWNvdmVyeSA9IHBvdyggcmVjb3ZlcnksIGdhbW1hICk7XG4gIHZlYzMgbG9nQm9vc3QgPSBnYWluTWFwTWluICogKCAxLjAgLSBsb2dSZWNvdmVyeSApICsgZ2Fpbk1hcE1heCAqIGxvZ1JlY292ZXJ5O1xuICB2ZWMzIGhkckNvbG9yID0gKHJnYiArIG9mZnNldFNkcikgKiBleHAyKCBsb2dCb29zdCAqIHdlaWdodEZhY3RvciApIC0gb2Zmc2V0SGRyO1xuICB2ZWMzIGNsYW1wZWRIZHJDb2xvciA9IG1heCggSEFMRl9GTE9BVF9NSU4sIG1pbiggSEFMRl9GTE9BVF9NQVgsIGhkckNvbG9yICkpO1xuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjbGFtcGVkSGRyQ29sb3IgLCAxLjAgKTtcbn1cbmA7XG4vKipcbiAqIEEgTWF0ZXJpYWwgd2hpY2ggaXMgYWJsZSB0byBkZWNvZGUgdGhlIEdhaW5tYXAgaW50byBhIGZ1bGwgSERSIFJlcHJlc2VudGF0aW9uXG4gKlxuICogQGNhdGVnb3J5IE1hdGVyaWFsc1xuICogQGdyb3VwIE1hdGVyaWFsc1xuICovXG5jbGFzcyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgZ2FtbWEsIG9mZnNldEhkciwgb2Zmc2V0U2RyLCBnYWluTWFwTWluLCBnYWluTWFwTWF4LCBtYXhEaXNwbGF5Qm9vc3QsIGhkckNhcGFjaXR5TWluLCBoZHJDYXBhY2l0eU1heCwgc2RyLCBnYWluTWFwIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogJ0dhaW5NYXBEZWNvZGVyTWF0ZXJpYWwnLFxuICAgICAgICAgICAgdmVydGV4U2hhZGVyLFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgIHNkcjogeyB2YWx1ZTogc2RyIH0sXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcDogeyB2YWx1ZTogZ2Fpbk1hcCB9LFxuICAgICAgICAgICAgICAgIGdhbW1hOiB7IHZhbHVlOiBuZXcgVmVjdG9yMygxLjAgLyBnYW1tYVswXSwgMS4wIC8gZ2FtbWFbMV0sIDEuMCAvIGdhbW1hWzJdKSB9LFxuICAgICAgICAgICAgICAgIG9mZnNldEhkcjogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkob2Zmc2V0SGRyKSB9LFxuICAgICAgICAgICAgICAgIG9mZnNldFNkcjogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkob2Zmc2V0U2RyKSB9LFxuICAgICAgICAgICAgICAgIGdhaW5NYXBNaW46IHsgdmFsdWU6IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KGdhaW5NYXBNaW4pIH0sXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcE1heDogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoZ2Fpbk1hcE1heCkgfSxcbiAgICAgICAgICAgICAgICB3ZWlnaHRGYWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IChNYXRoLmxvZzIobWF4RGlzcGxheUJvb3N0KSAtIGhkckNhcGFjaXR5TWluKSAvIChoZHJDYXBhY2l0eU1heCAtIGhkckNhcGFjaXR5TWluKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibGVuZGluZzogTm9CbGVuZGluZyxcbiAgICAgICAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICAgICAgICBkZXB0aFdyaXRlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWF4RGlzcGxheUJvb3N0ID0gbWF4RGlzcGxheUJvb3N0O1xuICAgICAgICB0aGlzLl9oZHJDYXBhY2l0eU1pbiA9IGhkckNhcGFjaXR5TWluO1xuICAgICAgICB0aGlzLl9oZHJDYXBhY2l0eU1heCA9IGhkckNhcGFjaXR5TWF4O1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgc2RyKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5zZHIudmFsdWU7IH1cbiAgICBzZXQgc2RyKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMuc2RyLnZhbHVlID0gdmFsdWU7IH1cbiAgICBnZXQgZ2Fpbk1hcCgpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2Fpbk1hcC52YWx1ZTsgfVxuICAgIHNldCBnYWluTWFwKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMuZ2Fpbk1hcC52YWx1ZSA9IHZhbHVlOyB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLm9mZnNldEhkcn1cbiAgICAgKi9cbiAgICBnZXQgb2Zmc2V0SGRyKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5vZmZzZXRIZHIudmFsdWUudG9BcnJheSgpOyB9XG4gICAgc2V0IG9mZnNldEhkcih2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLm9mZnNldEhkci52YWx1ZS5mcm9tQXJyYXkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLm9mZnNldFNkcn1cbiAgICAgKi9cbiAgICBnZXQgb2Zmc2V0U2RyKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5vZmZzZXRTZHIudmFsdWUudG9BcnJheSgpOyB9XG4gICAgc2V0IG9mZnNldFNkcih2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLm9mZnNldFNkci52YWx1ZS5mcm9tQXJyYXkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmdhaW5NYXBNaW59XG4gICAgICovXG4gICAgZ2V0IGdhaW5NYXBNaW4oKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLmdhaW5NYXBNaW4udmFsdWUudG9BcnJheSgpOyB9XG4gICAgc2V0IGdhaW5NYXBNaW4odmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5nYWluTWFwTWluLnZhbHVlLmZyb21BcnJheSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuZ2Fpbk1hcE1heH1cbiAgICAgKi9cbiAgICBnZXQgZ2Fpbk1hcE1heCgpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2Fpbk1hcE1heC52YWx1ZS50b0FycmF5KCk7IH1cbiAgICBzZXQgZ2Fpbk1hcE1heCh2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLmdhaW5NYXBNYXgudmFsdWUuZnJvbUFycmF5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5nYW1tYX1cbiAgICAgKi9cbiAgICBnZXQgZ2FtbWEoKSB7XG4gICAgICAgIGNvbnN0IGcgPSB0aGlzLnVuaWZvcm1zLmdhbW1hLnZhbHVlO1xuICAgICAgICByZXR1cm4gWzEgLyBnLngsIDEgLyBnLnksIDEgLyBnLnpdO1xuICAgIH1cbiAgICBzZXQgZ2FtbWEodmFsdWUpIHtcbiAgICAgICAgY29uc3QgZyA9IHRoaXMudW5pZm9ybXMuZ2FtbWEudmFsdWU7XG4gICAgICAgIGcueCA9IDEuMCAvIHZhbHVlWzBdO1xuICAgICAgICBnLnkgPSAxLjAgLyB2YWx1ZVsxXTtcbiAgICAgICAgZy56ID0gMS4wIC8gdmFsdWVbMl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5oZHJDYXBhY2l0eU1pbn1cbiAgICAgKiBAcmVtYXJrcyBMb2dhcml0aG1pYyBzcGFjZVxuICAgICAqL1xuICAgIGdldCBoZHJDYXBhY2l0eU1pbigpIHsgcmV0dXJuIHRoaXMuX2hkckNhcGFjaXR5TWluOyB9XG4gICAgc2V0IGhkckNhcGFjaXR5TWluKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hkckNhcGFjaXR5TWluID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlV2VpZ2h0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5oZHJDYXBhY2l0eU1pbn1cbiAgICAgKiBAcmVtYXJrcyBMb2dhcml0aG1pYyBzcGFjZVxuICAgICAqL1xuICAgIGdldCBoZHJDYXBhY2l0eU1heCgpIHsgcmV0dXJuIHRoaXMuX2hkckNhcGFjaXR5TWF4OyB9XG4gICAgc2V0IGhkckNhcGFjaXR5TWF4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hkckNhcGFjaXR5TWF4ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlV2VpZ2h0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5tYXBEZWNvZGluZ1BhcmFtZXRlcnMubWF4RGlzcGxheUJvb3N0fVxuICAgICAqIEByZW1hcmtzIE5vbiBMb2dhcml0aG1pYyBzcGFjZVxuICAgICAqL1xuICAgIGdldCBtYXhEaXNwbGF5Qm9vc3QoKSB7IHJldHVybiB0aGlzLl9tYXhEaXNwbGF5Qm9vc3Q7IH1cbiAgICBzZXQgbWF4RGlzcGxheUJvb3N0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX21heERpc3BsYXlCb29zdCA9IE1hdGgubWF4KDEsIE1hdGgubWluKDY1NTA0LCB2YWx1ZSkpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVdlaWdodCgpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVXZWlnaHQoKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IChNYXRoLmxvZzIodGhpcy5fbWF4RGlzcGxheUJvb3N0KSAtIHRoaXMuX2hkckNhcGFjaXR5TWluKSAvICh0aGlzLl9oZHJDYXBhY2l0eU1heCAtIHRoaXMuX2hkckNhcGFjaXR5TWluKTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy53ZWlnaHRGYWN0b3IudmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWwpKTtcbiAgICB9XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIGdhaW4gbWFwIHVzaW5nIGEgV2ViR0xSZW5kZXJUYXJnZXRcbiAqXG4gKiBAY2F0ZWdvcnkgRGVjb2RpbmcgRnVuY3Rpb25zXG4gKiBAZ3JvdXAgRGVjb2RpbmcgRnVuY3Rpb25zXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gKiBpbXBvcnQge1xuICogICBNZXNoLFxuICogICBNZXNoQmFzaWNNYXRlcmlhbCxcbiAqICAgUGVyc3BlY3RpdmVDYW1lcmEsXG4gKiAgIFBsYW5lR2VvbWV0cnksXG4gKiAgIFNjZW5lLFxuICogICBUZXh0dXJlTG9hZGVyLFxuICogICBXZWJHTFJlbmRlcmVyXG4gKiB9IGZyb20gJ3RocmVlJ1xuICpcbiAqIGNvbnN0IHJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoKVxuICpcbiAqIGNvbnN0IHRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpXG4gKlxuICogLy8gbG9hZCBTRFIgUmVwcmVzZW50YXRpb25cbiAqIGNvbnN0IHNkciA9IGF3YWl0IHRleHR1cmVMb2FkZXIubG9hZEFzeW5jKCdzZHIuanBnJylcbiAqIC8vIGxvYWQgR2FpbiBtYXAgcmVjb3ZlcnkgaW1hZ2VcbiAqIGNvbnN0IGdhaW5NYXAgPSBhd2FpdCB0ZXh0dXJlTG9hZGVyLmxvYWRBc3luYygnZ2Fpbm1hcC5qcGcnKVxuICogLy8gbG9hZCBtZXRhZGF0YVxuICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCAoYXdhaXQgZmV0Y2goJ21ldGFkYXRhLmpzb24nKSkuanNvbigpXG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVjb2RlKHtcbiAqICAgc2RyLFxuICogICBnYWluTWFwLFxuICogICAvLyB0aGlzIGFsbG93cyB0byB1c2UgYHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZWAgZGlyZWN0bHlcbiAqICAgcmVuZGVyZXIsXG4gKiAgIC8vIHRoaXMgd2lsbCByZXN0b3JlIHRoZSBmdWxsIEhEUiByYW5nZVxuICogICBtYXhEaXNwbGF5Qm9vc3Q6IE1hdGgucG93KDIsIG1ldGFkYXRhLmhkckNhcGFjaXR5TWF4KSxcbiAqICAgLi4ubWV0YWRhdGFcbiAqIH0pXG4gKlxuICogY29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoKVxuICogLy8gYHJlc3VsdGAgY2FuIGJlIHVzZWQgdG8gcG9wdWxhdGUgYSBUZXh0dXJlXG4gKiBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gKiAgIG5ldyBQbGFuZUdlb21ldHJ5KCksXG4gKiAgIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlIH0pXG4gKiApXG4gKiBzY2VuZS5hZGQobWVzaClcbiAqIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCkpXG4gKlxuICogLy8gcmVzdWx0IG11c3QgYmUgbWFudWFsbHkgZGlzcG9zZWRcbiAqIC8vIHdoZW4geW91IGFyZSBkb25lIHVzaW5nIGl0XG4gKiByZXN1bHQuZGlzcG9zZSgpXG4gKlxuICogQHBhcmFtIHBhcmFtc1xuICogQHJldHVybnNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgV2ViR0xSZW5kZXJlciBmYWlscyB0byByZW5kZXIgdGhlIGdhaW4gbWFwXG4gKi9cbmNvbnN0IGRlY29kZSA9IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IHNkciwgZ2Fpbk1hcCwgcmVuZGVyZXIgfSA9IHBhcmFtcztcbiAgICBpZiAoc2RyLmNvbG9yU3BhY2UgIT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU0RSIENvbG9yc3BhY2UgbmVlZHMgdG8gYmUgKlNSR0JDb2xvclNwYWNlKiwgc2V0dGluZyBpdCBhdXRvbWF0aWNhbGx5Jyk7XG4gICAgICAgIHNkci5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U7XG4gICAgfVxuICAgIHNkci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgaWYgKGdhaW5NYXAuY29sb3JTcGFjZSAhPT0gTGluZWFyU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdHYWlubWFwIENvbG9yc3BhY2UgbmVlZHMgdG8gYmUgKkxpbmVhclNSR0JDb2xvclNwYWNlKiwgc2V0dGluZyBpdCBhdXRvbWF0aWNhbGx5Jyk7XG4gICAgICAgIGdhaW5NYXAuY29sb3JTcGFjZSA9IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgIH1cbiAgICBnYWluTWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsKHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBzZHIsXG4gICAgICAgIGdhaW5NYXBcbiAgICB9KTtcbiAgICBjb25zdCBxdWFkUmVuZGVyZXIgPSBuZXcgUXVhZFJlbmRlcmVyKHtcbiAgICAgICAgLy8gVE9ETzogdGhyZWUgdHlwZXMgYXJlIGdlbmVyaWMsIGVzbGludCBjb21wbGFpbnMgaGVyZSwgc2VlIGhvdyB3ZSBjYW4gc29sdmVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIHdpZHRoOiBzZHIuaW1hZ2Uud2lkdGgsXG4gICAgICAgIC8vIFRPRE86IHRocmVlIHR5cGVzIGFyZSBnZW5lcmljLCBlc2xpbnQgY29tcGxhaW5zIGhlcmUsIHNlZSBob3cgd2UgY2FuIHNvbHZlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICBoZWlnaHQ6IHNkci5pbWFnZS5oZWlnaHQsXG4gICAgICAgIHR5cGU6IEhhbGZGbG9hdFR5cGUsXG4gICAgICAgIGNvbG9yU3BhY2U6IExpbmVhclNSR0JDb2xvclNwYWNlLFxuICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIHJlbmRlclRhcmdldE9wdGlvbnM6IHBhcmFtcy5yZW5kZXJUYXJnZXRPcHRpb25zXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgICAgcXVhZFJlbmRlcmVyLnJlbmRlcigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgcmV0dXJuIHF1YWRSZW5kZXJlcjtcbn07XG5cbmNsYXNzIEdhaW5NYXBOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG5jbGFzcyBYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5cbmNvbnN0IGdldEF0dHJpYnV0ZSA9IChkZXNjcmlwdGlvbiwgbmFtZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IChfYSA9IGRlc2NyaXB0aW9uLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKG5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZVZhbHVlO1xuICAgIGlmICghcGFyc2VkVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRlc2NyaXB0aW9uLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpWzBdO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgncmRmOmxpJyk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gQXJyYXkuZnJvbSh2YWx1ZXMpLm1hcCh2ID0+IHYuaW5uZXJIVE1MKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR2Fpbm1hcCBtZXRhZGF0YSBjb250YWlucyBhbiBhcnJheSBvZiBpdGVtcyBmb3IgJHtuYW1lfSBidXQgaXRzIGxlbmd0aCBpcyBub3QgM2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCAke25hbWV9IGluIGdhaW5tYXAgbWV0YWRhdGFgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBwYXJzZWRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcbi8qKlxuICpcbiAqIEBwYXJhbSBpbnB1dFxuICogQHJldHVybnNcbiAqL1xuY29uc3QgZXh0cmFjdFhNUCA9IChpbnB1dCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IHN0cjtcbiAgICAvLyBzdXBwb3J0IG5vZGUgdGVzdCBlbnZpcm9ubWVudFxuICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBzdHIgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoaW5wdXQpO1xuICAgIGVsc2VcbiAgICAgICAgc3RyID0gaW5wdXQudG9TdHJpbmcoKTtcbiAgICBsZXQgc3RhcnQgPSBzdHIuaW5kZXhPZignPHg6eG1wbWV0YScpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICB3aGlsZSAoc3RhcnQgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0ci5pbmRleE9mKCd4OnhtcG1ldGE+Jywgc3RhcnQpO1xuICAgICAgICBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEwKTtcbiAgICAgICAgY29uc3QgeG1wQmxvY2sgPSBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHhtbERvY3VtZW50ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bXBCbG9jaywgJ3RleHQveG1sJyk7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHhtbERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdyZGY6RGVzY3JpcHRpb24nKVswXTtcbiAgICAgICAgICAgIGNvbnN0IGdhaW5NYXBNaW4gPSBnZXRBdHRyaWJ1dGUoZGVzY3JpcHRpb24sICdoZHJnbTpHYWluTWFwTWluJywgJzAnKTtcbiAgICAgICAgICAgIGNvbnN0IGdhaW5NYXBNYXggPSBnZXRBdHRyaWJ1dGUoZGVzY3JpcHRpb24sICdoZHJnbTpHYWluTWFwTWF4Jyk7XG4gICAgICAgICAgICBjb25zdCBnYW1tYSA9IGdldEF0dHJpYnV0ZShkZXNjcmlwdGlvbiwgJ2hkcmdtOkdhbW1hJywgJzEnKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFNEUiA9IGdldEF0dHJpYnV0ZShkZXNjcmlwdGlvbiwgJ2hkcmdtOk9mZnNldFNEUicsICcwLjAxNTYyNScpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0SERSID0gZ2V0QXR0cmlidXRlKGRlc2NyaXB0aW9uLCAnaGRyZ206T2Zmc2V0SERSJywgJzAuMDE1NjI1Jyk7XG4gICAgICAgICAgICBsZXQgaGRyQ2FwYWNpdHlNaW4gPSAoX2EgPSBkZXNjcmlwdGlvbi5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnaGRyZ206SERSQ2FwYWNpdHlNaW4nKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIGlmICghaGRyQ2FwYWNpdHlNaW4pXG4gICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNaW4gPSAnMCc7XG4gICAgICAgICAgICBjb25zdCBoZHJDYXBhY2l0eU1heCA9IChfYiA9IGRlc2NyaXB0aW9uLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdoZHJnbTpIRFJDYXBhY2l0eU1heCcpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iubm9kZVZhbHVlO1xuICAgICAgICAgICAgaWYgKCFoZHJDYXBhY2l0eU1heClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGxldGUgZ2Fpbm1hcCBtZXRhZGF0YScpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnYWluTWFwTWluOiBBcnJheS5pc0FycmF5KGdhaW5NYXBNaW4pID8gZ2Fpbk1hcE1pbi5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KGdhaW5NYXBNaW4pLCBwYXJzZUZsb2F0KGdhaW5NYXBNaW4pLCBwYXJzZUZsb2F0KGdhaW5NYXBNaW4pXSxcbiAgICAgICAgICAgICAgICBnYWluTWFwTWF4OiBBcnJheS5pc0FycmF5KGdhaW5NYXBNYXgpID8gZ2Fpbk1hcE1heC5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KGdhaW5NYXBNYXgpLCBwYXJzZUZsb2F0KGdhaW5NYXBNYXgpLCBwYXJzZUZsb2F0KGdhaW5NYXBNYXgpXSxcbiAgICAgICAgICAgICAgICBnYW1tYTogQXJyYXkuaXNBcnJheShnYW1tYSkgPyBnYW1tYS5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KGdhbW1hKSwgcGFyc2VGbG9hdChnYW1tYSksIHBhcnNlRmxvYXQoZ2FtbWEpXSxcbiAgICAgICAgICAgICAgICBvZmZzZXRTZHI6IEFycmF5LmlzQXJyYXkob2Zmc2V0U0RSKSA/IG9mZnNldFNEUi5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KG9mZnNldFNEUiksIHBhcnNlRmxvYXQob2Zmc2V0U0RSKSwgcGFyc2VGbG9hdChvZmZzZXRTRFIpXSxcbiAgICAgICAgICAgICAgICBvZmZzZXRIZHI6IEFycmF5LmlzQXJyYXkob2Zmc2V0SERSKSA/IG9mZnNldEhEUi5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KG9mZnNldEhEUiksIHBhcnNlRmxvYXQob2Zmc2V0SERSKSwgcGFyc2VGbG9hdChvZmZzZXRIRFIpXSxcbiAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1pbjogcGFyc2VGbG9hdChoZHJDYXBhY2l0eU1pbiksXG4gICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNYXg6IHBhcnNlRmxvYXQoaGRyQ2FwYWNpdHlNYXgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBzdHIuaW5kZXhPZignPHg6eG1wbWV0YScsIGVuZCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNUEYgRXh0cmFjdG9yIChNdWx0aSBQaWN0dXJlIEZvcm1hdCBFeHRyYWN0b3IpXG4gKiBCeSBIZW5yaWsgUyBOaWxzc29uIDIwMTlcbiAqXG4gKiBFeHRyYWN0cyBpbWFnZXMgc3RvcmVkIGluIGltYWdlcyBiYXNlZCBvbiB0aGUgTVBGIGZvcm1hdCAoZm91bmQgaGVyZTogaHR0cHM6Ly93d3cuY2lwYS5qcC9lL3N0ZC9zdGQtc2VjLmh0bWxcbiAqIHVuZGVyIFwiQ0lQQSBEQy0wMDctVHJhbnNsYXRpb24tMjAyMSBNdWx0aS1QaWN0dXJlIEZvcm1hdFwiXG4gKlxuICogT3Zlcmx5IGNvbW1lbnRlZCwgYW5kIHdpdGhvdXQgaW50ZW50aW9uIG9mIGJlaW5nIGNvbXBsZXRlIG9yIHByb2R1Y3Rpb24gcmVhZHkuXG4gKiBDcmVhdGVkIHRvIGV4dHJhY3QgZGVwdGggbWFwcyBmcm9tIGlQaG9uZSBpbWFnZXMsIGFuZCB0byBsZWFybiBhYm91dCBpbWFnZSBtZXRhZGF0YS5cbiAqIEt1ZG9zIHRvOiBQaGlsIEhhcnZleSAoZXhpZnRvb2wpLCBKYXVtZSBTYW5jaGV6IChhbmRyb2lkLWxlbnMtYmx1ci1kZXB0aC1leHRyYWN0b3IpXG4gKi9cbmNsYXNzIE1QRkV4dHJhY3RvciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkZWJ1Zzogb3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlYnVnIDogZmFsc2UsXG4gICAgICAgICAgICBleHRyYWN0RklJOiBvcHRpb25zICYmIG9wdGlvbnMuZXh0cmFjdEZJSSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5leHRyYWN0RklJIDogdHJ1ZSxcbiAgICAgICAgICAgIGV4dHJhY3ROb25GSUk6IG9wdGlvbnMgJiYgb3B0aW9ucy5leHRyYWN0Tm9uRklJICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmV4dHJhY3ROb25GSUkgOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGV4dHJhY3QoaW1hZ2VBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVidWcgPSB0aGlzLm9wdGlvbnMuZGVidWc7XG4gICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhpbWFnZUFycmF5QnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgICAgICAvLyBJZiB5b3UncmUgZXhlY3V0aW5nIHRoaXMgbGluZSBvbiBhIGJpZyBlbmRpYW4gbWFjaGluZSwgaXQnbGwgYmUgcmV2ZXJzZWQuXG4gICAgICAgICAgICAvLyBiaWdFbmQgZnVydGhlciBkb3duIHRob3VnaCwgcmVmZXJzIHRvIHRoZSBlbmRpYW5uZXNzIG9mIHRoZSBpbWFnZSBpdHNlbGYuXG4gICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KDApICE9PSAweGZmZDgpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdOb3QgYSB2YWxpZCBqcGVnJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFWaWV3LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICAgICAgICAgIGxldCBsb29wcyA9IDA7XG4gICAgICAgICAgICBsZXQgbWFya2VyOyAvLyBBUFAjIG1hcmtlclxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICgrK2xvb3BzID4gMjUwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZvdW5kIG5vIG1hcmtlciBhZnRlciAke2xvb3BzfSBsb29wcyDwn5i1YCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpICE9PSAweGZmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYE5vdCBhIHZhbGlkIG1hcmtlciBhdCBvZmZzZXQgMHgke29mZnNldC50b1N0cmluZygxNil9LCBmb3VuZDogMHgke2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkudG9TdHJpbmcoMTYpfWApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXJrZXIgPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNYXJrZXI6ICR7bWFya2VyLnRvU3RyaW5nKDE2KX1gKTtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyID09PSAweGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBBUFAyIG1hcmtlciAoMHhmZmUyKScpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrcyBmb3IgaVBob25lIDggUGx1cywgWCwgYW5kIFhTTWF4LiBPciBhbnkgcGhvdG9zIG9mIE1QRiBmb3JtYXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdyZWF0IHdheSB0byB2aXN1YWxpemUgaW1hZ2UgaW5mb3JtYXRpb24gaW4gaHRtbCBpcyB1c2luZyBFeGlmdG9vbC4gRS5nLjpcbiAgICAgICAgICAgICAgICAgICAgLy8gLi9leGlmdG9vbC5leGUgLWh0bWxkdW1wIC13YW50VHJhaWxlciBwaG90by5qcGcgPiBwaG90by5odG1sXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdFB0ID0gb2Zmc2V0ICsgNDtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogIFN0cnVjdHVyZSBvZiB0aGUgTVAgRm9ybWF0IElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogIE9mZnNldCBBZGRyLiAgfCBDb2RlIChIZXgpICB8IERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqICArMDAgICAgICAgICAgICAgZmYgICAgICAgICAgICBNYXJrZXIgUHJlZml4ICAgICAgPC0tIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgKiAgKzAxICAgICAgICAgICAgIGUyICAgICAgICAgICAgQVBQMlxuICAgICAgICAgICAgICAgICAgICAgKiAgKzAyICAgICAgICAgICAgICNuICAgICAgICAgICAgQVBQMiBGaWVsZCBMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICogICswMyAgICAgICAgICAgICAjbiAgICAgICAgICAgIEFQUDIgRmllbGQgTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAqICArMDQgICAgICAgICAgICAgNGQgICAgICAgICAgICAnTScgICAgICAgICAgICAgICAgPC0tIGZvcm1hdFB0XG4gICAgICAgICAgICAgICAgICAgICAqICArMDUgICAgICAgICAgICAgNTAgICAgICAgICAgICAnUCdcbiAgICAgICAgICAgICAgICAgICAgICogICswNiAgICAgICAgICAgICA0NiAgICAgICAgICAgICdGJ1xuICAgICAgICAgICAgICAgICAgICAgKiAgKzA3ICAgICAgICAgICAgIDAwICAgICAgICAgICAgTlVMTFxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwtLSB0aWZmT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDMyKGZvcm1hdFB0KSA9PT0gMHg0ZDUwNDYwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgTVBGIHRhZywgc28gd2Ugc3RhcnQgZGlnIG91dCBzdWIgaW1hZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWZmT2Zmc2V0ID0gZm9ybWF0UHQgKyA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpZ0VuZDsgLy8gRW5kaWFubmVzcyBmcm9tIFRJRkYgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZXN0IGZvciBUSUZGIHZhbGlkaXR5IGFuZCBlbmRpYW5uZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAweDQ5NDkgYW5kIDB4NEQ0RCAoJ0lJJyBhbmQgJ01NJykgbWFya3MgTGl0dGxlIEVuZGlhbiBhbmQgQmlnIEVuZGlhblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0OTQ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlnRW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NGQ0ZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ0VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdObyB2YWxpZCBlbmRpYW5uZXNzIG1hcmtlciBmb3VuZCBpbiBUSUZGIGhlYWRlcicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQgKyAyLCAhYmlnRW5kKSAhPT0gMHgwMDJhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm90IHZhbGlkIFRJRkYgZGF0YSEgKG5vIDB4MDAyQSBtYXJrZXIpJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMyIGJpdCBudW1iZXIgc3RhdGluZyB0aGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSA4IEJ5dGUgTVAgSGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBNUCBJbmRleCBJRkQgTGVhc3QgcG9zc2libGUgdmFsdWUgaXMgdGh1cyA4IChtZWFucyAwIG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0SUZET2Zmc2V0ID0gZGF0YVZpZXcuZ2V0VWludDMyKHRpZmZPZmZzZXQgKyA0LCAhYmlnRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdElGRE9mZnNldCA8IDB4MDAwMDAwMDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdOb3QgdmFsaWQgVElGRiBkYXRhISAoRmlyc3Qgb2Zmc2V0IGxlc3MgdGhhbiA4KScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIGFoZWFkIHRvIE1QIEluZGV4IElGRFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHdlJ3JlIGF0IHRoZSBmaXJzdCBJRkQsIHNvIGZpcnN0SUZET2Zmc2V0IHBvaW50cyB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTVAgSW5kZXggSUZEIGFuZCBub3QgTVAgQXR0cmlidXRlcyBJRkQuIChJZiB3ZSB0cnkgZXh0cmFjdCBmcm9tIGEgc3ViIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZmFpbCBzaWxlbnRseSBoZXJlIGR1ZSB0byB0aGlzIGFzc3VtcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCAoMiBCeXRlKSB8IE1QIEluZGV4IEZpZWxkcyBhLmsuYS4gTVAgRW50cmllcyAoY291bnQgKiAxMiBCeXRlKSB8IE9mZnNldCBvZiBOZXh0IElGRCAoNCBCeXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyU3RhcnQgPSB0aWZmT2Zmc2V0ICsgZmlyc3RJRkRPZmZzZXQ7IC8vIFN0YXJ0IG9mIElGRCAoSW1hZ2UgRmlsZSBEaXJlY3RvcnkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IGRhdGFWaWV3LmdldFVpbnQxNihkaXJTdGFydCwgIWJpZ0VuZCk7IC8vIENvdW50IG9mIE1QRW50cmllcyAoMiBCeXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBpbmZvIGZyb20gTVBFbnRyaWVzIChzdGFydGluZyBhZnRlciBDb3VudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXNTdGFydCA9IGRpclN0YXJ0ICsgMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBudW1iZXJPZkltYWdlcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZW50cmllc1N0YXJ0OyBpIDwgZW50cmllc1N0YXJ0ICsgMTIgKiBjb3VudDsgaSArPSAxMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggZW50cnkgaXMgMTIgQnl0ZXMgbG9uZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIE1QIEluZGV4IElGRCB0YWdzLCBoZXJlIHdlIG9ubHkgdGFrZSB0YWcgMHhiMDAxID0gTnVtYmVyIG9mIGltYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYoaSwgIWJpZ0VuZCkgPT09IDB4YjAwMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZWQgaW4gTGFzdCA0IGJ5dGVzIG9mIGl0cyAxMiBCeXRlIGVudHJ5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkltYWdlcyA9IGRhdGFWaWV3LmdldFVpbnQzMihpICsgOCwgIWJpZ0VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dElGRE9mZnNldExlbiA9IDQ7IC8vIDQgQnl0ZSBvZmZzZXQgZmllbGQgdGhhdCBhcHBlYXJzIGFmdGVyIE1QIEluZGV4IElGRCB0YWdzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBNUEltYWdlTGlzdFZhbFB0ID0gZGlyU3RhcnQgKyAyICsgY291bnQgKiAxMiArIG5leHRJRkRPZmZzZXRMZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBNUEltYWdlTGlzdFZhbFB0OyBpIDwgTVBJbWFnZUxpc3RWYWxQdCArIG51bWJlck9mSW1hZ2VzICogMTY7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTVBUeXBlOiBkYXRhVmlldy5nZXRVaW50MzIoaSwgIWJpZ0VuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGRhdGFWaWV3LmdldFVpbnQzMihpICsgNCwgIWJpZ0VuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgb2Zmc2V0IGlzIHNwZWNpZmllZCByZWxhdGl2ZSB0byB0aGUgYWRkcmVzcyBvZiB0aGUgTVAgRW5kaWFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpZWxkIGluIHRoZSBNUCBIZWFkZXIsIHVubGVzcyB0aGUgaW1hZ2UgaXMgYSBGaXJzdCBJbmRpdmlkdWFsIEltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB3aGljaCBjYXNlIHRoZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IHNoYWxsIGJlIE5VTEwgKDB4MDAwMDAwMDApLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0OiBkYXRhVmlldy5nZXRVaW50MzIoaSArIDgsICFiaWdFbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRhbnRJbWFnZXM6IGRhdGFWaWV3LmdldFVpbnQzMihpICsgMTIsICFiaWdFbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRklJOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWFnZS5kYXRhT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGFPZmZzZXQgaXMgMHgwMDAwMDAwMCBmb3IgRmlyc3QgSW5kaXZpZHVhbCBJbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5zdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLmlzRklJID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnN0YXJ0ID0gdGlmZk9mZnNldCArIGltYWdlLmRhdGFPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLmlzRklJID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLmVuZCA9IGltYWdlLnN0YXJ0ICsgaW1hZ2Uuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXMucHVzaChpbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dHJhY3ROb25GSUkgJiYgaW1hZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckJsb2IgPSBuZXcgQmxvYihbZGF0YVZpZXddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmlzRklJICYmICF0aGlzLm9wdGlvbnMuZXh0cmFjdEZJSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgRklJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VCbG9iID0gYnVmZmVyQmxvYi5zbGljZShpbWFnZS5zdGFydCwgaW1hZ2UuZW5kICsgMSwgJ2ltYWdlL2pwZWcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGltYWdlVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpbWFnZUJsb2IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltYWdlLmltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltYWdlLmltZy5zcmMgPSBpbWFnZVVybFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWdzLnB1c2goaW1hZ2VCbG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbWdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMiArIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIFhNUCBNZXRhZGF0YSBhbmQgdGhlIGdhaW4gbWFwIHJlY292ZXJ5IGltYWdlXG4gKiBmcm9tIGEgc2luZ2xlIEpQRUcgZmlsZS5cbiAqXG4gKiBAY2F0ZWdvcnkgRGVjb2RpbmcgRnVuY3Rpb25zXG4gKiBAZ3JvdXAgRGVjb2RpbmcgRnVuY3Rpb25zXG4gKiBAcGFyYW0ganBlZ0ZpbGUgYW4gYFVpbnQ4QXJyYXlgIGNvbnRhaW5pbmcgYW5kIGVuY29kZWQgSlBFRyBmaWxlXG4gKiBAcmV0dXJucyBhbiBzZHIgYFVpbnQ4QXJyYXlgIGNvbXByZXNzZWQgaW4gSlBFRywgYSBnYWluTWFwIGBVaW50OEFycmF5YCBjb21wcmVzc2VkIGluIEpQRUcgYW5kIHRoZSBYTVAgcGFyc2VkIFhNUCBtZXRhZGF0YVxuICogQHRocm93cyBFcnJvciBpZiBYTVAgTWV0YWRhdGEgaXMgbm90IGZvdW5kXG4gKiBAdGhyb3dzIEVycm9yIGlmIEdhaW4gbWFwIGltYWdlIGlzIG5vdCBmb3VuZFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEZpbGVMb2FkZXIgfSBmcm9tICd0aHJlZSdcbiAqIGltcG9ydCB7IGV4dHJhY3RHYWlubWFwRnJvbUpQRUcgfSBmcm9tICdAbW9ub2dyaWQvZ2Fpbm1hcC1qcydcbiAqXG4gKiBjb25zdCBqcGVnRmlsZSA9IGF3YWl0IG5ldyBGaWxlTG9hZGVyKClcbiAqICAuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpXG4gKiAgLmxvYWRBc3luYygnaW1hZ2UuanBnJylcbiAqXG4gKiBjb25zdCB7IHNkciwgZ2Fpbk1hcCwgbWV0YWRhdGEgfSA9IGV4dHJhY3RHYWlubWFwRnJvbUpQRUcoanBlZ0ZpbGUpXG4gKi9cbmNvbnN0IGV4dHJhY3RHYWlubWFwRnJvbUpQRUcgPSBhc3luYyAoanBlZ0ZpbGUpID0+IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGV4dHJhY3RYTVAoanBlZ0ZpbGUpO1xuICAgIGlmICghbWV0YWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IoJ0dhaW4gbWFwIFhNUCBtZXRhZGF0YSBub3QgZm91bmQnKTtcbiAgICBjb25zdCBtcGZFeHRyYWN0b3IgPSBuZXcgTVBGRXh0cmFjdG9yKHsgZXh0cmFjdEZJSTogdHJ1ZSwgZXh0cmFjdE5vbkZJSTogdHJ1ZSB9KTtcbiAgICBjb25zdCBpbWFnZXMgPSBhd2FpdCBtcGZFeHRyYWN0b3IuZXh0cmFjdChqcGVnRmlsZSk7XG4gICAgaWYgKGltYWdlcy5sZW5ndGggIT09IDIpXG4gICAgICAgIHRocm93IG5ldyBHYWluTWFwTm90Rm91bmRFcnJvcignR2FpbiBtYXAgcmVjb3ZlcnkgaW1hZ2Ugbm90IGZvdW5kJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2RyOiBuZXcgVWludDhBcnJheShhd2FpdCBpbWFnZXNbMF0uYXJyYXlCdWZmZXIoKSksXG4gICAgICAgIGdhaW5NYXA6IG5ldyBVaW50OEFycmF5KGF3YWl0IGltYWdlc1sxXS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgICAgbWV0YWRhdGFcbiAgICB9O1xufTtcblxuLyoqXG4gKiBwcml2YXRlIGZ1bmN0aW9uLCBhc3luYyBnZXQgaW1hZ2UgZnJvbSBibG9iXG4gKlxuICogQHBhcmFtIGJsb2JcbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IGdldEhUTUxJbWFnZUZyb21CbG9iID0gKGJsb2IpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHsgcmVzb2x2ZShpbWcpOyB9O1xuICAgICAgICBpbWcub25lcnJvciA9IChlKSA9PiB7IHJlamVjdChlKTsgfTtcbiAgICAgICAgaW1nLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgfSk7XG59O1xuXG5jbGFzcyBMb2FkZXJCYXNlIGV4dGVuZHMgTG9hZGVyIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZW5kZXJlclxuICAgICAqIEBwYXJhbSBtYW5hZ2VyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIG1hbmFnZXIpIHtcbiAgICAgICAgc3VwZXIobWFuYWdlcik7XG4gICAgICAgIGlmIChyZW5kZXJlcilcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2ludGVybmFsTG9hZGluZ01hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgcmVuZGVyZXIgdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRoZSBnYWluIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbmRlcmVyXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzZXRSZW5kZXJlcihyZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgcmVuZGVyVGFyZ2V0IG9wdGlvbnMgdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRoZSBnYWluIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHNldFJlbmRlclRhcmdldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBwcmVwYXJlUXVhZFJlbmRlcmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBBbiBleGlzdGluZyBXZWJHTCBSZW5kZXJlciB3YXMgbm90IHBhc3NlZCB0byB0aGlzIExvYWRlciBjb25zdHJ1Y3RvciBvciBpbiBzZXRSZW5kZXJlciwgdGhlIHJlc3VsdCBvZiB0aGlzIExvYWRlciB3aWxsIG5lZWQgdG8gYmUgY29udmVydGVkIHRvIGEgRGF0YSBUZXh0dXJlIHdpdGggdG9EYXRhVGV4dHVyZSgpIGJlZm9yZSB5b3UgY2FuIHVzZSBpdCBpbiB5b3VyIHJlbmRlcmVyLicpO1xuICAgICAgICAvLyB0ZW1wb3JhcnkgdmFsdWVzXG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IEdhaW5NYXBEZWNvZGVyTWF0ZXJpYWwoe1xuICAgICAgICAgICAgZ2Fpbk1hcE1heDogWzEsIDEsIDFdLFxuICAgICAgICAgICAgZ2Fpbk1hcE1pbjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgZ2FtbWE6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgIG9mZnNldEhkcjogWzEsIDEsIDFdLFxuICAgICAgICAgICAgb2Zmc2V0U2RyOiBbMSwgMSwgMV0sXG4gICAgICAgICAgICBoZHJDYXBhY2l0eU1heDogMSxcbiAgICAgICAgICAgIGhkckNhcGFjaXR5TWluOiAwLFxuICAgICAgICAgICAgbWF4RGlzcGxheUJvb3N0OiAxLFxuICAgICAgICAgICAgZ2Fpbk1hcDogbmV3IFRleHR1cmUoKSxcbiAgICAgICAgICAgIHNkcjogbmV3IFRleHR1cmUoKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWFkUmVuZGVyZXIoe1xuICAgICAgICAgICAgd2lkdGg6IDE2LFxuICAgICAgICAgICAgaGVpZ2h0OiAxNixcbiAgICAgICAgICAgIHR5cGU6IEhhbGZGbG9hdFR5cGUsXG4gICAgICAgICAgICBjb2xvclNwYWNlOiBMaW5lYXJTUkdCQ29sb3JTcGFjZSxcbiAgICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgICAgcmVuZGVyZXI6IHRoaXMuX3JlbmRlcmVyLFxuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0T3B0aW9uczogdGhpcy5fcmVuZGVyVGFyZ2V0T3B0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBxdWFkUmVuZGVyZXJcbiAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBzZHJCdWZmZXJcbiAgICogQHBhcmFtIGdhaW5NYXBCdWZmZXJcbiAgICovXG4gICAgYXN5bmMgcmVuZGVyKHF1YWRSZW5kZXJlciwgbWV0YWRhdGEsIHNkckJ1ZmZlciwgZ2Fpbk1hcEJ1ZmZlcikge1xuICAgICAgICAvLyB0aGlzIGlzIG9wdGlvbmFsLCB3aWxsIHJlbmRlciBhIGJsYWNrIGdhaW4tbWFwIGlmIG5vdCBwcmVzZW50XG4gICAgICAgIGNvbnN0IGdhaW5NYXBCbG9iID0gZ2Fpbk1hcEJ1ZmZlciA/IG5ldyBCbG9iKFtnYWluTWFwQnVmZmVyXSwgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNkckJsb2IgPSBuZXcgQmxvYihbc2RyQnVmZmVyXSwgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICAgIGxldCBzZHJJbWFnZTtcbiAgICAgICAgbGV0IGdhaW5NYXBJbWFnZTtcbiAgICAgICAgbGV0IG5lZWRzRmxpcCA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGdhaW5NYXBCbG9iID8gZ2V0SFRNTEltYWdlRnJvbUJsb2IoZ2Fpbk1hcEJsb2IpIDogUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgZ2V0SFRNTEltYWdlRnJvbUJsb2Ioc2RyQmxvYilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgZ2Fpbk1hcEltYWdlID0gcmVzWzBdO1xuICAgICAgICAgICAgc2RySW1hZ2UgPSByZXNbMV07XG4gICAgICAgICAgICBuZWVkc0ZsaXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGdhaW5NYXBCbG9iID8gY3JlYXRlSW1hZ2VCaXRtYXAoZ2Fpbk1hcEJsb2IsIHsgaW1hZ2VPcmllbnRhdGlvbjogJ2ZsaXBZJyB9KSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUltYWdlQml0bWFwKHNkckJsb2IsIHsgaW1hZ2VPcmllbnRhdGlvbjogJ2ZsaXBZJyB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBnYWluTWFwSW1hZ2UgPSByZXNbMF07XG4gICAgICAgICAgICBzZHJJbWFnZSA9IHJlc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnYWluTWFwID0gbmV3IFRleHR1cmUoZ2Fpbk1hcEltYWdlIHx8IG5ldyBJbWFnZURhdGEoMiwgMiksIFVWTWFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIsIFJHQkFGb3JtYXQsIFVuc2lnbmVkQnl0ZVR5cGUsIDEsIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgZ2Fpbk1hcC5mbGlwWSA9IG5lZWRzRmxpcDtcbiAgICAgICAgZ2Fpbk1hcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHNkciA9IG5ldyBUZXh0dXJlKHNkckltYWdlLCBVVk1hcHBpbmcsIENsYW1wVG9FZGdlV3JhcHBpbmcsIENsYW1wVG9FZGdlV3JhcHBpbmcsIExpbmVhckZpbHRlciwgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLCBSR0JBRm9ybWF0LCBVbnNpZ25lZEJ5dGVUeXBlLCAxLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIHNkci5mbGlwWSA9IG5lZWRzRmxpcDtcbiAgICAgICAgc2RyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcXVhZFJlbmRlcmVyLndpZHRoID0gc2RySW1hZ2Uud2lkdGg7XG4gICAgICAgIHF1YWRSZW5kZXJlci5oZWlnaHQgPSBzZHJJbWFnZS5oZWlnaHQ7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5nYWluTWFwID0gZ2Fpbk1hcDtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLnNkciA9IHNkcjtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmdhaW5NYXBNaW4gPSBtZXRhZGF0YS5nYWluTWFwTWluO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuZ2Fpbk1hcE1heCA9IG1ldGFkYXRhLmdhaW5NYXBNYXg7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5vZmZzZXRIZHIgPSBtZXRhZGF0YS5vZmZzZXRIZHI7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5vZmZzZXRTZHIgPSBtZXRhZGF0YS5vZmZzZXRTZHI7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5nYW1tYSA9IG1ldGFkYXRhLmdhbW1hO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuaGRyQ2FwYWNpdHlNaW4gPSBtZXRhZGF0YS5oZHJDYXBhY2l0eU1pbjtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmhkckNhcGFjaXR5TWF4ID0gbWV0YWRhdGEuaGRyQ2FwYWNpdHlNYXg7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5tYXhEaXNwbGF5Qm9vc3QgPSBNYXRoLnBvdygyLCBtZXRhZGF0YS5oZHJDYXBhY2l0eU1heCk7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHF1YWRSZW5kZXJlci5yZW5kZXIoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBUaHJlZS5qcyBMb2FkZXIgZm9yIHRoZSBnYWluIG1hcCBmb3JtYXQuXG4gKlxuICogQGNhdGVnb3J5IExvYWRlcnNcbiAqIEBncm91cCBMb2FkZXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEdhaW5NYXBMb2FkZXIgfSBmcm9tICdAbW9ub2dyaWQvZ2Fpbm1hcC1qcydcbiAqIGltcG9ydCB7XG4gKiAgIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuICogICBMaW5lYXJGaWx0ZXIsXG4gKiAgIE1lc2gsXG4gKiAgIE1lc2hCYXNpY01hdGVyaWFsLFxuICogICBQZXJzcGVjdGl2ZUNhbWVyYSxcbiAqICAgUGxhbmVHZW9tZXRyeSxcbiAqICAgU2NlbmUsXG4gKiAgIFdlYkdMUmVuZGVyZXJcbiAqIH0gZnJvbSAndGhyZWUnXG4gKlxuICogY29uc3QgcmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpXG4gKlxuICogY29uc3QgbG9hZGVyID0gbmV3IEdhaW5NYXBMb2FkZXIocmVuZGVyZXIpXG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYyhbJ3Nkci5qcGVnJywgJ2dhaW5tYXAuanBlZycsICdtZXRhZGF0YS5qc29uJ10pXG4gKiAvLyBgcmVzdWx0YCBjYW4gYmUgdXNlZCB0byBwb3B1bGF0ZSBhIFRleHR1cmVcbiAqXG4gKiBjb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpXG4gKiBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gKiAgIG5ldyBQbGFuZUdlb21ldHJ5KCksXG4gKiAgIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlIH0pXG4gKiApXG4gKiBzY2VuZS5hZGQobWVzaClcbiAqIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCkpXG4gKlxuICogLy8gU3RhcnRpbmcgZnJvbSB0aHJlZS5qcyByMTU5XG4gKiAvLyBgcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlYCBjYW5cbiAqIC8vIGFsc28gYmUgdXNlZCBhcyBFcXVpcmVjdGFuZ3VsYXIgc2NlbmUgYmFja2dyb3VuZFxuICogLy9cbiAqIC8vIGl0IHdhcyBwcmV2aW91c2x5IG5lZWRlZCB0byBjb252ZXJ0IGl0XG4gKiAvLyB0byBhIERhdGFUZXh0dXJlIHdpdGggYHJlc3VsdC50b0RhdGFUZXh0dXJlKClgXG4gKiBzY2VuZS5iYWNrZ3JvdW5kID0gcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlXG4gKiBzY2VuZS5iYWNrZ3JvdW5kLm1hcHBpbmcgPSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZ1xuICpcbiAqIC8vIHJlc3VsdCBtdXN0IGJlIG1hbnVhbGx5IGRpc3Bvc2VkXG4gKiAvLyB3aGVuIHlvdSBhcmUgZG9uZSB1c2luZyBpdFxuICogcmVzdWx0LmRpc3Bvc2UoKVxuICpcbiAqL1xuY2xhc3MgR2Fpbk1hcExvYWRlciBleHRlbmRzIExvYWRlckJhc2Uge1xuICAgIC8qKlxuICAgICAqIExvYWRzIGEgZ2Fpbm1hcCB1c2luZyBzZXBhcmF0ZSBkYXRhXG4gICAgICogKiBzZHIgaW1hZ2VcbiAgICAgKiAqIGdhaW4gbWFwIGltYWdlXG4gICAgICogKiBtZXRhZGF0YSBqc29uXG4gICAgICpcbiAgICAgKiB1c2VmdWwgZm9yIHdlYnAgZ2FpbiBtYXBzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJscyBBbiBhcnJheSBpbiB0aGUgZm9ybSBvZiBbc2RyLmpwZywgZ2Fpbm1hcC5qcGcsIG1ldGFkYXRhLmpzb25dXG4gICAgICogQHBhcmFtIG9uTG9hZCBMb2FkIGNvbXBsZXRlIGNhbGxiYWNrLCB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSBvblByb2dyZXNzIFByb2dyZXNzIGNhbGxiYWNrLCB3aWxsIHJlY2VpdmUgYSB7QGxpbmsgUHJvZ3Jlc3NFdmVudH1cbiAgICAgKiBAcGFyYW0gb25FcnJvciBFcnJvciBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgbG9hZChbc2RyVXJsLCBnYWluTWFwVXJsLCBtZXRhZGF0YVVybF0sIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgICAgICBjb25zdCBxdWFkUmVuZGVyZXIgPSB0aGlzLnByZXBhcmVRdWFkUmVuZGVyZXIoKTtcbiAgICAgICAgbGV0IHNkcjtcbiAgICAgICAgbGV0IGdhaW5NYXA7XG4gICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgY29uc3QgbG9hZENoZWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNkciAmJiBnYWluTWFwICYmIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gc29sdmVzICMxNlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyKHF1YWRSZW5kZXJlciwgbWV0YWRhdGEsIHNkciwgZ2Fpbk1hcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHNkclVybCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IoZ2Fpbk1hcFVybCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkxvYWQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZChxdWFkUmVuZGVyZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRW5kKHNkclVybCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQoZ2Fpbk1hcFVybCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgIHF1YWRSZW5kZXJlci5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgc2RyTGVuZ3RoQ29tcHV0YWJsZSA9IHRydWU7XG4gICAgICAgIGxldCBzZHJUb3RhbCA9IDA7XG4gICAgICAgIGxldCBzZHJMb2FkZWQgPSAwO1xuICAgICAgICBsZXQgZ2Fpbk1hcExlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xuICAgICAgICBsZXQgZ2Fpbk1hcFRvdGFsID0gMDtcbiAgICAgICAgbGV0IGdhaW5NYXBMb2FkZWQgPSAwO1xuICAgICAgICBsZXQgbWV0YWRhdGFMZW5ndGhDb21wdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgbGV0IG1ldGFkYXRhVG90YWwgPSAwO1xuICAgICAgICBsZXQgbWV0YWRhdGFMb2FkZWQgPSAwO1xuICAgICAgICBjb25zdCBwcm9ncmVzc0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbCA9IHNkclRvdGFsICsgZ2Fpbk1hcFRvdGFsICsgbWV0YWRhdGFUb3RhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkZWQgPSBzZHJMb2FkZWQgKyBnYWluTWFwTG9hZGVkICsgbWV0YWRhdGFMb2FkZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoQ29tcHV0YWJsZSA9IHNkckxlbmd0aENvbXB1dGFibGUgJiYgZ2Fpbk1hcExlbmd0aENvbXB1dGFibGUgJiYgbWV0YWRhdGFMZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MobmV3IFByb2dyZXNzRXZlbnQoJ3Byb2dyZXNzJywgeyBsZW5ndGhDb21wdXRhYmxlLCBsb2FkZWQsIHRvdGFsIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydChzZHJVcmwpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KGdhaW5NYXBVcmwpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KG1ldGFkYXRhVXJsKTtcbiAgICAgICAgY29uc3Qgc2RyTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgIHNkckxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG4gICAgICAgIHNkckxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgICAgIHNkckxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgIHNkckxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICBzZHJMb2FkZXIubG9hZChzZHJVcmwsIGFzeW5jIChidWZmZXIpID0+IHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgICAgICAgICAgIHRoaXMgY29uZGl0aW9uIGV4aXN0cyBvbmx5IGJlY2F1c2Ugb2YgdGhyZWUuanMgdHlwZXMgKyBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2RyIGJ1ZmZlcicpO1xuICAgICAgICAgICAgc2RyID0gYnVmZmVyO1xuICAgICAgICAgICAgYXdhaXQgbG9hZENoZWNrKCk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBzZHJMZW5ndGhDb21wdXRhYmxlID0gZS5sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgc2RyTG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICBzZHJUb3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXIoKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHNkclVybCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBnYWluTWFwTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgIGdhaW5NYXBMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgICBnYWluTWFwTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgICAgZ2Fpbk1hcExvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgIGdhaW5NYXBMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgZ2Fpbk1hcExvYWRlci5sb2FkKGdhaW5NYXBVcmwsIGFzeW5jIChidWZmZXIpID0+IHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgICAgICAgICAgIHRoaXMgY29uZGl0aW9uIGV4aXN0cyBvbmx5IGJlY2F1c2Ugb2YgdGhyZWUuanMgdHlwZXMgKyBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZ2Fpbm1hcCBidWZmZXInKTtcbiAgICAgICAgICAgIGdhaW5NYXAgPSBidWZmZXI7XG4gICAgICAgICAgICBhd2FpdCBsb2FkQ2hlY2soKTtcbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIGdhaW5NYXBMZW5ndGhDb21wdXRhYmxlID0gZS5sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgZ2Fpbk1hcExvYWRlZCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgZ2Fpbk1hcFRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcigpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IoZ2Fpbk1hcFVybCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXRhZGF0YUxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMuX2ludGVybmFsTG9hZGluZ01hbmFnZXIpO1xuICAgICAgICAvLyBtZXRhZGF0YUxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2pzb24nKVxuICAgICAgICBtZXRhZGF0YUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgICAgIG1ldGFkYXRhTG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgbWV0YWRhdGFMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgbWV0YWRhdGFMb2FkZXIubG9hZChtZXRhZGF0YVVybCwgYXN5bmMgKGpzb24pID0+IHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgICAgICAgICAgIHRoaXMgY29uZGl0aW9uIGV4aXN0cyBvbmx5IGJlY2F1c2Ugb2YgdGhyZWUuanMgdHlwZXMgKyBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGFkYXRhIHN0cmluZycpO1xuICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IGNoZWNrIG9uIEpTT04gZmlsZSBhbmQgcmVtb3ZlIHRoaXMgZXNsaW50IGRpc2FibGVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIG1ldGFkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRDaGVjaygpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgbWV0YWRhdGFMZW5ndGhDb21wdXRhYmxlID0gZS5sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgbWV0YWRhdGFMb2FkZWQgPSBlLmxvYWRlZDtcbiAgICAgICAgICAgIG1ldGFkYXRhVG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVyKCk7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcXVhZFJlbmRlcmVyO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIFRocmVlLmpzIExvYWRlciBmb3IgYSBKUEVHIHdpdGggZW1iZWRkZWQgZ2Fpbm1hcCBtZXRhZGF0YS5cbiAqXG4gKiBAY2F0ZWdvcnkgTG9hZGVyc1xuICogQGdyb3VwIExvYWRlcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgSERSSlBHTG9hZGVyIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gKiBpbXBvcnQge1xuICogICBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcbiAqICAgTGluZWFyRmlsdGVyLFxuICogICBNZXNoLFxuICogICBNZXNoQmFzaWNNYXRlcmlhbCxcbiAqICAgUGVyc3BlY3RpdmVDYW1lcmEsXG4gKiAgIFBsYW5lR2VvbWV0cnksXG4gKiAgIFNjZW5lLFxuICogICBXZWJHTFJlbmRlcmVyXG4gKiB9IGZyb20gJ3RocmVlJ1xuICpcbiAqIGNvbnN0IHJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoKVxuICpcbiAqIGNvbnN0IGxvYWRlciA9IG5ldyBIRFJKUEdMb2FkZXIocmVuZGVyZXIpXG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYygnZ2Fpbm1hcC5qcGVnJylcbiAqIC8vIGByZXN1bHRgIGNhbiBiZSB1c2VkIHRvIHBvcHVsYXRlIGEgVGV4dHVyZVxuICpcbiAqIGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lKClcbiAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAqICAgbmV3IFBsYW5lR2VvbWV0cnkoKSxcbiAqICAgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmUgfSlcbiAqIClcbiAqIHNjZW5lLmFkZChtZXNoKVxuICogcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKSlcbiAqXG4gKiAvLyBTdGFydGluZyBmcm9tIHRocmVlLmpzIHIxNTlcbiAqIC8vIGByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVgIGNhblxuICogLy8gYWxzbyBiZSB1c2VkIGFzIEVxdWlyZWN0YW5ndWxhciBzY2VuZSBiYWNrZ3JvdW5kXG4gKiAvL1xuICogLy8gaXQgd2FzIHByZXZpb3VzbHkgbmVlZGVkIHRvIGNvbnZlcnQgaXRcbiAqIC8vIHRvIGEgRGF0YVRleHR1cmUgd2l0aCBgcmVzdWx0LnRvRGF0YVRleHR1cmUoKWBcbiAqIHNjZW5lLmJhY2tncm91bmQgPSByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVcbiAqIHNjZW5lLmJhY2tncm91bmQubWFwcGluZyA9IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nXG4gKlxuICogLy8gcmVzdWx0IG11c3QgYmUgbWFudWFsbHkgZGlzcG9zZWRcbiAqIC8vIHdoZW4geW91IGFyZSBkb25lIHVzaW5nIGl0XG4gKiByZXN1bHQuZGlzcG9zZSgpXG4gKlxuICovXG5jbGFzcyBIRFJKUEdMb2FkZXIgZXh0ZW5kcyBMb2FkZXJCYXNlIHtcbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIEpQRUcgY29udGFpbmluZyBnYWluIG1hcCBtZXRhZGF0YVxuICAgICAqIFJlbmRlcnMgYSBub3JtYWwgU0RSIGltYWdlIGlmIGdhaW5tYXAgZGF0YSBpcyBub3QgZm91bmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgQW4gYXJyYXkgaW4gdGhlIGZvcm0gb2YgW3Nkci5qcGcsIGdhaW5tYXAuanBnLCBtZXRhZGF0YS5qc29uXVxuICAgICAqIEBwYXJhbSBvbkxvYWQgTG9hZCBjb21wbGV0ZSBjYWxsYmFjaywgd2lsbCByZWNlaXZlIHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gb25Qcm9ncmVzcyBQcm9ncmVzcyBjYWxsYmFjaywgd2lsbCByZWNlaXZlIGEge0BsaW5rIFByb2dyZXNzRXZlbnR9XG4gICAgICogQHBhcmFtIG9uRXJyb3IgRXJyb3IgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcXVhZFJlbmRlcmVyID0gdGhpcy5wcmVwYXJlUXVhZFJlbmRlcmVyKCk7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMuX2ludGVybmFsTG9hZGluZ01hbmFnZXIpO1xuICAgICAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgICAgICBsb2FkZXIubG9hZCh1cmwsIGFzeW5jIChqcGVnKSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgICB0aGlzIGNvbmRpdGlvbiBleGlzdHMgb25seSBiZWNhdXNlIG9mIHRocmVlLmpzIHR5cGVzICsgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGpwZWcgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBidWZmZXIsIHJlY2VpdmVkIFtzdHJpbmddLCB3YXMgZXhwZWN0aW5nIFtBcnJheUJ1ZmZlcl0nKTtcbiAgICAgICAgICAgIGNvbnN0IGpwZWdCdWZmZXIgPSBuZXcgVWludDhBcnJheShqcGVnKTtcbiAgICAgICAgICAgIGxldCBzZHJKUEVHO1xuICAgICAgICAgICAgbGV0IGdhaW5NYXBKUEVHO1xuICAgICAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRyYWN0aW9uUmVzdWx0ID0gYXdhaXQgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyhqcGVnQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAvLyBnYWluIG1hcCBpcyBzdWNjZXNzZnVsbHkgcmVjb25zdHJ1Y3RlZFxuICAgICAgICAgICAgICAgIHNkckpQRUcgPSBleHRyYWN0aW9uUmVzdWx0LnNkcjtcbiAgICAgICAgICAgICAgICBnYWluTWFwSlBFRyA9IGV4dHJhY3Rpb25SZXN1bHQuZ2Fpbk1hcDtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IGV4dHJhY3Rpb25SZXN1bHQubWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlciB0aGUgU0RSIHZlcnNpb24gaWYgdGhpcyBpcyBub3QgYSBnYWlubWFwXG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IgfHwgZSBpbnN0YW5jZW9mIEdhaW5NYXBOb3RGb3VuZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbHVyZSB0byByZWNvbnN0cnVjdCBhbiBIRFIgaW1hZ2UgZnJvbSAke3VybH06IEdhaW4gbWFwIG1ldGFkYXRhIG5vdCBmb3VuZCBpbiB0aGUgZmlsZSwgSERSSlBHTG9hZGVyIHdpbGwgcmVuZGVyIHRoZSBTRFIganBlZ2ApO1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhaW5NYXBNaW46IFswLCAwLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhaW5NYXBNYXg6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhbW1hOiBbMSwgMSwgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWF4OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0SGRyOiBbMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRTZHI6IFswLCAwLCAwXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZHJKUEVHID0ganBlZ0J1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc29sdmVzICMxNlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlcihxdWFkUmVuZGVyZXIsIG1ldGFkYXRhLCBzZHJKUEVHLCBnYWluTWFwSlBFRyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uTG9hZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvbkxvYWQocXVhZFJlbmRlcmVyKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgfSwgb25Qcm9ncmVzcywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcXVhZFJlbmRlcmVyO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgR2Fpbk1hcERlY29kZXJNYXRlcmlhbCwgR2Fpbk1hcExvYWRlciwgSERSSlBHTG9hZGVyLCBIRFJKUEdMb2FkZXIgYXMgSlBFR1JMb2FkZXIsIE1QRkV4dHJhY3RvciwgUXVhZFJlbmRlcmVyLCBkZWNvZGUsIGV4dHJhY3RHYWlubWFwRnJvbUpQRUcsIGV4dHJhY3RYTVAgfTtcbiJdLCJuYW1lcyI6WyJRIiwiUXVhZFJlbmRlcmVyIiwiU2hhZGVyTWF0ZXJpYWwiLCJWZWN0b3IzIiwiTm9CbGVuZGluZyIsIlNSR0JDb2xvclNwYWNlIiwiTGluZWFyU1JHQkNvbG9yU3BhY2UiLCJIYWxmRmxvYXRUeXBlIiwiTG9hZGVyIiwiTG9hZGluZ01hbmFnZXIiLCJUZXh0dXJlIiwiVVZNYXBwaW5nIiwiQ2xhbXBUb0VkZ2VXcmFwcGluZyIsIkxpbmVhckZpbHRlciIsIkxpbmVhck1pcE1hcExpbmVhckZpbHRlciIsIlJHQkFGb3JtYXQiLCJVbnNpZ25lZEJ5dGVUeXBlIiwiRmlsZUxvYWRlciIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwiR2Fpbk1hcERlY29kZXJNYXRlcmlhbCIsImNvbnN0cnVjdG9yIiwiZ2FtbWEiLCJvZmZzZXRIZHIiLCJvZmZzZXRTZHIiLCJnYWluTWFwTWluIiwiZ2Fpbk1hcE1heCIsIm1heERpc3BsYXlCb29zdCIsImhkckNhcGFjaXR5TWluIiwiaGRyQ2FwYWNpdHlNYXgiLCJzZHIiLCJnYWluTWFwIiwibmFtZSIsInVuaWZvcm1zIiwidmFsdWUiLCJmcm9tQXJyYXkiLCJ3ZWlnaHRGYWN0b3IiLCJNYXRoIiwibG9nMiIsImJsZW5kaW5nIiwiZGVwdGhUZXN0IiwiZGVwdGhXcml0ZSIsIl9tYXhEaXNwbGF5Qm9vc3QiLCJfaGRyQ2FwYWNpdHlNaW4iLCJfaGRyQ2FwYWNpdHlNYXgiLCJuZWVkc1VwZGF0ZSIsInVuaWZvcm1zTmVlZFVwZGF0ZSIsInRvQXJyYXkiLCJnIiwieCIsInkiLCJ6IiwiY2FsY3VsYXRlV2VpZ2h0IiwibWF4IiwibWluIiwidmFsIiwiZGVjb2RlIiwicGFyYW1zIiwicmVuZGVyZXIiLCJjb2xvclNwYWNlIiwiY29uc29sZSIsIndhcm4iLCJtYXRlcmlhbCIsInF1YWRSZW5kZXJlciIsIndpZHRoIiwiaW1hZ2UiLCJoZWlnaHQiLCJ0eXBlIiwicmVuZGVyVGFyZ2V0T3B0aW9ucyIsInJlbmRlciIsImUiLCJkaXNwb3NlT25EZW1hbmRSZW5kZXJlciIsIkdhaW5NYXBOb3RGb3VuZEVycm9yIiwiRXJyb3IiLCJYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IiLCJnZXRBdHRyaWJ1dGUiLCJkZXNjcmlwdGlvbiIsImRlZmF1bHRWYWx1ZSIsIl9hIiwicmV0dXJuVmFsdWUiLCJwYXJzZWRWYWx1ZSIsImF0dHJpYnV0ZXMiLCJnZXROYW1lZEl0ZW0iLCJub2RlVmFsdWUiLCJub2RlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJ2YWx1ZXMiLCJsZW5ndGgiLCJBcnJheSIsImZyb20iLCJtYXAiLCJ2IiwiaW5uZXJIVE1MIiwiZXh0cmFjdFhNUCIsImlucHV0IiwiX2IiLCJzdHIiLCJUZXh0RGVjb2RlciIsInRvU3RyaW5nIiwic3RhcnQiLCJpbmRleE9mIiwicGFyc2VyIiwiRE9NUGFyc2VyIiwiZW5kIiwic2xpY2UiLCJ4bXBCbG9jayIsInhtbERvY3VtZW50IiwicGFyc2VGcm9tU3RyaW5nIiwib2Zmc2V0U0RSIiwib2Zmc2V0SERSIiwiaXNBcnJheSIsInBhcnNlRmxvYXQiLCJNUEZFeHRyYWN0b3IiLCJvcHRpb25zIiwiZGVidWciLCJ1bmRlZmluZWQiLCJleHRyYWN0RklJIiwiZXh0cmFjdE5vbkZJSSIsImV4dHJhY3QiLCJpbWFnZUFycmF5QnVmZmVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJkYXRhVmlldyIsIkRhdGFWaWV3IiwiYnVmZmVyIiwiZ2V0VWludDE2IiwiYnl0ZUxlbmd0aCIsIm9mZnNldCIsImxvb3BzIiwibWFya2VyIiwiZ2V0VWludDgiLCJsb2ciLCJmb3JtYXRQdCIsImdldFVpbnQzMiIsInRpZmZPZmZzZXQiLCJiaWdFbmQiLCJmaXJzdElGRE9mZnNldCIsImRpclN0YXJ0IiwiY291bnQiLCJlbnRyaWVzU3RhcnQiLCJudW1iZXJPZkltYWdlcyIsImkiLCJuZXh0SUZET2Zmc2V0TGVuIiwiTVBJbWFnZUxpc3RWYWxQdCIsImltYWdlcyIsIk1QVHlwZSIsInNpemUiLCJkYXRhT2Zmc2V0IiwiZGVwZW5kYW50SW1hZ2VzIiwiaXNGSUkiLCJwdXNoIiwiYnVmZmVyQmxvYiIsIkJsb2IiLCJpbWdzIiwiaW1hZ2VCbG9iIiwiZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyIsImpwZWdGaWxlIiwibWV0YWRhdGEiLCJtcGZFeHRyYWN0b3IiLCJVaW50OEFycmF5IiwiYXJyYXlCdWZmZXIiLCJnZXRIVE1MSW1hZ2VGcm9tQmxvYiIsImJsb2IiLCJpbWciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJvbmxvYWQiLCJvbmVycm9yIiwic3JjIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiTG9hZGVyQmFzZSIsIm1hbmFnZXIiLCJfcmVuZGVyZXIiLCJfaW50ZXJuYWxMb2FkaW5nTWFuYWdlciIsInNldFJlbmRlcmVyIiwic2V0UmVuZGVyVGFyZ2V0T3B0aW9ucyIsIl9yZW5kZXJUYXJnZXRPcHRpb25zIiwicHJlcGFyZVF1YWRSZW5kZXJlciIsInNkckJ1ZmZlciIsImdhaW5NYXBCdWZmZXIiLCJnYWluTWFwQmxvYiIsInNkckJsb2IiLCJzZHJJbWFnZSIsImdhaW5NYXBJbWFnZSIsIm5lZWRzRmxpcCIsImNyZWF0ZUltYWdlQml0bWFwIiwicmVzIiwiYWxsIiwiaW1hZ2VPcmllbnRhdGlvbiIsIkltYWdlRGF0YSIsImZsaXBZIiwicG93IiwiR2Fpbk1hcExvYWRlciIsImxvYWQiLCJzZHJVcmwiLCJnYWluTWFwVXJsIiwibWV0YWRhdGFVcmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsImxvYWRDaGVjayIsImVycm9yIiwiaXRlbUVycm9yIiwiaXRlbUVuZCIsInNkckxlbmd0aENvbXB1dGFibGUiLCJzZHJUb3RhbCIsInNkckxvYWRlZCIsImdhaW5NYXBMZW5ndGhDb21wdXRhYmxlIiwiZ2Fpbk1hcFRvdGFsIiwiZ2Fpbk1hcExvYWRlZCIsIm1ldGFkYXRhTGVuZ3RoQ29tcHV0YWJsZSIsIm1ldGFkYXRhVG90YWwiLCJtZXRhZGF0YUxvYWRlZCIsInByb2dyZXNzSGFuZGxlciIsInRvdGFsIiwibG9hZGVkIiwibGVuZ3RoQ29tcHV0YWJsZSIsIlByb2dyZXNzRXZlbnQiLCJpdGVtU3RhcnQiLCJzZHJMb2FkZXIiLCJzZXRSZXNwb25zZVR5cGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwicmVxdWVzdEhlYWRlciIsInNldFBhdGgiLCJwYXRoIiwic2V0V2l0aENyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiZ2Fpbk1hcExvYWRlciIsIm1ldGFkYXRhTG9hZGVyIiwianNvbiIsIkpTT04iLCJwYXJzZSIsIkhEUkpQR0xvYWRlciIsInVybCIsImxvYWRlciIsImpwZWciLCJqcGVnQnVmZmVyIiwic2RySlBFRyIsImdhaW5NYXBKUEVHIiwiZXh0cmFjdGlvblJlc3VsdCIsIkpQRUdSTG9hZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js\n");

/***/ })

};
;