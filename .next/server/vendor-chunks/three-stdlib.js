"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/LoaderUtils.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeText: () => (/* binding */ decodeText)\n/* harmony export */ });\nfunction decodeText(array) {\n    if (typeof TextDecoder !== \"undefined\") {\n        return new TextDecoder().decode(array);\n    }\n    let s = \"\";\n    for(let i = 0, il = array.length; i < il; i++){\n        s += String.fromCharCode(array[i]);\n    }\n    try {\n        return decodeURIComponent(escape(s));\n    } catch (e) {\n        return s;\n    }\n}\n //# sourceMappingURL=LoaderUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9Mb2FkZXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsV0FBV0MsS0FBSztJQUN2QixJQUFJLE9BQU9DLGdCQUFnQixhQUFhO1FBQ3RDLE9BQU8sSUFBSUEsY0FBY0MsTUFBTSxDQUFDRjtJQUNsQztJQUNBLElBQUlHLElBQUk7SUFDUixJQUFLLElBQUlDLElBQUksR0FBR0MsS0FBS0wsTUFBTU0sTUFBTSxFQUFFRixJQUFJQyxJQUFJRCxJQUFLO1FBQzlDRCxLQUFLSSxPQUFPQyxZQUFZLENBQUNSLEtBQUssQ0FBQ0ksRUFBRTtJQUNuQztJQUNBLElBQUk7UUFDRixPQUFPSyxtQkFBbUJDLE9BQU9QO0lBQ25DLEVBQUUsT0FBT1EsR0FBRztRQUNWLE9BQU9SO0lBQ1Q7QUFDRjtBQUdFLENBQ0YsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNyZWF0aXZlLXBvcnRmb2xpby1zdGFydGVyLWNvZGUtZmlsZXMvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9Mb2FkZXJVdGlscy5qcz9lNWNhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGRlY29kZVRleHQoYXJyYXkpIHtcbiAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXJyYXkpO1xuICB9XG4gIGxldCBzID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZXhwb3J0IHtcbiAgZGVjb2RlVGV4dFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvYWRlclV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbImRlY29kZVRleHQiLCJhcnJheSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwicyIsImkiLCJpbCIsImxlbmd0aCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVzY2FwZSIsImUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst version = parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFDakMsTUFBTUMsVUFBVUMsU0FBU0YsMkNBQVFBLENBQUNHLE9BQU8sQ0FBQyxRQUFRO0FBR2hELENBQ0YscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNyZWF0aXZlLXBvcnRmb2xpby1zdGFydGVyLWNvZGUtZmlsZXMvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanM/ZjE3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRVZJU0lPTiB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KFJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZywgXCJcIikpO1xuZXhwb3J0IHtcbiAgdmVyc2lvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSRVZJU0lPTiIsInZlcnNpb24iLCJwYXJzZUludCIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/libs/MeshoptDecoder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshoptDecoder: () => (/* binding */ MeshoptDecoder)\n/* harmony export */ });\nlet generated;\nconst MeshoptDecoder = ()=>{\n    if (generated) return generated;\n    const wasm_base = \"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\";\n    const wasm_simd = \"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\";\n    const detector = new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        4,\n        1,\n        96,\n        0,\n        0,\n        3,\n        3,\n        2,\n        0,\n        0,\n        5,\n        3,\n        1,\n        0,\n        1,\n        12,\n        1,\n        0,\n        10,\n        22,\n        2,\n        12,\n        0,\n        65,\n        0,\n        65,\n        0,\n        65,\n        0,\n        252,\n        10,\n        0,\n        0,\n        11,\n        7,\n        0,\n        65,\n        0,\n        253,\n        15,\n        26,\n        11\n    ]);\n    const wasmpack = new Uint8Array([\n        32,\n        0,\n        65,\n        253,\n        3,\n        1,\n        2,\n        34,\n        4,\n        106,\n        6,\n        5,\n        11,\n        8,\n        7,\n        20,\n        13,\n        33,\n        12,\n        16,\n        128,\n        9,\n        116,\n        64,\n        19,\n        113,\n        127,\n        15,\n        10,\n        21,\n        22,\n        14,\n        255,\n        66,\n        24,\n        54,\n        136,\n        107,\n        18,\n        23,\n        192,\n        26,\n        114,\n        118,\n        132,\n        17,\n        77,\n        101,\n        130,\n        144,\n        27,\n        87,\n        131,\n        44,\n        45,\n        74,\n        156,\n        154,\n        70,\n        167\n    ]);\n    if (typeof WebAssembly !== \"object\") {\n        return {\n            supported: false\n        };\n    }\n    let wasm = wasm_base;\n    if (WebAssembly.validate(detector)) {\n        wasm = wasm_simd;\n    }\n    let instance;\n    const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result)=>{\n        instance = result.instance;\n        instance.exports.__wasm_call_ctors();\n    });\n    function unpack(data) {\n        const result = new Uint8Array(data.length);\n        for(let i = 0; i < data.length; ++i){\n            const ch = data.charCodeAt(i);\n            result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n        }\n        let write = 0;\n        for(let i = 0; i < data.length; ++i){\n            result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n        }\n        return result.buffer.slice(0, write);\n    }\n    function decode(fun, target, count, size, source, filter) {\n        const sbrk = instance.exports.sbrk;\n        const count4 = count + 3 & ~3;\n        const tp = sbrk(count4 * size);\n        const sp = sbrk(source.length);\n        const heap = new Uint8Array(instance.exports.memory.buffer);\n        heap.set(source, sp);\n        const res = fun(tp, count, size, sp, source.length);\n        if (res === 0 && filter) {\n            filter(tp, count4, size);\n        }\n        target.set(heap.subarray(tp, tp + count * size));\n        sbrk(tp - sbrk(0));\n        if (res !== 0) {\n            throw new Error(`Malformed buffer data: ${res}`);\n        }\n    }\n    const filters = {\n        // legacy index-based enums for glTF\n        0: \"\",\n        1: \"meshopt_decodeFilterOct\",\n        2: \"meshopt_decodeFilterQuat\",\n        3: \"meshopt_decodeFilterExp\",\n        // string-based enums for glTF\n        NONE: \"\",\n        OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n        QUATERNION: \"meshopt_decodeFilterQuat\",\n        EXPONENTIAL: \"meshopt_decodeFilterExp\"\n    };\n    const decoders = {\n        // legacy index-based enums for glTF\n        0: \"meshopt_decodeVertexBuffer\",\n        1: \"meshopt_decodeIndexBuffer\",\n        2: \"meshopt_decodeIndexSequence\",\n        // string-based enums for glTF\n        ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n        TRIANGLES: \"meshopt_decodeIndexBuffer\",\n        INDICES: \"meshopt_decodeIndexSequence\"\n    };\n    generated = {\n        ready: promise,\n        supported: true,\n        decodeVertexBuffer (target, count, size, source, filter) {\n            decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);\n        },\n        decodeIndexBuffer (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n        },\n        decodeIndexSequence (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n        },\n        decodeGltfBuffer (target, count, size, source, mode, filter) {\n            decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);\n        }\n    };\n    return generated;\n};\n //# sourceMappingURL=MeshoptDecoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQUlBO0FBQ0osTUFBTUMsaUJBQWlCO0lBQ3JCLElBQUlELFdBQ0YsT0FBT0E7SUFDVCxNQUFNRSxZQUFZO0lBQ2xCLE1BQU1DLFlBQVk7SUFDbEIsTUFBTUMsV0FBVyxJQUFJQyxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsTUFBTUMsV0FBVyxJQUFJRCxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsSUFBSSxPQUFPRSxnQkFBZ0IsVUFBVTtRQUNuQyxPQUFPO1lBQ0xDLFdBQVc7UUFDYjtJQUNGO0lBQ0EsSUFBSUMsT0FBT1A7SUFDWCxJQUFJSyxZQUFZRyxRQUFR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QUFrQjNCLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLE1BQU07WUFDM0NMLE9BQU9oQixTQUFTTSxPQUFPLENBQUN3Qyx5QkFBeUIsRUFBRTVCLFFBQVFDLE9BQU9DLE1BQU1DO1FBQzFFO1FBQ0EwQixxQkFBb0I3QixNQUFNLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxNQUFNO1lBQzdDTCxPQUFPaEIsU0FBU00sT0FBTyxDQUFDMEMsMkJBQTJCLEVBQUU5QixRQUFRQyxPQUFPQyxNQUFNQztRQUM1RTtRQUNBNEIsa0JBQWlCL0IsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFNkIsSUFBSSxFQUFFNUIsTUFBTTtZQUN4RE4sT0FDRWhCLFNBQVNNLE9BQU8sQ0FBQ2dDLFFBQVEsQ0FBQ1ksS0FBSyxDQUFDLEVBQ2hDaEMsUUFDQUMsT0FDQUMsTUFDQUMsUUFDQXJCLFNBQVNNLE9BQU8sQ0FBQzJCLE9BQU8sQ0FBQ1gsT0FBTyxDQUFDO1FBRXJDO0lBQ0Y7SUFDQSxPQUFPakM7QUFDVDtBQUdFLENBQ0YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNyZWF0aXZlLXBvcnRmb2xpby1zdGFydGVyLWNvZGUtZmlsZXMvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanM/YTdmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZ2VuZXJhdGVkO1xuY29uc3QgTWVzaG9wdERlY29kZXIgPSAoKSA9PiB7XG4gIGlmIChnZW5lcmF0ZWQpXG4gICAgcmV0dXJuIGdlbmVyYXRlZDtcbiAgY29uc3Qgd2FzbV9iYXNlID0gXCJCOWg5ejl0RkJCQkY4Zkw5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmE5Z0VhYWFGYUVNY0JGRkZHR0dFSUlJTEY5d0ZGRkxFRkJGS05GYUZDeC9JRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJGOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCR3k5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCRW45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQklpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCS0k5ejlpcWxCT2MreDh5Y0dCTS9xUUZUYThqVVVVVUJDVS9FQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHVGtVVVVCUk5DVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSVkFFQ0ZKUklDQlJjR1hFWEFjQUY5UFFGQVZBRkFjbEFjQVZKQUY5SnlSTUdYR1hBRzlGUUJBTUNiSkhLQzl3WlJTQUtDSXJDRUpDR3JSUUFOQ1VHSlJmQ0JSYkFJUlRFWEdYQU9BVGxBUTlQUUJDQlJJU0VNQVRBUUpSSUdYQVM5RlFCQ0JSdENCUkVFWEdYQU9BSWxDaTlQUUJDQlJJU0xNQU5DVS9DQkpBRUpSS0dYR1hHWEdYR1hBVEFFQ0tySjJCQkF0Q0tackNFWmZJQkZHRUJNQUtoQjgzRUJBS0NOSmhCODNFQlNFTUFLQUkyQklBSTJCQkhtQ0tySFlBWUNFNkhZeTg2QkJBS0NGSkFJQ0lKQVlKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDR0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ0VKQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NJSkFZQW1KSFkyQkJBSTJCRkhtQ0tySFBBUENFNkhQeTg2QkJBS0NMSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDS0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ09KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NOSkFZQW1KSFkyQkJBSTJCR0htQ0tySFBBUENFNkhQeTg2QkJBS0NWSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDY0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ01KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NTSkFZQW1KSG0yQkJBSTJCRUhJQ0tySFlBWUNFNkhZeTg2QkJBS0NRSkFtQVlKSG0yQkJBSUNJckNFWkhZQVlDRTZIWXk4NkJCQUtDZkpBbUFZSkhtMkJCQUlDR3JDRVpIWUFZQ0U2SFl5ODZCQkFLQ2JKQW1BWUpISzJCQkFJQ0VaSElBSUNFNkhJeTg2QkJBS0FJSlJJU0dNQUtBSTJCTkFJMkJCSG1DSXJIWUFZQ2I2SFl5ODZCQkFLQ0ZKQUlDTkpBWUpIWTJCQkFtQ2JaSG1BbUNiNkhteTg2QkJBS0NHSkFZQW1KSG0yQkJBSTJCRkhZQ0lySFBBUENiNkhQeTg2QkJBS0NFSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDSUpBbUFZSkhtMkJCQUkyQkdIWUNJckhQQVBDYjZIUHk4NkJCQUtDTEpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ0tKQW1BWUpIbTJCQkFJMkJFSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ09KQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NOSkFtQVlKSG0yQkJBSTJCSUhZQ0lySFBBUENiNkhQeTg2QkJBS0NWSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDY0pBbUFZSkhtMkJCQUkyQkxIWUNJckhQQVBDYjZIUHk4NkJCQUtDTUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ1NKQW1BWUpIbTJCQkFJMkJLSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ1FKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NmSkFtQVlKSG0yQkJBSTJCT0hJQ0lySFlBWUNiNkhZeTg2QkJBS0NiSkFtQVlKSEsyQkJBSUNiWkhJQUlDYjZISXk4NkJCQUtBSUpSSVNGTUFLQUk4cEJCODNCQkFLQ05KQUlDTko4cEJCODNCQkFJQ1RKUklNQXRDR0pSdEFFQ1RKSEVBUzlKUUJNTUdYQUlRQkNCUklTRU1HWEFNOUZRQkFOQWJKMkJCUnRDQlJLQWZSRUVYQUVBTkNVL0NCSkFLSjJCQkhUQ0ZyQ0JBVENGWmw5ekF0Skh0ODZCQkFFQUdKUkVBS0NGSkhLQU05SFFCTU1BZkNGSlJmQUlSVEFiQ0ZKSGJBRzlIUUJNTUFCQWNBRzlzSkFOQ1VHSkFNQUc5c1RrVVVVQnBBTkFOQ1VHSkFNQ2FKQUc5c0pBR1RrVVVVQnBNQU1DQkFJeUFjSlJjQUlRQk1DOStSS1NGTUNCQzk5QU9BSWxBR0NBQUdDQTlMeTZ5UktNQUxDVS9FQko4a1VVVVVCQUtNK09tRlRhOGpVVVVVQkNvRmxITDhrVVVVVUJDOStSS0dYQUZDRTl1SE9DdEpBSTlMUUJDYVJLQUUyQkJITkMvd0ZaQy9nRjlIUUJBTkNiWkhWQ0Y5TFFCQUxDb0JKQ2dGQ1VGVCtKVVVVQnBBTEM4NEpoYTgzRUJBTEM4d0poYTgzRUJBTEM4b0poYTgzRUJBTENBSmhhODNFQkFMQ2lKaGE4M0VCQUxDVEpoYTgzRUJBTGhhODNFTkFMaGE4M0VCQUVBSUpDOXdKUmNBRUNGSkhOQU9KUk1HWEFGOUZRQkNRQ2JBVkNGNnlSU0FCUkVDQlJWQ0JSUUNCUmZDQlJJQ0JSS0VYR1hBTUFjdVFCQzkrUktTRU1HWEdYQU4yQkJIT0MvdkY5TFFCQUxDb0JKQU9DSXJDYTl6QUtKQ2JaQ0VXSkhiOG9HSVJUQWI4b0dCUnRHWEFPQ2JaSGJBUzlQUUJBTEFPQ2E5ekFJSkNiWkNHV0o4b0dCQVZBYnlST0FiOUZSYkdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBTzg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFPakdCQUVDSUpBVGpHQk1BVkFiSlJWQUxDb0JKQUtDRVdKSG1BT2pHQkFtQVRqR0lBTEFJQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIVEF0akdCQVRBT2pHSUFJQWJKUklBS0NGSlJLU0dNR1hHWEFiQ2I2UUJBUUFiSkFiQzk4OXpKQ0ZKUlFTRk1BTTFCQkhiQ2dGWlJPR1hHWEFiQ2E5TVFCQU1DRkpSTVNGTUFNMUJGSGJDZ0JaQ09XQU9DZ0JacVJPR1hBYkNhOU1RQkFNQ0dKUk1TRk1BTTFCR0hiQ2dCWkNmV0FPcVJPR1hBYkNhOU1RQkFNQ0VKUk1TRk1BTTFCRUhiQ2dCWkNkV0FPcVJPR1hBYkNhOU1RQkFNQ0lKUk1TRk1BTTJCSUM4Y1dBT3FST0FNQ0xKUk1NQU9DRnJDQkFPQ0ZabDl6QVFKUlFNR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFRODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQVFqR0JBRUNJSkFUakdCTUFMQ29CSkFLQ0VXSkhPQVFqR0JBT0FUakdJQUxBSUNHV0pBUWpHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSE9BdGpHQkFPQVFqR0lBSUNGSlJJQUtDRkpSS1NGTUdYQU9DREY5TFFCQUxBSUFjQU9DYlpKMkJCSGJDSXJIVGxDYlpDR1dKOG9HQkFWQ0ZKSHRBVHlST0FMQUlBYmxDYlpDR1dKOG9HQkF0QVQ5RkhtSkh0QWJDYlpIVHlSYkFUOUZSVEdYR1hBR0NHOUhRQkFCQVY4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVZqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTEFJQ0dXSkFWakdCQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVZqR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlBbUpDYlpISUNHV0pBYmpHQkFMQ29CSkFLQ0dKQ2JaSEtDRVdKSE9BVmpHQkFPQWJqR0lBS0NGSlJLQUlBVEpSSUF0QVRKUlZTRk1BVkNCQU0yQkJIWXlIVEFPQy8rRjZIUEpST0FZQ2JaUnRHWEdYQVlDSXJIbVFCQU9DRkpSYlNGTUFPUmJBTEFJQW1sQ2JaQ0dXSjhvR0JST01HWEdYQXRRQkFiQ0ZKUlZTRk1BYlJWQUxBSUFZbENiWkNHV0o4b0dCUmJNR1hHWEFQOUZRQkFNQ0ZKUllTRk1BTTFCRkhZQ2dGWlJUR1hHWEFZQ2E5TVFCQU1DR0pSWVNGTUFNMUJHSFlDZ0JaQ09XQVRDZ0JacVJUR1hBWUNhOU1RQkFNQ0VKUllTRk1BTTFCRUhZQ2dCWkNmV0FUcVJUR1hBWUNhOU1RQkFNQ0lKUllTRk1BTTFCSUhZQ2dCWkNkV0FUcVJUR1hBWUNhOU1RQkFNQ0xKUllTRk1BTUNLSlJZQU0yQkxDOGNXQVRxUlRNQVRDRnJDQkFUQ0ZabDl6QVFKSFFSVE1HWEdYQW1DYjZRQkFZUlBTRk1BWTFCQkhNQ2dGWlJPR1hHWEFNQ2E5TVFCQVlDRkpSUFNGTUFZMUJGSE1DZ0JaQ09XQU9DZ0JacVJPR1hBTUNhOU1RQkFZQ0dKUlBTRk1BWTFCR0hNQ2dCWkNmV0FPcVJPR1hBTUNhOU1RQkFZQ0VKUlBTRk1BWTFCRUhNQ2dCWkNkV0FPcVJPR1hBTUNhOU1RQkFZQ0lKUlBTRk1BWUNMSlJQQVkyQklDOGNXQU9xUk9NQU9DRnJDQkFPQ0ZabDl6QVFKSFFST01HWEdYQXRDYjZRQkFQUk1TRk1BUDFCQkhNQ2dGWlJiR1hHWEFNQ2E5TVFCQVBDRkpSTVNGTUFQMUJGSE1DZ0JaQ09XQWJDZ0JacVJiR1hBTUNhOU1RQkFQQ0dKUk1TRk1BUDFCR0hNQ2dCWkNmV0FicVJiR1hBTUNhOU1RQkFQQ0VKUk1TRk1BUDFCRUhNQ2dCWkNkV0FicVJiR1hBTUNhOU1RQkFQQ0lKUk1TRk1BUENMSlJNQVAyQklDOGNXQWJxUmJNQWJDRnJDQkFiQ0ZabDl6QVFKSFFSYk1HWEdYQUdDRzlIUUJBQkFUODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFUakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVRqR0lBTEFJQ0dXSkFUakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NHSkNiWkNFV0pIT0FUakdCQU9BYmpHSUFMQUlBbTlGQW1DYjZxSkhJQ2JaQ0dXSkFiakdCQUlBdDlGQXRDYjZxSlJJQUtDRUpSS01BTkNGSlJOQUJDS0pSQkFFQ1NKUkVBS0NiWlJLQUlDYlpSSUFmQ0VKSGZBRjlKUUJNTUNCQzk5QU1BYzZ5UktNQUxDb0ZKOGtVVVVVQkFLTS90SUZHYThqVVVVVUJDVGxSTEM5K1JLR1hBRkNMSkFJOUxRQkNhUktBRTJCQkMvK0ZaQy9RRjlIUUJBTGhCODNFTkFFQ0ZKUktBRUFJSkM5OEpSRUdYQUY5RlFCR1hBR0NHNlFCRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUxDTkpBSUNGWkNHV3FIR0FJQ0dyQ0JBSUNGckNGWmw5ekFHOG9HQkpISWpHQkFCQUlqR0JBQkNJSlJCQUZDYUpIRlFCU0dNTUVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFCQUlDR3JDQkFJQ0ZyQ0ZabDl6QUxDTkpBSUNGWkNHV3FISThvR0JKSEc4N0ZCQUlBR2pHQkFCQ0dKUkJBRkNhSkhGUUJNTUNCQzk5QUtBRTZ5UktNQUtNK2xMS0ZhRjk5R2FHOTlGYUc5OUdYR1hBR0NJOUhRQkFGOUZRRkVYR1hHWDlEQkJCOC85REJCQisvQUJDR0pIRzFCQit5QUIxQkJIRSt5SEkrTCtUQUJDRkpITDFCQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REJCLytoQU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg2QkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg2QkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg2QkJBQkNJSlJCQUZDYUpIRlFCU0dNTUFGOUZRQkVYR1hHWDlEQkJCOC85REJCQisvQUJDSUpIRzh1RkIreUFCOHVGQkhFK3lISStMK1RBQkNHSkhMOHVGQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REIvK2c2QU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg3RkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg3RkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg3RkJBQkNOSlJCQUZDYUpIRlFCTU1NL1NFSUVhRTk5RWFGOTlHWEFGOUZRQkNCUkVBQlJJRVhHWEdYOUQvekk4MTgvQUlDS0o4dUZCSExDRXEreStWSEtBSTh1RkIreStVSE85REIvK2c2K1U5REJCQjgvOURCQkIrL0FPOURCQkJCOWd5K1NITitMOURCQkI5UDlkOUZRQkFOK29SVlNGTUNVVVVVOTRSVk1BSUNJSjh1RkJSY0FJQ0dKOHVGQlJNQUJBTENGSkNFWkFFcUNGV0pBVjg3RkJHWEdYQUtBTSt5K1VITjlEQi8rZzYrVTlEQkJCOC85REJCQisvQU45REJCQkI5Z3krU0hTK0w5REJCQjlQOWQ5RlFCQVMrb1JNU0ZNQ1VVVVU5NFJNTUFCQUxDR0pDRVpBRXFDRldKQU04N0ZCR1hHWEFLQWMreStVSEs5REIvK2c2K1U5REJCQjgvOURCQkIrL0FLOURCQkJCOWd5K1NIUytMOURCQkI5UDlkOUZRQkFTK29SY1NGTUNVVVVVOTRSY01BQkFMQ2FKQ0VaQUVxQ0ZXSkFjODdGQkdYR1g5REJCVTgvQU9BTytVK1RBTkFOK1UrVEFLQUsrVStUSE85REJCQkJBTzlEQkJCQjlneStSOURCLytnNitVOURCQkI4LytTSE8rTDlEQkJCOVA5ZDlGUUJBTytvUmNTRk1DVVVVVTk0UmNNQUJBTENFWkFFcUNGV0pBYzg3RkJBSUNOSlJJQUVDSUpSRUFGQ2FKSEZRQk1NTTlKQkdYQUdDR3JBRjlzSEY5RlFCRVhBQkFCOG9HQkhHQ05XQ045MSt5QUdDaTkxQ25XQ1VVVS84RUorKytVODRHQkFCQ0lKUkJBRkNhSkhGUUJNTU05VEZFYUNCQ0I4b0dVa1VVQkhGQUJDRUpDOThaSkhCakdVa1VVQkdYR1hBQjgvQkNUV0hHdVFCQ2FSRUFCQUdsQ2dnRUpDVHJYQkNhNlFGTUFGUkVNQUVNL2xGRkZhR1hHWEFGQUJxQ0VaOUZRQkFCUkVTRk1HWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBRjhvR0JqR0JBRUNJSkFGQ0lKOG9HQmpHQkFFQ05KQUZDTko4b0dCakdCQUVDU0pBRkNTSjhvR0JqR0JBRUNUSlJFQUZDVEpSRkFHQzl3SkhHQ2I5TFFCTU1BR0NJOUpRQkVYQUVBRjhvR0JqR0JBRkNJSlJGQUVDSUpSRUFHQzk4SkhHQ0U5TFFCTU1HWEFHOUZRQkVYQUVBRjJCQjg2QkJBRUNGSlJFQUZDRkpSRkFHQ2FKSEdRQk1NQUJNb0ZGR2FHWEdYQUJDRVo5RlFCQUJSRVNGTUFGQ2dGWkMrQndzTjlzUklHWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBSWpHQkFFQ1NKQUlqR0JBRUNOSkFJakdCQUVDSUpBSWpHQkFFQ1RKUkVBR0M5d0pIR0NiOUxRQk1NQUdDSTlKUUJFWEFFQUlqR0JBRUNJSlJFQUdDOThKSEdDRTlMUUJNTUdYQUc5RlFCRVhBRUFGODZCQkFFQ0ZKUkVBR0NhSkhHUUJNTUFCTU1NRkJDVU5NSVQ5a0JCXCI7XG4gIGNvbnN0IHdhc21fc2ltZCA9IFwiQjloOXo5dEZCQkJGaUk5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmFFTWNCQkZCRkZHR0dFSUxGOXdGRkZMRUZCRktORmFGQ3gvYUZNTy9MRlZLOXR2OXQ5dnE5NUdCdDlmOWY5MzloOXo5dDlmOWo5aDlzOXM5ZjlqVzl2cTl6QkJwOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OVd2cVd2OTRoOTE5bTltdnFCRzhaOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0aDkxOW05bXZxQkl5OXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0OVR2Wjkxdjl1OWp2QkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UDlqV0JLaTl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVI5MTloV0JPbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOUY5NDl3Qk5JOXo5aXFsQlZjK045SWNJQlRFTTkrRkxhOGpVVVVVQkNUbFJCQ0JSRkVYQ0JSR0NCUkVFWEFCQ05KQUdKQUVDVWFBRkFHckNGWkhJeTg2QkJBRUFJSlJFQUdDRkpIR0NOOUhRQk1BRkN4K1lVVUJKQUU4NkJCQUZDRVdDeGtVVUJKQUI4cEVOODNFQkFGQ0ZKSEZDVUc5SFFCTU1rOGxMYmFFOTdGOStGYUw5NzhqVVVVVUJDVS9LQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHLzhjQkJDVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSTkFFQ0ZKUktDQlJWR1hFWEFWQUY5UFFGQU5BRkFWbEFWQU5KQUY5SnlSY0dYR1hBRzlGUUJBY0NiSkhJQzl3WkhNQ0U5c1JTQU1DRldSUUFJQ0lyQ0VKQ0dyUmZDQlJiRVhBS1JUQ0JSdEdYRVhHWEFPQVRsQWY5UFFCQ0JSS1NMTUFMQ1UvQ0JKQXRBTTlzSlJtQVRBZkpSS0NCUkVHWEFNQ29COUpRQkFPQUtsQy9nQjlKUUJDQlJJRVhBbUFJSlJFR1hHWEdYR1hHWEFUQUlDS3JKMkJCSFlDRVpmSUJGR0VCTUFFQ0JEdERNSUJTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlCQUtDVEpSS01HWEdYR1hHWEdYQVlDR3JDRVpmSUJGR0VCTUFFQ0JEdERNSVRTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlUQUtDVEpSS01HWEdYR1hHWEdYQVlDSXJDRVpmSUJGR0VCTUFFQ0JEdERNSUFTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlBQUtDVEpSS01HWEdYR1hHWEdYQVlDS3JmSUJGR0VCTUFFQ0JEdERNSTh3U0VNQUVBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSFlDRVdDeGtVVUJKREJFQkFZQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIWUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JOHdBS0NJSkFlRGVCSkFZQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJBWUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSFlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSTh3QUtDTkpBZURlQkpBWUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUk4d0FLQ1RKUktNQUlDb0JKUkVBSUNVRkpBTTlMUUZBRVJJQU9BS2xDL2ZCOUxRQk1NR1hBRUFNOVBRQkFFQ0VyUklFWEdYQU9BS2xDaTlQUUJDQlJLU09NQW1BRUpSWUdYR1hHWEdYR1hBVEFFQ0tySjJCQkFJQ0tackNFWmZJQkZHRUJNQVlDQkR0RE1JQlNFTUFZQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BWUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BWUFLREJCQkRNSUJBS0NUSlJLTUFJQ0dKUklBRUNUSkhFQU05SlFCTU1HWEFLOUZRQkFLUlRBdENGSkh0Q0k2UUdTRk1NQ0JSS1NFTUdYQU05RlFCQUxDVUdKQWJKUkVBTEFiSkRCR0JSZUNCUllFWEFFQUxDVS9DQkpBWUpISURCSUJIZENGRDl0QWRDRkRiSFBEOU9EOWhEOVJIZEFJQU1KREJJQkg4WkNGRDl0QThaQVBEOU9EOWhEOVJIOFpEUUJURnRHbUVZSVBMZEtlT25IcEFJQVFKREJJQkh5Q0ZEOXRBeUFQRDlPRDloRDlSSHlBSUFTSkRCSUJIOGNDRkQ5dEE4Y0FQRDlPRDloRDlSSDhjRFFCVEZ0R21FWUlQTGRLZU9uSDhkRFFCRlR0R0VtWUlMUGRLT2VuSFBBUERRQkZHRUJGR0VCRkdFQkZHRUFlRDl1SGVEeUJqR0JBRUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSkhJQWVBcEE4ZERRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFBBUERRQkZHRUJGR0VCRkdFQkZHRUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pISUFlQWRBOFpEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4ZkhkQXlBOGNEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4Zkg4WkRRQkZUdEdFbVlJTFBkS09lbkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKSElBZUFkQThaRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSlJFQVlDVEpIWUFNOUpRQk1NQWJDSUpIYkFHOUpRQk1NQUJBVkFHOXNKQUxDVUdKQWNBRzlzLzhjQkJBTEFMQ1VHSkFjQ2FKQUc5c0pBRy84Y0JCTUFjQ0JBS3lBVkpSVkFLUUJNQzkrUktTRk1DQkM5OUFPQUtsQUdDQUFHQ0E5THk2eVJLTUFMQ1UvS0JKOGtVVVVVQkFLTU5CVCtCVVVVQk0rS21GVGE4alVVVVVCQ29GbEhMOGtVVVVVQkM5K1JLR1hBRkNFOXVIT0N0SkFJOUxRQkNhUktBRTJCQkhOQy93RlpDL2dGOUhRQkFOQ2JaSFZDRjlMUUJBTENvQkpDZ0ZDVUYvOE1CQUxDODRKaGE4M0VCQUxDOHdKaGE4M0VCQUxDOG9KaGE4M0VCQUxDQUpoYTgzRUJBTENpSmhhODNFQkFMQ1RKaGE4M0VCQUxoYTgzRU5BTGhhODNFQkFFQUlKQzl3SlJjQUVDRkpITkFPSlJNR1hBRjlGUUJDUUNiQVZDRjZ5UlNBQlJFQ0JSVkNCUlFDQlJmQ0JSSUNCUktFWEdYQU1BY3VRQkM5K1JLU0VNR1hHWEFOMkJCSE9DL3ZGOUxRQkFMQ29CSkFPQ0lyQ2E5ekFLSkNiWkNFV0pIYjhvR0lSVEFiOG9HQlJ0R1hBT0NiWkhiQVM5UFFCQUxBT0NhOXpBSUpDYlpDR1dKOG9HQkFWQWJ5Uk9BYjlGUmJHWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQU84N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBT2pHQkFFQ0lKQVRqR0JNQVZBYkpSVkFMQ29CSkFLQ0VXSkhtQU9qR0JBbUFUakdJQUxBSUNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSFRBdGpHQkFUQU9qR0lBSUFiSlJJQUtDRkpSS1NHTUdYR1hBYkNiNlFCQVFBYkpBYkM5ODl6SkNGSlJRU0ZNQU0xQkJIYkNnRlpST0dYR1hBYkNhOU1RQkFNQ0ZKUk1TRk1BTTFCRkhiQ2dCWkNPV0FPQ2dCWnFST0dYQWJDYTlNUUJBTUNHSlJNU0ZNQU0xQkdIYkNnQlpDZldBT3FST0dYQWJDYTlNUUJBTUNFSlJNU0ZNQU0xQkVIYkNnQlpDZFdBT3FST0dYQWJDYTlNUUJBTUNJSlJNU0ZNQU0yQklDOGNXQU9xUk9BTUNMSlJNTUFPQ0ZyQ0JBT0NGWmw5ekFRSlJRTUdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBUTg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFRakdCQUVDSUpBVGpHQk1BTENvQkpBS0NFV0pIT0FRakdCQU9BVGpHSUFMQUlDR1dKQVFqR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhPQXRqR0JBT0FRakdJQUlDRkpSSUFLQ0ZKUktTRk1HWEFPQ0RGOUxRQkFMQUlBY0FPQ2JaSjJCQkhiQ0lySFRsQ2JaQ0dXSjhvR0JBVkNGSkh0QVR5Uk9BTEFJQWJsQ2JaQ0dXSjhvR0JBdEFUOUZIbUpIdEFiQ2JaSFR5UmJBVDlGUlRHWEdYQUdDRzlIUUJBQkFWODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFWakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxBSUNHV0pBVmpHQkFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFWakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQW1KQ2JaSElDR1dKQWJqR0JBTENvQkpBS0NHSkNiWkhLQ0VXSkhPQVZqR0JBT0FiakdJQUtDRkpSS0FJQVRKUklBdEFUSlJWU0ZNQVZDQkFNMkJCSFl5SFRBT0MvK0Y2SFBKUk9BWUNiWlJ0R1hHWEFZQ0lySG1RQkFPQ0ZKUmJTRk1BT1JiQUxBSUFtbENiWkNHV0o4b0dCUk9NR1hHWEF0UUJBYkNGSlJWU0ZNQWJSVkFMQUlBWWxDYlpDR1dKOG9HQlJiTUdYR1hBUDlGUUJBTUNGSlJZU0ZNQU0xQkZIWUNnRlpSVEdYR1hBWUNhOU1RQkFNQ0dKUllTRk1BTTFCR0hZQ2dCWkNPV0FUQ2dCWnFSVEdYQVlDYTlNUUJBTUNFSlJZU0ZNQU0xQkVIWUNnQlpDZldBVHFSVEdYQVlDYTlNUUJBTUNJSlJZU0ZNQU0xQklIWUNnQlpDZFdBVHFSVEdYQVlDYTlNUUJBTUNMSlJZU0ZNQU1DS0pSWUFNMkJMQzhjV0FUcVJUTUFUQ0ZyQ0JBVENGWmw5ekFRSkhRUlRNR1hHWEFtQ2I2UUJBWVJQU0ZNQVkxQkJITUNnRlpST0dYR1hBTUNhOU1RQkFZQ0ZKUlBTRk1BWTFCRkhNQ2dCWkNPV0FPQ2dCWnFST0dYQU1DYTlNUUJBWUNHSlJQU0ZNQVkxQkdITUNnQlpDZldBT3FST0dYQU1DYTlNUUJBWUNFSlJQU0ZNQVkxQkVITUNnQlpDZFdBT3FST0dYQU1DYTlNUUJBWUNJSlJQU0ZNQVlDTEpSUEFZMkJJQzhjV0FPcVJPTUFPQ0ZyQ0JBT0NGWmw5ekFRSkhRUk9NR1hHWEF0Q2I2UUJBUFJNU0ZNQVAxQkJITUNnRlpSYkdYR1hBTUNhOU1RQkFQQ0ZKUk1TRk1BUDFCRkhNQ2dCWkNPV0FiQ2dCWnFSYkdYQU1DYTlNUUJBUENHSlJNU0ZNQVAxQkdITUNnQlpDZldBYnFSYkdYQU1DYTlNUUJBUENFSlJNU0ZNQVAxQkVITUNnQlpDZFdBYnFSYkdYQU1DYTlNUUJBUENJSlJNU0ZNQVBDTEpSTUFQMkJJQzhjV0FicVJiTUFiQ0ZyQ0JBYkNGWmw5ekFRSkhRUmJNR1hHWEFHQ0c5SFFCQUJBVDg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVGpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFUakdJQUxBSUNHV0pBVGpHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDR0pDYlpDRVdKSE9BVGpHQkFPQWJqR0lBTEFJQW05RkFtQ2I2cUpISUNiWkNHV0pBYmpHQkFJQXQ5RkF0Q2I2cUpSSUFLQ0VKUktNQU5DRkpSTkFCQ0tKUkJBRUNTSlJFQUtDYlpSS0FJQ2JaUklBZkNFSkhmQUY5SlFCTU1DQkM5OUFNQWM2eVJLTUFMQ29GSjhrVVVVVUJBS00vdElGR2E4alVVVVVCQ1RsUkxDOStSS0dYQUZDTEpBSTlMUUJDYVJLQUUyQkJDLytGWkMvUUY5SFFCQUxoQjgzRU5BRUNGSlJLQUVBSUpDOThKUkVHWEFGOUZRQkdYQUdDRzZRQkVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFMQ05KQUlDRlpDR1dxSEdBSUNHckNCQUlDRnJDRlpsOXpBRzhvR0JKSElqR0JBQkFJakdCQUJDSUpSQkFGQ2FKSEZRQlNHTU1FWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BQkFJQ0dyQ0JBSUNGckNGWmw5ekFMQ05KQUlDRlpDR1dxSEk4b0dCSkhHODdGQkFJQUdqR0JBQkNHSlJCQUZDYUpIRlFCTU1DQkM5OUFLQUU2eVJLTUFLTS9kTEVLOTdGYUY5N0dYR1hBR0NJOUhRQkFGOUZRRkNCUkdFWEFCQUJEQkJCSEVDaUQrckZDaUQrc0ZELzZGSElBRUNORCtyRkNpRCtzRkQvNkZBSUQvZ0ZBRUNURCtyRkNpRCtzRkQvNkZITEQvZ0ZEL2tGRC9sRkhLQ0JEdEQrMkZIT0FJQ1VVVVU5NER0SE5EOU9EOVJEL2tGSEk5REJCLytoRFlBSUFJRC9tRkFLQUtEL21GQUxBT0FMQU5EOU9EOVJEL2tGSElBSUQvbUZEL2tGRC9rRkQvakZEL25GSExEL21GOURCQlg5TERZSE9EL2tGQ2dGRHREOU9BRUNVVVU5NER0RDlPRDlRQUlBTEQvbUZBT0Qva0ZDTkQrckZDVS8rRUR0RDlPRDlRQUtBTEQvbUZBT0Qva0ZDVEQrckZDVVUvOE9EdEQ5T0Q5UURNQkJBQkNUSlJCQUdDSUpIR0FGOUpRQlNHTU1BRjlGUUJDQlJHRVhBQkNUSkhWQVZEQkJCSEVDQkR0SE9DVVU5OEQ4Y0ZDVVU5OEQ4Y0VITkQ5T0FCREJCQkhLQUVEUUlMS09TUWZiUGRlbjhjOGQ4ZThmQ2dnRkR0RDlPRC82RkFLQUVEUUJGR0VOVmNNVHRtWWk4WnB5SEVDVEQrc0ZELzZGSElEL2dGQUVDVEQrckZDVEQrc0ZELzZGSExEL2dGRC9rRkQvbEZIRTlEQi8rZzZEWUFMQUVBT0QrMkZIT0FMQ1VVVVU5NER0SGNEOU9EOVJEL2tGSExBTEQvbUZBRUFFRC9tRkFJQU9BSUFjRDlPRDlSRC9rRkhFQUVEL21GRC9rRkQva0ZEL2pGRC9uRkhJRC9tRjlEQkJYOUxEWUhPRC9rRkNURCtyRkFMQUlEL21GQU9EL2tGQ2dnRUR0RDlPRDlRSExBRUFJRC9tRkFPRC9rRkNhRGJDQkRuR0NCRG5FQ0JEbktDQkRuT0NCRG5jQ0JEbk1DQkRuZkNCRG5iRDlPSEVEUU5WaThaY01weVNROGM4ZGZiOGU4ZkQ5UURNQkJBQkFLQU5EOU9BTEFFRFFCRlR0R0VtWUlMUGRLT2VuRDlRRE1CQkFCQ0FKUkJBR0NJSkhHQUY5SlFCTU1NL2hFSUdhRjk3RmFMOTc4alVVVVVCQ1RsUkVHWEFGOUZRQkNCUklFWEFFQUJEQkJCSExBQkNUSkhLREJCQkhPRFFJTEtPU1FmYlBkZW44YzhkOGU4ZkhOQ1REK3NGSFZDSUQrckZETUlCQUI5REJCVTgvRFk5RC96STgxOC9EWUFWQ0VEdEQ5UUQvNkZEL25GSFZBTEFPRFFCRkdFTlZjTVR0bVlpOFpweUhMQ1REK3JGQ1REK3NGRC82RkQvbUZIT0FPRC9tRkFWQUxDVEQrc0ZELzZGRC9tRkhjQWNEL21GQVZBTkNURCtyRkNURCtzRkQvNkZEL21GSE5BTkQvbUZEL2tGRC9rRkQvbEZDQkR0RCs0RkQvakY5REIvK2c2RFlIVkQvbUY5REJCWDlMRFlITEQva0ZDZ2dFRHRITUQ5T0FjQVZEL21GQUxEL2tGQ1REK3JGRDlRSGNBTkFWRC9tRkFMRC9rRkNURCtyRkFPQVZEL21GQUxEL2tGQU1EOU9EOVFIVkRRQkZUdEdFbVlJTFBkS09lbkhMRDhkQkFFREJJQkR5Qit0K0o4M0VCQUJDTkpBTEQ4ZEZBRURCSUJEeUYrdCtKODNFQkFLQWNBVkRRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFZEOGRCQUVEQklCRHlHK3QrSjgzRUJBQkNpSkFWRDhkRkFFREJJQkR5RSt0K0o4M0VCQUJDQUpSQkFJQ0lKSElBRjlKUUJNTU05akZGOTdHWEFHQ0dyQUY5c0hHOUZRQkNCUkZFWEFCQUJEQkJCSEVDTkQrckZDTkQrc0ZELzZGQUVDaUQrc0ZDbkQrckZDVVVVLzhFRHREK3VGRC9tRkRNQkJBQkNUSlJCQUZDSUpIRkFHOUpRQk1NTTlURkVhQ0JDQjhvR1VrVVVCSEZBQkNFSkM5OFpKSEJqR1VrVVVCR1hHWEFCOC9CQ1RXSEd1UUJDYVJFQUJBR2xDZ2dFSkNUclhCQ2E2UUZNQUZSRU1BRU1NTUZCQ1VOTUlUOXRCQlwiO1xuICBjb25zdCBkZXRlY3RvciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAwLFxuICAgIDk3LFxuICAgIDExNSxcbiAgICAxMDksXG4gICAgMSxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAxLFxuICAgIDQsXG4gICAgMSxcbiAgICA5NixcbiAgICAwLFxuICAgIDAsXG4gICAgMyxcbiAgICAzLFxuICAgIDIsXG4gICAgMCxcbiAgICAwLFxuICAgIDUsXG4gICAgMyxcbiAgICAxLFxuICAgIDAsXG4gICAgMSxcbiAgICAxMixcbiAgICAxLFxuICAgIDAsXG4gICAgMTAsXG4gICAgMjIsXG4gICAgMixcbiAgICAxMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDI1MixcbiAgICAxMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMTEsXG4gICAgNyxcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgMjUzLFxuICAgIDE1LFxuICAgIDI2LFxuICAgIDExXG4gIF0pO1xuICBjb25zdCB3YXNtcGFjayA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAzMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDI1MyxcbiAgICAzLFxuICAgIDEsXG4gICAgMixcbiAgICAzNCxcbiAgICA0LFxuICAgIDEwNixcbiAgICA2LFxuICAgIDUsXG4gICAgMTEsXG4gICAgOCxcbiAgICA3LFxuICAgIDIwLFxuICAgIDEzLFxuICAgIDMzLFxuICAgIDEyLFxuICAgIDE2LFxuICAgIDEyOCxcbiAgICA5LFxuICAgIDExNixcbiAgICA2NCxcbiAgICAxOSxcbiAgICAxMTMsXG4gICAgMTI3LFxuICAgIDE1LFxuICAgIDEwLFxuICAgIDIxLFxuICAgIDIyLFxuICAgIDE0LFxuICAgIDI1NSxcbiAgICA2NixcbiAgICAyNCxcbiAgICA1NCxcbiAgICAxMzYsXG4gICAgMTA3LFxuICAgIDE4LFxuICAgIDIzLFxuICAgIDE5MixcbiAgICAyNixcbiAgICAxMTQsXG4gICAgMTE4LFxuICAgIDEzMixcbiAgICAxNyxcbiAgICA3NyxcbiAgICAxMDEsXG4gICAgMTMwLFxuICAgIDE0NCxcbiAgICAyNyxcbiAgICA4NyxcbiAgICAxMzEsXG4gICAgNDQsXG4gICAgNDUsXG4gICAgNzQsXG4gICAgMTU2LFxuICAgIDE1NCxcbiAgICA3MCxcbiAgICAxNjdcbiAgXSk7XG4gIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VwcG9ydGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgbGV0IHdhc20gPSB3YXNtX2Jhc2U7XG4gIGlmIChXZWJBc3NlbWJseS52YWxpZGF0ZShkZXRlY3RvcikpIHtcbiAgICB3YXNtID0gd2FzbV9zaW1kO1xuICB9XG4gIGxldCBpbnN0YW5jZTtcbiAgY29uc3QgcHJvbWlzZSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHVucGFjayh3YXNtKSwge30pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgIGluc3RhbmNlID0gcmVzdWx0Lmluc3RhbmNlO1xuICAgIGluc3RhbmNlLmV4cG9ydHMuX193YXNtX2NhbGxfY3RvcnMoKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHVucGFjayhkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY2ggPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICByZXN1bHRbaV0gPSBjaCA+IDk2ID8gY2ggLSA3MSA6IGNoID4gNjQgPyBjaCAtIDY1IDogY2ggPiA0NyA/IGNoICsgNCA6IGNoID4gNDYgPyA2MyA6IDYyO1xuICAgIH1cbiAgICBsZXQgd3JpdGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0W3dyaXRlKytdID0gcmVzdWx0W2ldIDwgNjAgPyB3YXNtcGFja1tyZXN1bHRbaV1dIDogKHJlc3VsdFtpXSAtIDYwKSAqIDY0ICsgcmVzdWx0WysraV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuYnVmZmVyLnNsaWNlKDAsIHdyaXRlKTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUoZnVuLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIGZpbHRlcikge1xuICAgIGNvbnN0IHNicmsgPSBpbnN0YW5jZS5leHBvcnRzLnNicms7XG4gICAgY29uc3QgY291bnQ0ID0gY291bnQgKyAzICYgfjM7XG4gICAgY29uc3QgdHAgPSBzYnJrKGNvdW50NCAqIHNpemUpO1xuICAgIGNvbnN0IHNwID0gc2Jyayhzb3VyY2UubGVuZ3RoKTtcbiAgICBjb25zdCBoZWFwID0gbmV3IFVpbnQ4QXJyYXkoaW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKTtcbiAgICBoZWFwLnNldChzb3VyY2UsIHNwKTtcbiAgICBjb25zdCByZXMgPSBmdW4odHAsIGNvdW50LCBzaXplLCBzcCwgc291cmNlLmxlbmd0aCk7XG4gICAgaWYgKHJlcyA9PT0gMCAmJiBmaWx0ZXIpIHtcbiAgICAgIGZpbHRlcih0cCwgY291bnQ0LCBzaXplKTtcbiAgICB9XG4gICAgdGFyZ2V0LnNldChoZWFwLnN1YmFycmF5KHRwLCB0cCArIGNvdW50ICogc2l6ZSkpO1xuICAgIHNicmsodHAgLSBzYnJrKDApKTtcbiAgICBpZiAocmVzICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBidWZmZXIgZGF0YTogJHtyZXN9YCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpbHRlcnMgPSB7XG4gICAgLy8gbGVnYWN5IGluZGV4LWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgMDogXCJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgMjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICAzOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyRXhwXCIsXG4gICAgLy8gc3RyaW5nLWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgTk9ORTogXCJcIixcbiAgICBPQ1RBSEVEUkFMOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgUVVBVEVSTklPTjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICBFWFBPTkVOVElBTDogXCJtZXNob3B0X2RlY29kZUZpbHRlckV4cFwiXG4gIH07XG4gIGNvbnN0IGRlY29kZXJzID0ge1xuICAgIC8vIGxlZ2FjeSBpbmRleC1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIDA6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXJcIixcbiAgICAyOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZVwiLFxuICAgIC8vIHN0cmluZy1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIEFUVFJJQlVURVM6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICBUUklBTkdMRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlclwiLFxuICAgIElORElDRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlXCJcbiAgfTtcbiAgZ2VuZXJhdGVkID0ge1xuICAgIHJlYWR5OiBwcm9taXNlLFxuICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICBkZWNvZGVWZXJ0ZXhCdWZmZXIodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlLCBmaWx0ZXIpIHtcbiAgICAgIGRlY29kZShcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlcixcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleEJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpIHtcbiAgICAgIGRlY29kZShpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXIsIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleFNlcXVlbmNlKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSkge1xuICAgICAgZGVjb2RlKGluc3RhbmNlLmV4cG9ydHMubWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpO1xuICAgIH0sXG4gICAgZGVjb2RlR2x0ZkJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIG1vZGUsIGZpbHRlcikge1xuICAgICAgZGVjb2RlKFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2RlY29kZXJzW21vZGVdXSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZ2VuZXJhdGVkO1xufTtcbmV4cG9ydCB7XG4gIE1lc2hvcHREZWNvZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaG9wdERlY29kZXIuanMubWFwXG4iXSwibmFtZXMiOlsiZ2VuZXJhdGVkIiwiTWVzaG9wdERlY29kZXIiLCJ3YXNtX2Jhc2UiLCJ3YXNtX3NpbWQiLCJkZXRlY3RvciIsIlVpbnQ4QXJyYXkiLCJ3YXNtcGFjayIsIldlYkFzc2VtYmx5Iiwic3VwcG9ydGVkIiwid2FzbSIsInZhbGlkYXRlIiwiaW5zdGFuY2UiLCJwcm9taXNlIiwiaW5zdGFudGlhdGUiLCJ1bnBhY2siLCJ0aGVuIiwicmVzdWx0IiwiZXhwb3J0cyIsIl9fd2FzbV9jYWxsX2N0b3JzIiwiZGF0YSIsImxlbmd0aCIsImkiLCJjaCIsImNoYXJDb2RlQXQiLCJ3cml0ZSIsImJ1ZmZlciIsInNsaWNlIiwiZGVjb2RlIiwiZnVuIiwidGFyZ2V0IiwiY291bnQiLCJzaXplIiwic291cmNlIiwiZmlsdGVyIiwic2JyayIsImNvdW50NCIsInRwIiwic3AiLCJoZWFwIiwibWVtb3J5Iiwic2V0IiwicmVzIiwic3ViYXJyYXkiLCJFcnJvciIsImZpbHRlcnMiLCJOT05FIiwiT0NUQUhFRFJBTCIsIlFVQVRFUk5JT04iLCJFWFBPTkVOVElBTCIsImRlY29kZXJzIiwiQVRUUklCVVRFUyIsIlRSSUFOR0xFUyIsIklORElDRVMiLCJyZWFkeSIsImRlY29kZVZlcnRleEJ1ZmZlciIsIm1lc2hvcHRfZGVjb2RlVmVydGV4QnVmZmVyIiwiZGVjb2RlSW5kZXhCdWZmZXIiLCJtZXNob3B0X2RlY29kZUluZGV4QnVmZmVyIiwiZGVjb2RlSW5kZXhTZXF1ZW5jZSIsIm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZSIsImRlY29kZUdsdGZCdWZmZXIiLCJtb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: () => (/* binding */ DRACOLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.decoderPath = \"\";\n        this.decoderConfig = {};\n        this.decoderBinary = null;\n        this.decoderPending = null;\n        this.workerLimit = 4;\n        this.workerPool = [];\n        this.workerNextTaskID = 1;\n        this.workerSourceURL = \"\";\n        this.defaultAttributeIDs = {\n            position: \"POSITION\",\n            normal: \"NORMAL\",\n            color: \"COLOR\",\n            uv: \"TEX_COORD\"\n        };\n        this.defaultAttributeTypes = {\n            position: \"Float32Array\",\n            normal: \"Float32Array\",\n            color: \"Float32Array\",\n            uv: \"Float32Array\"\n        };\n    }\n    setDecoderPath(path) {\n        this.decoderPath = path;\n        return this;\n    }\n    setDecoderConfig(config) {\n        this.decoderConfig = config;\n        return this;\n    }\n    setWorkerLimit(workerLimit) {\n        this.workerLimit = workerLimit;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, (buffer)=>{\n            const taskConfig = {\n                attributeIDs: this.defaultAttributeIDs,\n                attributeTypes: this.defaultAttributeTypes,\n                useUniqueIDs: false\n            };\n            this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n        }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */ decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n        const taskConfig = {\n            attributeIDs: attributeIDs || this.defaultAttributeIDs,\n            attributeTypes: attributeTypes || this.defaultAttributeTypes,\n            useUniqueIDs: !!attributeIDs\n        };\n        this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n    decodeGeometry(buffer, taskConfig) {\n        for(const attribute in taskConfig.attributeTypes){\n            const type = taskConfig.attributeTypes[attribute];\n            if (type.BYTES_PER_ELEMENT !== void 0) {\n                taskConfig.attributeTypes[attribute] = type.name;\n            }\n        }\n        const taskKey = JSON.stringify(taskConfig);\n        if (_taskCache.has(buffer)) {\n            const cachedTask = _taskCache.get(buffer);\n            if (cachedTask.key === taskKey) {\n                return cachedTask.promise;\n            } else if (buffer.byteLength === 0) {\n                throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n            }\n        }\n        let worker;\n        const taskID = this.workerNextTaskID++;\n        const taskCost = buffer.byteLength;\n        const geometryPending = this._getWorker(taskID, taskCost).then((_worker)=>{\n            worker = _worker;\n            return new Promise((resolve, reject)=>{\n                worker._callbacks[taskID] = {\n                    resolve,\n                    reject\n                };\n                worker.postMessage({\n                    type: \"decode\",\n                    id: taskID,\n                    taskConfig,\n                    buffer\n                }, [\n                    buffer\n                ]);\n            });\n        }).then((message)=>this._createGeometry(message.geometry));\n        geometryPending.catch(()=>true).then(()=>{\n            if (worker && taskID) {\n                this._releaseTask(worker, taskID);\n            }\n        });\n        _taskCache.set(buffer, {\n            key: taskKey,\n            promise: geometryPending\n        });\n        return geometryPending;\n    }\n    _createGeometry(geometryData) {\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n        if (geometryData.index) {\n            geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n        }\n        for(let i = 0; i < geometryData.attributes.length; i++){\n            const attribute = geometryData.attributes[i];\n            const name = attribute.name;\n            const array = attribute.array;\n            const itemSize = attribute.itemSize;\n            geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n        }\n        return geometry;\n    }\n    _loadLibrary(url, responseType) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.decoderPath);\n        loader.setResponseType(responseType);\n        loader.setWithCredentials(this.withCredentials);\n        return new Promise((resolve, reject)=>{\n            loader.load(url, resolve, void 0, reject);\n        });\n    }\n    preload() {\n        this._initDecoder();\n        return this;\n    }\n    _initDecoder() {\n        if (this.decoderPending) return this.decoderPending;\n        const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n        const librariesPending = [];\n        if (useJS) {\n            librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n        } else {\n            librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n            librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n        }\n        this.decoderPending = Promise.all(librariesPending).then((libraries)=>{\n            const jsContent = libraries[0];\n            if (!useJS) {\n                this.decoderConfig.wasmBinary = libraries[1];\n            }\n            const fn = DRACOWorker.toString();\n            const body = [\n                \"/* draco decoder */\",\n                jsContent,\n                \"\",\n                \"/* worker */\",\n                fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n            ].join(\"\\n\");\n            this.workerSourceURL = URL.createObjectURL(new Blob([\n                body\n            ]));\n        });\n        return this.decoderPending;\n    }\n    _getWorker(taskID, taskCost) {\n        return this._initDecoder().then(()=>{\n            if (this.workerPool.length < this.workerLimit) {\n                const worker2 = new Worker(this.workerSourceURL);\n                worker2._callbacks = {};\n                worker2._taskCosts = {};\n                worker2._taskLoad = 0;\n                worker2.postMessage({\n                    type: \"init\",\n                    decoderConfig: this.decoderConfig\n                });\n                worker2.onmessage = function(e) {\n                    const message = e.data;\n                    switch(message.type){\n                        case \"decode\":\n                            worker2._callbacks[message.id].resolve(message);\n                            break;\n                        case \"error\":\n                            worker2._callbacks[message.id].reject(message);\n                            break;\n                        default:\n                            console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n                    }\n                };\n                this.workerPool.push(worker2);\n            } else {\n                this.workerPool.sort(function(a, b) {\n                    return a._taskLoad > b._taskLoad ? -1 : 1;\n                });\n            }\n            const worker = this.workerPool[this.workerPool.length - 1];\n            worker._taskCosts[taskID] = taskCost;\n            worker._taskLoad += taskCost;\n            return worker;\n        });\n    }\n    _releaseTask(worker, taskID) {\n        worker._taskLoad -= worker._taskCosts[taskID];\n        delete worker._callbacks[taskID];\n        delete worker._taskCosts[taskID];\n    }\n    debug() {\n        console.log(\"Task load: \", this.workerPool.map((worker)=>worker._taskLoad));\n    }\n    dispose() {\n        for(let i = 0; i < this.workerPool.length; ++i){\n            this.workerPool[i].terminate();\n        }\n        this.workerPool.length = 0;\n        return this;\n    }\n}\nfunction DRACOWorker() {\n    let decoderConfig;\n    let decoderPending;\n    onmessage = function(e) {\n        const message = e.data;\n        switch(message.type){\n            case \"init\":\n                decoderConfig = message.decoderConfig;\n                decoderPending = new Promise(function(resolve) {\n                    decoderConfig.onModuleLoaded = function(draco) {\n                        resolve({\n                            draco\n                        });\n                    };\n                    DracoDecoderModule(decoderConfig);\n                });\n                break;\n            case \"decode\":\n                const buffer = message.buffer;\n                const taskConfig = message.taskConfig;\n                decoderPending.then((module)=>{\n                    const draco = module.draco;\n                    const decoder = new draco.Decoder();\n                    const decoderBuffer = new draco.DecoderBuffer();\n                    decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n                    try {\n                        const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n                        const buffers = geometry.attributes.map((attr)=>attr.array.buffer);\n                        if (geometry.index) buffers.push(geometry.index.array.buffer);\n                        self.postMessage({\n                            type: \"decode\",\n                            id: message.id,\n                            geometry\n                        }, buffers);\n                    } catch (error) {\n                        console.error(error);\n                        self.postMessage({\n                            type: \"error\",\n                            id: message.id,\n                            error: error.message\n                        });\n                    } finally{\n                        draco.destroy(decoderBuffer);\n                        draco.destroy(decoder);\n                    }\n                });\n                break;\n        }\n    };\n    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n        const attributeIDs = taskConfig.attributeIDs;\n        const attributeTypes = taskConfig.attributeTypes;\n        let dracoGeometry;\n        let decodingStatus;\n        const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            dracoGeometry = new draco.Mesh();\n            decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n        } else if (geometryType === draco.POINT_CLOUD) {\n            dracoGeometry = new draco.PointCloud();\n            decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n        } else {\n            throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n        }\n        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n            throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n        }\n        const geometry = {\n            index: null,\n            attributes: []\n        };\n        for(const attributeName in attributeIDs){\n            const attributeType = self[attributeTypes[attributeName]];\n            let attribute;\n            let attributeID;\n            if (taskConfig.useUniqueIDs) {\n                attributeID = attributeIDs[attributeName];\n                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n            } else {\n                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n                if (attributeID === -1) continue;\n                attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n            }\n            geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n        }\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n        }\n        draco.destroy(dracoGeometry);\n        return geometry;\n    }\n    function decodeIndex(draco, decoder, dracoGeometry) {\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * 4;\n        const ptr = draco._malloc(byteLength);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n        const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        return {\n            array: index,\n            itemSize: 1\n        };\n    }\n    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n        const numComponents = attribute.num_components();\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(draco, attributeType);\n        const ptr = draco._malloc(byteLength);\n        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n        const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n        draco._free(ptr);\n        return {\n            name: attributeName,\n            array,\n            itemSize: numComponents\n        };\n    }\n    function getDracoDataType(draco, attributeType) {\n        switch(attributeType){\n            case Float32Array:\n                return draco.DT_FLOAT32;\n            case Int8Array:\n                return draco.DT_INT8;\n            case Int16Array:\n                return draco.DT_INT16;\n            case Int32Array:\n                return draco.DT_INT32;\n            case Uint8Array:\n                return draco.DT_UINT8;\n            case Uint16Array:\n                return draco.DT_UINT16;\n            case Uint32Array:\n                return draco.DT_UINT32;\n        }\n    }\n}\n //# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRFJBQ09Mb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEU7QUFDNUUsTUFBTUksYUFBYSxhQUFhLEdBQUcsSUFBSUM7QUFDdkMsTUFBTUMsb0JBQW9CTix5Q0FBTUE7SUFDOUJPLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQztRQUN0QixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztZQUN6QkMsVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO1FBQ0EsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRztZQUMzQkosVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO0lBQ0Y7SUFDQUUsZUFBZUMsSUFBSSxFQUFFO1FBQ25CLElBQUksQ0FBQ2YsV0FBVyxHQUFHZTtRQUNuQixPQUFPLElBQUk7SUFDYjtJQUNBQyxpQkFBaUJDLE1BQU0sRUFBRTtRQUN2QixJQUFJLENBQUNoQixhQUFhLEdBQUdnQjtRQUNyQixPQUFPLElBQUk7SUFDYjtJQUNBQyxlQUFlZCxXQUFXLEVBQUU7UUFDMUIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO1FBQ25CLE9BQU8sSUFBSTtJQUNiO0lBQ0FlLEtBQUtDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxNQUFNQyxTQUFTLElBQUloQyw2Q0FBVUEsQ0FBQyxJ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QUtDO2dCQUNILE9BQU94RCxNQUFNeUQsUUFBUTtZQUN2QixLQUFLQztnQkFDSCxPQUFPMUQsTUFBTTJELFFBQVE7WUFDdkIsS0FBS0M7Z0JBQ0gsT0FBTzVELE1BQU02RCxTQUFTO1lBQ3hCLEtBQUt0QjtnQkFDSCxPQUFPdkMsTUFBTThELFNBQVM7UUFDMUI7SUFDRjtBQUNGO0FBR0UsQ0FDRix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtY3JlYXRpdmUtcG9ydGZvbGlvLXN0YXJ0ZXItY29kZS1maWxlcy8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9EUkFDT0xvYWRlci5qcz83NGY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvYWRlciwgRmlsZUxvYWRlciwgQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgX3Rhc2tDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY2xhc3MgRFJBQ09Mb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy5kZWNvZGVyUGF0aCA9IFwiXCI7XG4gICAgdGhpcy5kZWNvZGVyQ29uZmlnID0ge307XG4gICAgdGhpcy5kZWNvZGVyQmluYXJ5ID0gbnVsbDtcbiAgICB0aGlzLmRlY29kZXJQZW5kaW5nID0gbnVsbDtcbiAgICB0aGlzLndvcmtlckxpbWl0ID0gNDtcbiAgICB0aGlzLndvcmtlclBvb2wgPSBbXTtcbiAgICB0aGlzLndvcmtlck5leHRUYXNrSUQgPSAxO1xuICAgIHRoaXMud29ya2VyU291cmNlVVJMID0gXCJcIjtcbiAgICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMgPSB7XG4gICAgICBwb3NpdGlvbjogXCJQT1NJVElPTlwiLFxuICAgICAgbm9ybWFsOiBcIk5PUk1BTFwiLFxuICAgICAgY29sb3I6IFwiQ09MT1JcIixcbiAgICAgIHV2OiBcIlRFWF9DT09SRFwiXG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgbm9ybWFsOiBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgY29sb3I6IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICB1djogXCJGbG9hdDMyQXJyYXlcIlxuICAgIH07XG4gIH1cbiAgc2V0RGVjb2RlclBhdGgocGF0aCkge1xuICAgIHRoaXMuZGVjb2RlclBhdGggPSBwYXRoO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldERlY29kZXJDb25maWcoY29uZmlnKSB7XG4gICAgdGhpcy5kZWNvZGVyQ29uZmlnID0gY29uZmlnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFdvcmtlckxpbWl0KHdvcmtlckxpbWl0KSB7XG4gICAgdGhpcy53b3JrZXJMaW1pdCA9IHdvcmtlckxpbWl0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgbG9hZGVyLmxvYWQoXG4gICAgICB1cmwsXG4gICAgICAoYnVmZmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhc2tDb25maWcgPSB7XG4gICAgICAgICAgYXR0cmlidXRlSURzOiB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMsXG4gICAgICAgICAgYXR0cmlidXRlVHlwZXM6IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzLFxuICAgICAgICAgIHVzZVVuaXF1ZUlEczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWNvZGVHZW9tZXRyeShidWZmZXIsIHRhc2tDb25maWcpLnRoZW4ob25Mb2FkKS5jYXRjaChvbkVycm9yKTtcbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgb25FcnJvclxuICAgICk7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIEtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyBEUkFDT0xvYWRlciB2ZXJzaW9ucy4gKi9cbiAgZGVjb2RlRHJhY29GaWxlKGJ1ZmZlciwgY2FsbGJhY2ssIGF0dHJpYnV0ZUlEcywgYXR0cmlidXRlVHlwZXMpIHtcbiAgICBjb25zdCB0YXNrQ29uZmlnID0ge1xuICAgICAgYXR0cmlidXRlSURzOiBhdHRyaWJ1dGVJRHMgfHwgdGhpcy5kZWZhdWx0QXR0cmlidXRlSURzLFxuICAgICAgYXR0cmlidXRlVHlwZXM6IGF0dHJpYnV0ZVR5cGVzIHx8IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzLFxuICAgICAgdXNlVW5pcXVlSURzOiAhIWF0dHJpYnV0ZUlEc1xuICAgIH07XG4gICAgdGhpcy5kZWNvZGVHZW9tZXRyeShidWZmZXIsIHRhc2tDb25maWcpLnRoZW4oY2FsbGJhY2spO1xuICB9XG4gIGRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykge1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIGluIHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzW2F0dHJpYnV0ZV07XG4gICAgICBpZiAodHlwZS5CWVRFU19QRVJfRUxFTUVOVCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlXSA9IHR5cGUubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGFza0tleSA9IEpTT04uc3RyaW5naWZ5KHRhc2tDb25maWcpO1xuICAgIGlmIChfdGFza0NhY2hlLmhhcyhidWZmZXIpKSB7XG4gICAgICBjb25zdCBjYWNoZWRUYXNrID0gX3Rhc2tDYWNoZS5nZXQoYnVmZmVyKTtcbiAgICAgIGlmIChjYWNoZWRUYXNrLmtleSA9PT0gdGFza0tleSkge1xuICAgICAgICByZXR1cm4gY2FjaGVkVGFzay5wcm9taXNlO1xuICAgICAgfSBlbHNlIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5EUkFDT0xvYWRlcjogVW5hYmxlIHRvIHJlLWRlY29kZSBhIGJ1ZmZlciB3aXRoIGRpZmZlcmVudCBzZXR0aW5ncy4gQnVmZmVyIGhhcyBhbHJlYWR5IGJlZW4gdHJhbnNmZXJyZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHdvcmtlcjtcbiAgICBjb25zdCB0YXNrSUQgPSB0aGlzLndvcmtlck5leHRUYXNrSUQrKztcbiAgICBjb25zdCB0YXNrQ29zdCA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGdlb21ldHJ5UGVuZGluZyA9IHRoaXMuX2dldFdvcmtlcih0YXNrSUQsIHRhc2tDb3N0KS50aGVuKChfd29ya2VyKSA9PiB7XG4gICAgICB3b3JrZXIgPSBfd29ya2VyO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgd29ya2VyLl9jYWxsYmFja3NbdGFza0lEXSA9IHsgcmVzb2x2ZSwgcmVqZWN0IH07XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZGVjb2RlXCIsIGlkOiB0YXNrSUQsIHRhc2tDb25maWcsIGJ1ZmZlciB9LCBbYnVmZmVyXSk7XG4gICAgICB9KTtcbiAgICB9KS50aGVuKChtZXNzYWdlKSA9PiB0aGlzLl9jcmVhdGVHZW9tZXRyeShtZXNzYWdlLmdlb21ldHJ5KSk7XG4gICAgZ2VvbWV0cnlQZW5kaW5nLmNhdGNoKCgpID0+IHRydWUpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHdvcmtlciAmJiB0YXNrSUQpIHtcbiAgICAgICAgdGhpcy5fcmVsZWFzZVRhc2sod29ya2VyLCB0YXNrSUQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90YXNrQ2FjaGUuc2V0KGJ1ZmZlciwge1xuICAgICAga2V5OiB0YXNrS2V5LFxuICAgICAgcHJvbWlzZTogZ2VvbWV0cnlQZW5kaW5nXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5UGVuZGluZztcbiAgfVxuICBfY3JlYXRlR2VvbWV0cnkoZ2VvbWV0cnlEYXRhKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnlEYXRhLmluZGV4KSB7XG4gICAgICBnZW9tZXRyeS5zZXRJbmRleChuZXcgQnVmZmVyQXR0cmlidXRlKGdlb21ldHJ5RGF0YS5pbmRleC5hcnJheSwgMSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJ5RGF0YS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeURhdGEuYXR0cmlidXRlc1tpXTtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcbiAgICAgIGNvbnN0IGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIF9sb2FkTGlicmFyeSh1cmwsIHJlc3BvbnNlVHlwZSkge1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5kZWNvZGVyUGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShyZXNwb25zZVR5cGUpO1xuICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsb2FkZXIubG9hZCh1cmwsIHJlc29sdmUsIHZvaWQgMCwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBwcmVsb2FkKCkge1xuICAgIHRoaXMuX2luaXREZWNvZGVyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2luaXREZWNvZGVyKCkge1xuICAgIGlmICh0aGlzLmRlY29kZXJQZW5kaW5nKVxuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlclBlbmRpbmc7XG4gICAgY29uc3QgdXNlSlMgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09IFwib2JqZWN0XCIgfHwgdGhpcy5kZWNvZGVyQ29uZmlnLnR5cGUgPT09IFwianNcIjtcbiAgICBjb25zdCBsaWJyYXJpZXNQZW5kaW5nID0gW107XG4gICAgaWYgKHVzZUpTKSB7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb19kZWNvZGVyLmpzXCIsIFwidGV4dFwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX3dhc21fd3JhcHBlci5qc1wiLCBcInRleHRcIikpO1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fZGVjb2Rlci53YXNtXCIsIFwiYXJyYXlidWZmZXJcIikpO1xuICAgIH1cbiAgICB0aGlzLmRlY29kZXJQZW5kaW5nID0gUHJvbWlzZS5hbGwobGlicmFyaWVzUGVuZGluZykudGhlbigobGlicmFyaWVzKSA9PiB7XG4gICAgICBjb25zdCBqc0NvbnRlbnQgPSBsaWJyYXJpZXNbMF07XG4gICAgICBpZiAoIXVzZUpTKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlckNvbmZpZy53YXNtQmluYXJ5ID0gbGlicmFyaWVzWzFdO1xuICAgICAgfVxuICAgICAgY29uc3QgZm4gPSBEUkFDT1dvcmtlci50b1N0cmluZygpO1xuICAgICAgY29uc3QgYm9keSA9IFtcbiAgICAgICAgXCIvKiBkcmFjbyBkZWNvZGVyICovXCIsXG4gICAgICAgIGpzQ29udGVudCxcbiAgICAgICAgXCJcIixcbiAgICAgICAgXCIvKiB3b3JrZXIgKi9cIixcbiAgICAgICAgZm4uc3Vic3RyaW5nKGZuLmluZGV4T2YoXCJ7XCIpICsgMSwgZm4ubGFzdEluZGV4T2YoXCJ9XCIpKVxuICAgICAgXS5qb2luKFwiXFxuXCIpO1xuICAgICAgdGhpcy53b3JrZXJTb3VyY2VVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtib2R5XSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRlY29kZXJQZW5kaW5nO1xuICB9XG4gIF9nZXRXb3JrZXIodGFza0lELCB0YXNrQ29zdCkge1xuICAgIHJldHVybiB0aGlzLl9pbml0RGVjb2RlcigpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHRoaXMud29ya2VyUG9vbC5sZW5ndGggPCB0aGlzLndvcmtlckxpbWl0KSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcjIgPSBuZXcgV29ya2VyKHRoaXMud29ya2VyU291cmNlVVJMKTtcbiAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzID0ge307XG4gICAgICAgIHdvcmtlcjIuX3Rhc2tDb3N0cyA9IHt9O1xuICAgICAgICB3b3JrZXIyLl90YXNrTG9hZCA9IDA7XG4gICAgICAgIHdvcmtlcjIucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImluaXRcIiwgZGVjb2RlckNvbmZpZzogdGhpcy5kZWNvZGVyQ29uZmlnIH0pO1xuICAgICAgICB3b3JrZXIyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZS5kYXRhO1xuICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGVjb2RlXCI6XG4gICAgICAgICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrc1ttZXNzYWdlLmlkXS5yZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3NbbWVzc2FnZS5pZF0ucmVqZWN0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkRSQUNPTG9hZGVyOiBVbmV4cGVjdGVkIG1lc3NhZ2UsIFwiJyArIG1lc3NhZ2UudHlwZSArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53b3JrZXJQb29sLnB1c2god29ya2VyMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmtlclBvb2wuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuX3Rhc2tMb2FkID4gYi5fdGFza0xvYWQgPyAtMSA6IDE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgd29ya2VyID0gdGhpcy53b3JrZXJQb29sW3RoaXMud29ya2VyUG9vbC5sZW5ndGggLSAxXTtcbiAgICAgIHdvcmtlci5fdGFza0Nvc3RzW3Rhc2tJRF0gPSB0YXNrQ29zdDtcbiAgICAgIHdvcmtlci5fdGFza0xvYWQgKz0gdGFza0Nvc3Q7XG4gICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0pO1xuICB9XG4gIF9yZWxlYXNlVGFzayh3b3JrZXIsIHRhc2tJRCkge1xuICAgIHdvcmtlci5fdGFza0xvYWQgLT0gd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXTtcbiAgICBkZWxldGUgd29ya2VyLl9jYWxsYmFja3NbdGFza0lEXTtcbiAgICBkZWxldGUgd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXTtcbiAgfVxuICBkZWJ1ZygpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwiVGFzayBsb2FkOiBcIixcbiAgICAgIHRoaXMud29ya2VyUG9vbC5tYXAoKHdvcmtlcikgPT4gd29ya2VyLl90YXNrTG9hZClcbiAgICApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndvcmtlclBvb2wubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMud29ya2VyUG9vbFtpXS50ZXJtaW5hdGUoKTtcbiAgICB9XG4gICAgdGhpcy53b3JrZXJQb29sLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIERSQUNPV29ya2VyKCkge1xuICBsZXQgZGVjb2RlckNvbmZpZztcbiAgbGV0IGRlY29kZXJQZW5kaW5nO1xuICBvbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGUuZGF0YTtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgY2FzZSBcImluaXRcIjpcbiAgICAgICAgZGVjb2RlckNvbmZpZyA9IG1lc3NhZ2UuZGVjb2RlckNvbmZpZztcbiAgICAgICAgZGVjb2RlclBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgZGVjb2RlckNvbmZpZy5vbk1vZHVsZUxvYWRlZCA9IGZ1bmN0aW9uKGRyYWNvKSB7XG4gICAgICAgICAgICByZXNvbHZlKHsgZHJhY28gfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBEcmFjb0RlY29kZXJNb2R1bGUoZGVjb2RlckNvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZWNvZGVcIjpcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbWVzc2FnZS5idWZmZXI7XG4gICAgICAgIGNvbnN0IHRhc2tDb25maWcgPSBtZXNzYWdlLnRhc2tDb25maWc7XG4gICAgICAgIGRlY29kZXJQZW5kaW5nLnRoZW4oKG1vZHVsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRyYWNvID0gbW9kdWxlLmRyYWNvO1xuICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgZHJhY28uRGVjb2RlcigpO1xuICAgICAgICAgIGNvbnN0IGRlY29kZXJCdWZmZXIgPSBuZXcgZHJhY28uRGVjb2RlckJ1ZmZlcigpO1xuICAgICAgICAgIGRlY29kZXJCdWZmZXIuSW5pdChuZXcgSW50OEFycmF5KGJ1ZmZlciksIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBkZWNvZGVHZW9tZXRyeShkcmFjbywgZGVjb2RlciwgZGVjb2RlckJ1ZmZlciwgdGFza0NvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IGF0dHIuYXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS5pbmRleClcbiAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKGdlb21ldHJ5LmluZGV4LmFycmF5LmJ1ZmZlcik7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJkZWNvZGVcIiwgaWQ6IG1lc3NhZ2UuaWQsIGdlb21ldHJ5IH0sIGJ1ZmZlcnMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImVycm9yXCIsIGlkOiBtZXNzYWdlLmlkLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZHJhY28uZGVzdHJveShkZWNvZGVyQnVmZmVyKTtcbiAgICAgICAgICAgIGRyYWNvLmRlc3Ryb3koZGVjb2Rlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkZWNvZGVHZW9tZXRyeShkcmFjbywgZGVjb2RlciwgZGVjb2RlckJ1ZmZlciwgdGFza0NvbmZpZykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZUlEcyA9IHRhc2tDb25maWcuYXR0cmlidXRlSURzO1xuICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGVzID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlcztcbiAgICBsZXQgZHJhY29HZW9tZXRyeTtcbiAgICBsZXQgZGVjb2RpbmdTdGF0dXM7XG4gICAgY29uc3QgZ2VvbWV0cnlUeXBlID0gZGVjb2Rlci5HZXRFbmNvZGVkR2VvbWV0cnlUeXBlKGRlY29kZXJCdWZmZXIpO1xuICAgIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlRSSUFOR1VMQVJfTUVTSCkge1xuICAgICAgZHJhY29HZW9tZXRyeSA9IG5ldyBkcmFjby5NZXNoKCk7XG4gICAgICBkZWNvZGluZ1N0YXR1cyA9IGRlY29kZXIuRGVjb2RlQnVmZmVyVG9NZXNoKGRlY29kZXJCdWZmZXIsIGRyYWNvR2VvbWV0cnkpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09PSBkcmFjby5QT0lOVF9DTE9VRCkge1xuICAgICAgZHJhY29HZW9tZXRyeSA9IG5ldyBkcmFjby5Qb2ludENsb3VkKCk7XG4gICAgICBkZWNvZGluZ1N0YXR1cyA9IGRlY29kZXIuRGVjb2RlQnVmZmVyVG9Qb2ludENsb3VkKGRlY29kZXJCdWZmZXIsIGRyYWNvR2VvbWV0cnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5EUkFDT0xvYWRlcjogVW5leHBlY3RlZCBnZW9tZXRyeSB0eXBlLlwiKTtcbiAgICB9XG4gICAgaWYgKCFkZWNvZGluZ1N0YXR1cy5vaygpIHx8IGRyYWNvR2VvbWV0cnkucHRyID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5EUkFDT0xvYWRlcjogRGVjb2RpbmcgZmFpbGVkOiBcIiArIGRlY29kaW5nU3RhdHVzLmVycm9yX21zZygpKTtcbiAgICB9XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB7IGluZGV4OiBudWxsLCBhdHRyaWJ1dGVzOiBbXSB9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVJRHMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGUgPSBzZWxmW2F0dHJpYnV0ZVR5cGVzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICAgIGxldCBhdHRyaWJ1dGU7XG4gICAgICBsZXQgYXR0cmlidXRlSUQ7XG4gICAgICBpZiAodGFza0NvbmZpZy51c2VVbmlxdWVJRHMpIHtcbiAgICAgICAgYXR0cmlidXRlSUQgPSBhdHRyaWJ1dGVJRHNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIGF0dHJpYnV0ZSA9IGRlY29kZXIuR2V0QXR0cmlidXRlQnlVbmlxdWVJZChkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVJRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVJRCA9IGRlY29kZXIuR2V0QXR0cmlidXRlSWQoZHJhY29HZW9tZXRyeSwgZHJhY29bYXR0cmlidXRlSURzW2F0dHJpYnV0ZU5hbWVdXSk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVJRCA9PT0gLTEpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF0dHJpYnV0ZSA9IGRlY29kZXIuR2V0QXR0cmlidXRlKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlEKTtcbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucHVzaChkZWNvZGVBdHRyaWJ1dGUoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGF0dHJpYnV0ZSkpO1xuICAgIH1cbiAgICBpZiAoZ2VvbWV0cnlUeXBlID09PSBkcmFjby5UUklBTkdVTEFSX01FU0gpIHtcbiAgICAgIGdlb21ldHJ5LmluZGV4ID0gZGVjb2RlSW5kZXgoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnkpO1xuICAgIH1cbiAgICBkcmFjby5kZXN0cm95KGRyYWNvR2VvbWV0cnkpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVJbmRleChkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSkge1xuICAgIGNvbnN0IG51bUZhY2VzID0gZHJhY29HZW9tZXRyeS5udW1fZmFjZXMoKTtcbiAgICBjb25zdCBudW1JbmRpY2VzID0gbnVtRmFjZXMgKiAzO1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBudW1JbmRpY2VzICogNDtcbiAgICBjb25zdCBwdHIgPSBkcmFjby5fbWFsbG9jKGJ5dGVMZW5ndGgpO1xuICAgIGRlY29kZXIuR2V0VHJpYW5nbGVzVUludDMyQXJyYXkoZHJhY29HZW9tZXRyeSwgYnl0ZUxlbmd0aCwgcHRyKTtcbiAgICBjb25zdCBpbmRleCA9IG5ldyBVaW50MzJBcnJheShkcmFjby5IRUFQRjMyLmJ1ZmZlciwgcHRyLCBudW1JbmRpY2VzKS5zbGljZSgpO1xuICAgIGRyYWNvLl9mcmVlKHB0cik7XG4gICAgcmV0dXJuIHsgYXJyYXk6IGluZGV4LCBpdGVtU2l6ZTogMSB9O1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUF0dHJpYnV0ZShkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlKSB7XG4gICAgY29uc3QgbnVtQ29tcG9uZW50cyA9IGF0dHJpYnV0ZS5udW1fY29tcG9uZW50cygpO1xuICAgIGNvbnN0IG51bVBvaW50cyA9IGRyYWNvR2VvbWV0cnkubnVtX3BvaW50cygpO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IG51bVBvaW50cyAqIG51bUNvbXBvbmVudHM7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IG51bVZhbHVlcyAqIGF0dHJpYnV0ZVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBnZXREcmFjb0RhdGFUeXBlKGRyYWNvLCBhdHRyaWJ1dGVUeXBlKTtcbiAgICBjb25zdCBwdHIgPSBkcmFjby5fbWFsbG9jKGJ5dGVMZW5ndGgpO1xuICAgIGRlY29kZXIuR2V0QXR0cmlidXRlRGF0YUFycmF5Rm9yQWxsUG9pbnRzKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZSwgZGF0YVR5cGUsIGJ5dGVMZW5ndGgsIHB0cik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgYXR0cmlidXRlVHlwZShkcmFjby5IRUFQRjMyLmJ1ZmZlciwgcHRyLCBudW1WYWx1ZXMpLnNsaWNlKCk7XG4gICAgZHJhY28uX2ZyZWUocHRyKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogYXR0cmlidXRlTmFtZSxcbiAgICAgIGFycmF5LFxuICAgICAgaXRlbVNpemU6IG51bUNvbXBvbmVudHNcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldERyYWNvRGF0YVR5cGUoZHJhY28sIGF0dHJpYnV0ZVR5cGUpIHtcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZVR5cGUpIHtcbiAgICAgIGNhc2UgRmxvYXQzMkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfRkxPQVQzMjtcbiAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UODtcbiAgICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0lOVDE2O1xuICAgICAgY2FzZSBJbnQzMkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UMzI7XG4gICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UODtcbiAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UMTY7XG4gICAgICBjYXNlIFVpbnQzMkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfVUlOVDMyO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IHtcbiAgRFJBQ09Mb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EUkFDT0xvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJMb2FkZXIiLCJGaWxlTG9hZGVyIiwiQnVmZmVyR2VvbWV0cnkiLCJCdWZmZXJBdHRyaWJ1dGUiLCJfdGFza0NhY2hlIiwiV2Vha01hcCIsIkRSQUNPTG9hZGVyIiwiY29uc3RydWN0b3IiLCJtYW5hZ2VyIiwiZGVjb2RlclBhdGgiLCJkZWNvZGVyQ29uZmlnIiwiZGVjb2RlckJpbmFyeSIsImRlY29kZXJQZW5kaW5nIiwid29ya2VyTGltaXQiLCJ3b3JrZXJQb29sIiwid29ya2VyTmV4dFRhc2tJRCIsIndvcmtlclNvdXJjZVVSTCIsImRlZmF1bHRBdHRyaWJ1dGVJRHMiLCJwb3NpdGlvbiIsIm5vcm1hbCIsImNvbG9yIiwidXYiLCJkZWZhdWx0QXR0cmlidXRlVHlwZXMiLCJzZXREZWNvZGVyUGF0aCIsInBhdGgiLCJzZXREZWNvZGVyQ29uZmlnIiwiY29uZmlnIiwic2V0V29ya2VyTGltaXQiLCJsb2FkIiwidXJsIiwib25Mb2FkIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJsb2FkZXIiLCJzZXRQYXRoIiwic2V0UmVzcG9uc2VUeXBlIiwic2V0UmVxdWVzdEhlYWRlciIsInJlcXVlc3RIZWFkZXIiLCJzZXRXaXRoQ3JlZGVudGlhbHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJidWZmZXIiLCJ0YXNrQ29uZmlnIiwiYXR0cmlidXRlSURzIiwiYXR0cmlidXRlVHlwZXMiLCJ1c2VVbmlxdWVJRHMiLCJkZWNvZGVHZW9tZXRyeSIsInRoZW4iLCJjYXRjaCIsImRlY29kZURyYWNvRmlsZSIsImNhbGxiYWNrIiwiYXR0cmlidXRlIiwidHlwZSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwibmFtZSIsInRhc2tLZXkiLCJKU09OIiwic3RyaW5naWZ5IiwiaGFzIiwiY2FjaGVkVGFzayIsImdldCIsImtleSIsInByb21pc2UiLCJieXRlTGVuZ3RoIiwiRXJyb3IiLCJ3b3JrZXIiLCJ0YXNrSUQiLCJ0YXNrQ29zdCIsImdlb21ldHJ5UGVuZGluZyIsIl9nZXRXb3JrZXIiLCJfd29ya2VyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJfY2FsbGJhY2tzIiwicG9zdE1lc3NhZ2UiLCJpZCIsIm1lc3NhZ2UiLCJfY3JlYXRlR2VvbWV0cnkiLCJnZW9tZXRyeSIsIl9yZWxlYXNlVGFzayIsInNldCIsImdlb21ldHJ5RGF0YSIsImluZGV4Iiwic2V0SW5kZXgiLCJhcnJheSIsImkiLCJhdHRyaWJ1dGVzIiwibGVuZ3RoIiwiaXRlbVNpemUiLCJzZXRBdHRyaWJ1dGUiLCJfbG9hZExpYnJhcnkiLCJyZXNwb25zZVR5cGUiLCJwcmVsb2FkIiwiX2luaXREZWNvZGVyIiwidXNlSlMiLCJXZWJBc3NlbWJseSIsImxpYnJhcmllc1BlbmRpbmciLCJwdXNoIiwiYWxsIiwibGlicmFyaWVzIiwianNDb250ZW50Iiwid2FzbUJpbmFyeSIsImZuIiwiRFJBQ09Xb3JrZXIiLCJ0b1N0cmluZyIsImJvZHkiLCJzdWJzdHJpbmciLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJqb2luIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiQmxvYiIsIndvcmtlcjIiLCJXb3JrZXIiLCJfdGFza0Nvc3RzIiwiX3Rhc2tMb2FkIiwib25tZXNzYWdlIiwiZSIsImRhdGEiLCJjb25zb2xlIiwiZXJyb3IiLCJzb3J0IiwiYSIsImIiLCJkZWJ1ZyIsImxvZyIsIm1hcCIsImRpc3Bvc2UiLCJ0ZXJtaW5hdGUiLCJvbk1vZHVsZUxvYWRlZCIsImRyYWNvIiwiRHJhY29EZWNvZGVyTW9kdWxlIiwibW9kdWxlIiwiZGVjb2RlciIsIkRlY29kZXIiLCJkZWNvZGVyQnVmZmVyIiwiRGVjb2RlckJ1ZmZlciIsIkluaXQiLCJJbnQ4QXJyYXkiLCJidWZmZXJzIiwiYXR0ciIsInNlbGYiLCJkZXN0cm95IiwiZHJhY29HZW9tZXRyeSIsImRlY29kaW5nU3RhdHVzIiwiZ2VvbWV0cnlUeXBlIiwiR2V0RW5jb2RlZEdlb21ldHJ5VHlwZSIsIlRSSUFOR1VMQVJfTUVTSCIsIk1lc2giLCJEZWNvZGVCdWZmZXJUb01lc2giLCJQT0lOVF9DTE9VRCIsIlBvaW50Q2xvdWQiLCJEZWNvZGVCdWZmZXJUb1BvaW50Q2xvdWQiLCJvayIsInB0ciIsImVycm9yX21zZyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVUeXBlIiwiYXR0cmlidXRlSUQiLCJHZXRBdHRyaWJ1dGVCeVVuaXF1ZUlkIiwiR2V0QXR0cmlidXRlSWQiLCJHZXRBdHRyaWJ1dGUiLCJkZWNvZGVBdHRyaWJ1dGUiLCJkZWNvZGVJbmRleCIsIm51bUZhY2VzIiwibnVtX2ZhY2VzIiwibnVtSW5kaWNlcyIsIl9tYWxsb2MiLCJHZXRUcmlhbmdsZXNVSW50MzJBcnJheSIsIlVpbnQzMkFycmF5IiwiSEVBUEYzMiIsInNsaWNlIiwiX2ZyZWUiLCJudW1Db21wb25lbnRzIiwibnVtX2NvbXBvbmVudHMiLCJudW1Qb2ludHMiLCJudW1fcG9pbnRzIiwibnVtVmFsdWVzIiwiZGF0YVR5cGUiLCJnZXREcmFjb0RhdGFUeXBlIiwiR2V0QXR0cmlidXRlRGF0YUFycmF5Rm9yQWxsUG9pbnRzIiwiRmxvYXQzMkFycmF5IiwiRFRfRkxPQVQzMiIsIkRUX0lOVDgiLCJJbnQxNkFycmF5IiwiRFRfSU5UMTYiLCJJbnQzMkFycmF5IiwiRFRfSU5UMzIiLCJVaW50OEFycmF5IiwiRFRfVUlOVDgiLCJVaW50MTZBcnJheSIsIkRUX1VJTlQxNiIsIkRUX1VJTlQzMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/EXRLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXRLoader: () => (/* binding */ EXRLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fflate */ \"(ssr)/./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs\");\n\n\nconst hasColorSpace = \"colorSpace\" in new three__WEBPACK_IMPORTED_MODULE_0__.Texture();\nclass EXRLoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n    parse(buffer) {\n        const USHORT_RANGE = 1 << 16;\n        const BITMAP_SIZE = USHORT_RANGE >> 3;\n        const HUF_ENCBITS = 16;\n        const HUF_DECBITS = 14;\n        const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n        const HUF_DECSIZE = 1 << HUF_DECBITS;\n        const HUF_DECMASK = HUF_DECSIZE - 1;\n        const NBITS = 16;\n        const A_OFFSET = 1 << NBITS - 1;\n        const MOD_MASK = (1 << NBITS) - 1;\n        const SHORT_ZEROCODE_RUN = 59;\n        const LONG_ZEROCODE_RUN = 63;\n        const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n        const ULONG_SIZE = 8;\n        const FLOAT32_SIZE = 4;\n        const INT32_SIZE = 4;\n        const INT16_SIZE = 2;\n        const INT8_SIZE = 1;\n        const STATIC_HUFFMAN = 0;\n        const DEFLATE = 1;\n        const UNKNOWN = 0;\n        const LOSSY_DCT = 1;\n        const RLE = 2;\n        const logBase = Math.pow(2.7182818, 2.2);\n        function reverseLutFromBitmap(bitmap, lut) {\n            var k = 0;\n            for(var i = 0; i < USHORT_RANGE; ++i){\n                if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n                    lut[k++] = i;\n                }\n            }\n            var n = k - 1;\n            while(k < USHORT_RANGE)lut[k++] = 0;\n            return n;\n        }\n        function hufClearDecTable(hdec) {\n            for(var i = 0; i < HUF_DECSIZE; i++){\n                hdec[i] = {};\n                hdec[i].len = 0;\n                hdec[i].lit = 0;\n                hdec[i].p = null;\n            }\n        }\n        const getBitsReturn = {\n            l: 0,\n            c: 0,\n            lc: 0\n        };\n        function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n            while(lc < nBits){\n                c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n                lc += 8;\n            }\n            lc -= nBits;\n            getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n            getBitsReturn.c = c;\n            getBitsReturn.lc = lc;\n        }\n        const hufTableBuffer = new Array(59);\n        function hufCanonicalCodeTable(hcode) {\n            for(var i = 0; i <= 58; ++i)hufTableBuffer[i] = 0;\n            for(var i = 0; i < HUF_ENCSIZE; ++i)hufTableBuffer[hcode[i]] += 1;\n            var c = 0;\n            for(var i = 58; i > 0; --i){\n                var nc = c + hufTableBuffer[i] >> 1;\n                hufTableBuffer[i] = c;\n                c = nc;\n            }\n            for(var i = 0; i < HUF_ENCSIZE; ++i){\n                var l = hcode[i];\n                if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n            }\n        }\n        function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n            var p = inOffset;\n            var c = 0;\n            var lc = 0;\n            for(; im <= iM; im++){\n                if (p.value - inOffset.value > ni) return false;\n                getBits(6, c, lc, uInt8Array2, p);\n                var l = getBitsReturn.l;\n                c = getBitsReturn.c;\n                lc = getBitsReturn.lc;\n                hcode[im] = l;\n                if (l == LONG_ZEROCODE_RUN) {\n                    if (p.value - inOffset.value > ni) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    getBits(8, c, lc, uInt8Array2, p);\n                    var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n                    c = getBitsReturn.c;\n                    lc = getBitsReturn.lc;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                } else if (l >= SHORT_ZEROCODE_RUN) {\n                    var zerun = l - SHORT_ZEROCODE_RUN + 2;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                }\n            }\n            hufCanonicalCodeTable(hcode);\n        }\n        function hufLength(code) {\n            return code & 63;\n        }\n        function hufCode(code) {\n            return code >> 6;\n        }\n        function hufBuildDecTable(hcode, im, iM, hdecod) {\n            for(; im <= iM; im++){\n                var c = hufCode(hcode[im]);\n                var l = hufLength(hcode[im]);\n                if (c >> l) {\n                    throw \"Invalid table entry\";\n                }\n                if (l > HUF_DECBITS) {\n                    var pl = hdecod[c >> l - HUF_DECBITS];\n                    if (pl.len) {\n                        throw \"Invalid table entry\";\n                    }\n                    pl.lit++;\n                    if (pl.p) {\n                        var p = pl.p;\n                        pl.p = new Array(pl.lit);\n                        for(var i = 0; i < pl.lit - 1; ++i){\n                            pl.p[i] = p[i];\n                        }\n                    } else {\n                        pl.p = new Array(1);\n                    }\n                    pl.p[pl.lit - 1] = im;\n                } else if (l) {\n                    var plOffset = 0;\n                    for(var i = 1 << HUF_DECBITS - l; i > 0; i--){\n                        var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n                        if (pl.len || pl.p) {\n                            throw \"Invalid table entry\";\n                        }\n                        pl.len = l;\n                        pl.lit = im;\n                        plOffset++;\n                    }\n                }\n            }\n            return true;\n        }\n        const getCharReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getChar(c, lc, uInt8Array2, inOffset) {\n            c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n            lc += 8;\n            getCharReturn.c = c;\n            getCharReturn.lc = lc;\n        }\n        const getCodeReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n            if (po == rlc) {\n                if (lc < 8) {\n                    getChar(c, lc, uInt8Array2, inOffset);\n                    c = getCharReturn.c;\n                    lc = getCharReturn.lc;\n                }\n                lc -= 8;\n                var cs = c >> lc;\n                var cs = new Uint8Array([\n                    cs\n                ])[0];\n                if (outBufferOffset.value + cs > outBufferEndOffset) {\n                    return false;\n                }\n                var s = outBuffer[outBufferOffset.value - 1];\n                while(cs-- > 0){\n                    outBuffer[outBufferOffset.value++] = s;\n                }\n            } else if (outBufferOffset.value < outBufferEndOffset) {\n                outBuffer[outBufferOffset.value++] = po;\n            } else {\n                return false;\n            }\n            getCodeReturn.c = c;\n            getCodeReturn.lc = lc;\n        }\n        function UInt16(value) {\n            return value & 65535;\n        }\n        function Int16(value) {\n            var ref = UInt16(value);\n            return ref > 32767 ? ref - 65536 : ref;\n        }\n        const wdec14Return = {\n            a: 0,\n            b: 0\n        };\n        function wdec14(l, h) {\n            var ls = Int16(l);\n            var hs = Int16(h);\n            var hi = hs;\n            var ai = ls + (hi & 1) + (hi >> 1);\n            var as = ai;\n            var bs = ai - hi;\n            wdec14Return.a = as;\n            wdec14Return.b = bs;\n        }\n        function wdec16(l, h) {\n            var m = UInt16(l);\n            var d = UInt16(h);\n            var bb = m - (d >> 1) & MOD_MASK;\n            var aa = d + bb - A_OFFSET & MOD_MASK;\n            wdec14Return.a = aa;\n            wdec14Return.b = bb;\n        }\n        function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n            var w14 = mx < 1 << 14;\n            var n = nx > ny ? ny : nx;\n            var p = 1;\n            var p2;\n            while(p <= n)p <<= 1;\n            p >>= 1;\n            p2 = p;\n            p >>= 1;\n            while(p >= 1){\n                var py = 0;\n                var ey = py + oy * (ny - p2);\n                var oy1 = oy * p;\n                var oy2 = oy * p2;\n                var ox1 = ox * p;\n                var ox2 = ox * p2;\n                var i00, i01, i10, i11;\n                for(; py <= ey; py += oy2){\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        var p10 = px + oy1;\n                        var p11 = p10 + ox1;\n                        if (w14) {\n                            wdec14(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec14(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec14(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        } else {\n                            wdec16(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec16(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec16(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        }\n                    }\n                    if (nx & p) {\n                        var p10 = px + oy1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p10 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p10 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                if (ny & p) {\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p01 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p01 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                p2 = p;\n                p >>= 1;\n            }\n            return py;\n        }\n        function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n            var c = 0;\n            var lc = 0;\n            var outBufferEndOffset = no;\n            var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n            while(inOffset.value < inOffsetEnd){\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n                while(lc >= HUF_DECBITS){\n                    var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n                    var pl = decodingTable[index];\n                    if (pl.len) {\n                        lc -= pl.len;\n                        getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                        c = getCodeReturn.c;\n                        lc = getCodeReturn.lc;\n                    } else {\n                        if (!pl.p) {\n                            throw \"hufDecode issues\";\n                        }\n                        var j;\n                        for(j = 0; j < pl.lit; j++){\n                            var l = hufLength(encodingTable[pl.p[j]]);\n                            while(lc < l && inOffset.value < inOffsetEnd){\n                                getChar(c, lc, uInt8Array2, inOffset);\n                                c = getCharReturn.c;\n                                lc = getCharReturn.lc;\n                            }\n                            if (lc >= l) {\n                                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                                    lc -= l;\n                                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                                    c = getCodeReturn.c;\n                                    lc = getCodeReturn.lc;\n                                    break;\n                                }\n                            }\n                        }\n                        if (j == pl.lit) {\n                            throw \"hufDecode issues\";\n                        }\n                    }\n                }\n            }\n            var i = 8 - ni & 7;\n            c >>= i;\n            lc -= i;\n            while(lc > 0){\n                var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n                if (pl.len) {\n                    lc -= pl.len;\n                    getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                } else {\n                    throw \"hufDecode issues\";\n                }\n            }\n            return true;\n        }\n        function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n            var outOffset = {\n                value: 0\n            };\n            var initialInOffset = inOffset.value;\n            var im = parseUint32(inDataView, inOffset);\n            var iM = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            var nBits = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n                throw \"Something wrong with HUF_ENCSIZE\";\n            }\n            var freq = new Array(HUF_ENCSIZE);\n            var hdec = new Array(HUF_DECSIZE);\n            hufClearDecTable(hdec);\n            var ni = nCompressed - (inOffset.value - initialInOffset);\n            hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n            if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n                throw \"Something wrong with hufUncompress\";\n            }\n            hufBuildDecTable(freq, im, iM, hdec);\n            hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n        }\n        function applyLut(lut, data, nData) {\n            for(var i = 0; i < nData; ++i){\n                data[i] = lut[data[i]];\n            }\n        }\n        function predictor(source) {\n            for(var t = 1; t < source.length; t++){\n                var d = source[t - 1] + source[t] - 128;\n                source[t] = d;\n            }\n        }\n        function interleaveScalar(source, out) {\n            var t1 = 0;\n            var t2 = Math.floor((source.length + 1) / 2);\n            var s = 0;\n            var stop = source.length - 1;\n            while(true){\n                if (s > stop) break;\n                out[s++] = source[t1++];\n                if (s > stop) break;\n                out[s++] = source[t2++];\n            }\n        }\n        function decodeRunLength(source) {\n            var size = source.byteLength;\n            var out = new Array();\n            var p = 0;\n            var reader = new DataView(source);\n            while(size > 0){\n                var l = reader.getInt8(p++);\n                if (l < 0) {\n                    var count = -l;\n                    size -= count + 1;\n                    for(var i = 0; i < count; i++){\n                        out.push(reader.getUint8(p++));\n                    }\n                } else {\n                    var count = l;\n                    size -= 2;\n                    var value = reader.getUint8(p++);\n                    for(var i = 0; i < count + 1; i++){\n                        out.push(value);\n                    }\n                }\n            }\n            return out;\n        }\n        function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n            var dataView = new DataView(outBuffer.buffer);\n            var width = channelData[cscSet.idx[0]].width;\n            var height = channelData[cscSet.idx[0]].height;\n            var numComp = 3;\n            var numFullBlocksX = Math.floor(width / 8);\n            var numBlocksX = Math.ceil(width / 8);\n            var numBlocksY = Math.ceil(height / 8);\n            var leftoverX = width - (numBlocksX - 1) * 8;\n            var leftoverY = height - (numBlocksY - 1) * 8;\n            var currAcComp = {\n                value: 0\n            };\n            var currDcComp = new Array(numComp);\n            var dctData = new Array(numComp);\n            var halfZigBlock = new Array(numComp);\n            var rowBlock = new Array(numComp);\n            var rowOffsets = new Array(numComp);\n            for(let comp2 = 0; comp2 < numComp; ++comp2){\n                rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n                currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n                dctData[comp2] = new Float32Array(64);\n                halfZigBlock[comp2] = new Uint16Array(64);\n                rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n            }\n            for(let blocky = 0; blocky < numBlocksY; ++blocky){\n                var maxY = 8;\n                if (blocky == numBlocksY - 1) maxY = leftoverY;\n                var maxX = 8;\n                for(let blockx = 0; blockx < numBlocksX; ++blockx){\n                    if (blockx == numBlocksX - 1) maxX = leftoverX;\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        halfZigBlock[comp2].fill(0);\n                        halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n                        unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n                        unZigZag(halfZigBlock[comp2], dctData[comp2]);\n                        dctInverse(dctData[comp2]);\n                    }\n                    {\n                        csc709Inverse(dctData);\n                    }\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n                    }\n                }\n                let offset2 = 0;\n                for(let comp2 = 0; comp2 < numComp; ++comp2){\n                    const type2 = channelData[cscSet.idx[comp2]].type;\n                    for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                        offset2 = rowOffsets[comp2][y2];\n                        for(let blockx = 0; blockx < numFullBlocksX; ++blockx){\n                            const src = blockx * 64 + (y2 & 7) * 8;\n                            dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n                            dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n                            dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n                            dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n                            dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n                            dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n                            dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n                            dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n                            offset2 += 8 * INT16_SIZE * type2;\n                        }\n                    }\n                    if (numFullBlocksX != numBlocksX) {\n                        for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                            const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n                            const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n                            for(let x2 = 0; x2 < maxX; ++x2){\n                                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n                            }\n                        }\n                    }\n                }\n            }\n            var halfRow = new Uint16Array(width);\n            var dataView = new DataView(outBuffer.buffer);\n            for(var comp = 0; comp < numComp; ++comp){\n                channelData[cscSet.idx[comp]].decoded = true;\n                var type = channelData[cscSet.idx[comp]].type;\n                if (channelData[comp].type != 2) continue;\n                for(var y = 0; y < height; ++y){\n                    const offset2 = rowOffsets[comp][y];\n                    for(var x = 0; x < width; ++x){\n                        halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n                    }\n                    for(var x = 0; x < width; ++x){\n                        dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n                    }\n                }\n            }\n        }\n        function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n            var acValue;\n            var dctComp = 1;\n            while(dctComp < 64){\n                acValue = acBuffer[currAcComp.value];\n                if (acValue == 65280) {\n                    dctComp = 64;\n                } else if (acValue >> 8 == 255) {\n                    dctComp += acValue & 255;\n                } else {\n                    halfZigBlock[dctComp] = acValue;\n                    dctComp++;\n                }\n                currAcComp.value++;\n            }\n        }\n        function unZigZag(src, dst) {\n            dst[0] = decodeFloat16(src[0]);\n            dst[1] = decodeFloat16(src[1]);\n            dst[2] = decodeFloat16(src[5]);\n            dst[3] = decodeFloat16(src[6]);\n            dst[4] = decodeFloat16(src[14]);\n            dst[5] = decodeFloat16(src[15]);\n            dst[6] = decodeFloat16(src[27]);\n            dst[7] = decodeFloat16(src[28]);\n            dst[8] = decodeFloat16(src[2]);\n            dst[9] = decodeFloat16(src[4]);\n            dst[10] = decodeFloat16(src[7]);\n            dst[11] = decodeFloat16(src[13]);\n            dst[12] = decodeFloat16(src[16]);\n            dst[13] = decodeFloat16(src[26]);\n            dst[14] = decodeFloat16(src[29]);\n            dst[15] = decodeFloat16(src[42]);\n            dst[16] = decodeFloat16(src[3]);\n            dst[17] = decodeFloat16(src[8]);\n            dst[18] = decodeFloat16(src[12]);\n            dst[19] = decodeFloat16(src[17]);\n            dst[20] = decodeFloat16(src[25]);\n            dst[21] = decodeFloat16(src[30]);\n            dst[22] = decodeFloat16(src[41]);\n            dst[23] = decodeFloat16(src[43]);\n            dst[24] = decodeFloat16(src[9]);\n            dst[25] = decodeFloat16(src[11]);\n            dst[26] = decodeFloat16(src[18]);\n            dst[27] = decodeFloat16(src[24]);\n            dst[28] = decodeFloat16(src[31]);\n            dst[29] = decodeFloat16(src[40]);\n            dst[30] = decodeFloat16(src[44]);\n            dst[31] = decodeFloat16(src[53]);\n            dst[32] = decodeFloat16(src[10]);\n            dst[33] = decodeFloat16(src[19]);\n            dst[34] = decodeFloat16(src[23]);\n            dst[35] = decodeFloat16(src[32]);\n            dst[36] = decodeFloat16(src[39]);\n            dst[37] = decodeFloat16(src[45]);\n            dst[38] = decodeFloat16(src[52]);\n            dst[39] = decodeFloat16(src[54]);\n            dst[40] = decodeFloat16(src[20]);\n            dst[41] = decodeFloat16(src[22]);\n            dst[42] = decodeFloat16(src[33]);\n            dst[43] = decodeFloat16(src[38]);\n            dst[44] = decodeFloat16(src[46]);\n            dst[45] = decodeFloat16(src[51]);\n            dst[46] = decodeFloat16(src[55]);\n            dst[47] = decodeFloat16(src[60]);\n            dst[48] = decodeFloat16(src[21]);\n            dst[49] = decodeFloat16(src[34]);\n            dst[50] = decodeFloat16(src[37]);\n            dst[51] = decodeFloat16(src[47]);\n            dst[52] = decodeFloat16(src[50]);\n            dst[53] = decodeFloat16(src[56]);\n            dst[54] = decodeFloat16(src[59]);\n            dst[55] = decodeFloat16(src[61]);\n            dst[56] = decodeFloat16(src[35]);\n            dst[57] = decodeFloat16(src[36]);\n            dst[58] = decodeFloat16(src[48]);\n            dst[59] = decodeFloat16(src[49]);\n            dst[60] = decodeFloat16(src[57]);\n            dst[61] = decodeFloat16(src[58]);\n            dst[62] = decodeFloat16(src[62]);\n            dst[63] = decodeFloat16(src[63]);\n        }\n        function dctInverse(data) {\n            const a = 0.5 * Math.cos(3.14159 / 4);\n            const b = 0.5 * Math.cos(3.14159 / 16);\n            const c = 0.5 * Math.cos(3.14159 / 8);\n            const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n            const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n            const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n            const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n            var alpha = new Array(4);\n            var beta = new Array(4);\n            var theta = new Array(4);\n            var gamma = new Array(4);\n            for(var row = 0; row < 8; ++row){\n                var rowPtr = row * 8;\n                alpha[0] = c * data[rowPtr + 2];\n                alpha[1] = f * data[rowPtr + 2];\n                alpha[2] = c * data[rowPtr + 6];\n                alpha[3] = f * data[rowPtr + 6];\n                beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n                beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n                beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n                beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n                theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n                theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[rowPtr + 0] = gamma[0] + beta[0];\n                data[rowPtr + 1] = gamma[1] + beta[1];\n                data[rowPtr + 2] = gamma[2] + beta[2];\n                data[rowPtr + 3] = gamma[3] + beta[3];\n                data[rowPtr + 4] = gamma[3] - beta[3];\n                data[rowPtr + 5] = gamma[2] - beta[2];\n                data[rowPtr + 6] = gamma[1] - beta[1];\n                data[rowPtr + 7] = gamma[0] - beta[0];\n            }\n            for(var column = 0; column < 8; ++column){\n                alpha[0] = c * data[16 + column];\n                alpha[1] = f * data[16 + column];\n                alpha[2] = c * data[48 + column];\n                alpha[3] = f * data[48 + column];\n                beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n                beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n                beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n                beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n                theta[0] = a * (data[column] + data[32 + column]);\n                theta[3] = a * (data[column] - data[32 + column]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[0 + column] = gamma[0] + beta[0];\n                data[8 + column] = gamma[1] + beta[1];\n                data[16 + column] = gamma[2] + beta[2];\n                data[24 + column] = gamma[3] + beta[3];\n                data[32 + column] = gamma[3] - beta[3];\n                data[40 + column] = gamma[2] - beta[2];\n                data[48 + column] = gamma[1] - beta[1];\n                data[56 + column] = gamma[0] - beta[0];\n            }\n        }\n        function csc709Inverse(data) {\n            for(var i = 0; i < 64; ++i){\n                var y = data[0][i];\n                var cb = data[1][i];\n                var cr = data[2][i];\n                data[0][i] = y + 1.5747 * cr;\n                data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n                data[2][i] = y + 1.8556 * cb;\n            }\n        }\n        function convertToHalf(src, dst, idx) {\n            for(var i = 0; i < 64; ++i){\n                dst[idx + i] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(toLinear(src[i]));\n            }\n        }\n        function toLinear(float) {\n            if (float <= 1) {\n                return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n            } else {\n                return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n            }\n        }\n        function uncompressRAW(info) {\n            return new DataView(info.array.buffer, info.offset.value, info.size);\n        }\n        function uncompressRLE(info) {\n            var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressZIP(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPIZ(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n            var bitmap = new Uint8Array(BITMAP_SIZE);\n            var outBufferEnd = 0;\n            var pizChannelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; i++){\n                pizChannelData[i] = {};\n                pizChannelData[i][\"start\"] = outBufferEnd;\n                pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n                pizChannelData[i][\"nx\"] = info.width;\n                pizChannelData[i][\"ny\"] = info.lines;\n                pizChannelData[i][\"size\"] = info.type;\n                outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n            }\n            var minNonZero = parseUint16(inDataView, inOffset);\n            var maxNonZero = parseUint16(inDataView, inOffset);\n            if (maxNonZero >= BITMAP_SIZE) {\n                throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n            }\n            if (minNonZero <= maxNonZero) {\n                for(var i = 0; i < maxNonZero - minNonZero + 1; i++){\n                    bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n                }\n            }\n            var lut = new Uint16Array(USHORT_RANGE);\n            var maxValue = reverseLutFromBitmap(bitmap, lut);\n            var length = parseUint32(inDataView, inOffset);\n            hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = pizChannelData[i];\n                for(var j = 0; j < pizChannelData[i].size; ++j){\n                    wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n                }\n            }\n            applyLut(lut, outBuffer, outBufferEnd);\n            var tmpOffset2 = 0;\n            var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n            for(var y = 0; y < info.lines; y++){\n                for(var c = 0; c < info.channels; c++){\n                    var cd = pizChannelData[c];\n                    var n = cd.nx * cd.size;\n                    var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n                    tmpBuffer.set(cp, tmpOffset2);\n                    tmpOffset2 += n * INT16_SIZE;\n                    cd.end += n;\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPXR(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n            const sz = info.lines * info.channels * info.width;\n            const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n            let tmpBufferEnd = 0;\n            let writePtr = 0;\n            const ptr = new Array(4);\n            for(let y = 0; y < info.lines; y++){\n                for(let c = 0; c < info.channels; c++){\n                    let pixel = 0;\n                    switch(info.type){\n                        case 1:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            tmpBufferEnd = ptr[1] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                        case 2:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            ptr[2] = ptr[1] + info.width;\n                            tmpBufferEnd = ptr[2] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                    }\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressDWA(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n            var dwaHeader = {\n                version: parseInt64(inDataView, inOffset),\n                unknownUncompressedSize: parseInt64(inDataView, inOffset),\n                unknownCompressedSize: parseInt64(inDataView, inOffset),\n                acCompressedSize: parseInt64(inDataView, inOffset),\n                dcCompressedSize: parseInt64(inDataView, inOffset),\n                rleCompressedSize: parseInt64(inDataView, inOffset),\n                rleUncompressedSize: parseInt64(inDataView, inOffset),\n                rleRawSize: parseInt64(inDataView, inOffset),\n                totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n                totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n                acCompression: parseInt64(inDataView, inOffset)\n            };\n            if (dwaHeader.version < 2) {\n                throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n            }\n            var channelRules = new Array();\n            var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n            while(ruleSize > 0){\n                var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n                var value = parseUint8(inDataView, inOffset);\n                var compression = value >> 2 & 3;\n                var csc = (value >> 4) - 1;\n                var index = new Int8Array([\n                    csc\n                ])[0];\n                var type = parseUint8(inDataView, inOffset);\n                channelRules.push({\n                    name,\n                    index,\n                    type,\n                    compression\n                });\n                ruleSize -= name.length + 3;\n            }\n            var channels = EXRHeader.channels;\n            var channelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = channelData[i] = {};\n                var channel = channels[i];\n                cd.name = channel.name;\n                cd.compression = UNKNOWN;\n                cd.decoded = false;\n                cd.type = channel.pixelType;\n                cd.pLinear = channel.pLinear;\n                cd.width = info.width;\n                cd.height = info.lines;\n            }\n            var cscSet = {\n                idx: new Array(3)\n            };\n            for(var offset2 = 0; offset2 < info.channels; ++offset2){\n                var cd = channelData[offset2];\n                for(var i = 0; i < channelRules.length; ++i){\n                    var rule = channelRules[i];\n                    if (cd.name == rule.name) {\n                        cd.compression = rule.compression;\n                        if (rule.index >= 0) {\n                            cscSet.idx[rule.index] = offset2;\n                        }\n                        cd.offset = offset2;\n                    }\n                }\n            }\n            if (dwaHeader.acCompressedSize > 0) {\n                switch(dwaHeader.acCompression){\n                    case STATIC_HUFFMAN:\n                        var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n                        hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n                        break;\n                    case DEFLATE:\n                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n                        var data = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n                        var acBuffer = new Uint16Array(data.buffer);\n                        inOffset.value += dwaHeader.totalAcUncompressedCount;\n                        break;\n                }\n            }\n            if (dwaHeader.dcCompressedSize > 0) {\n                var zlibInfo = {\n                    array: info.array,\n                    offset: inOffset,\n                    size: dwaHeader.dcCompressedSize\n                };\n                var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n                inOffset.value += dwaHeader.dcCompressedSize;\n            }\n            if (dwaHeader.rleRawSize > 0) {\n                var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n                var data = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n                var rleBuffer = decodeRunLength(data.buffer);\n                inOffset.value += dwaHeader.rleCompressedSize;\n            }\n            var outBufferEnd = 0;\n            var rowOffsets = new Array(channelData.length);\n            for(var i = 0; i < rowOffsets.length; ++i){\n                rowOffsets[i] = new Array();\n            }\n            for(var y = 0; y < info.lines; ++y){\n                for(var chan = 0; chan < channelData.length; ++chan){\n                    rowOffsets[chan].push(outBufferEnd);\n                    outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n                }\n            }\n            lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n            for(var i = 0; i < channelData.length; ++i){\n                var cd = channelData[i];\n                if (cd.decoded) continue;\n                switch(cd.compression){\n                    case RLE:\n                        var row = 0;\n                        var rleOffset = 0;\n                        for(var y = 0; y < info.lines; ++y){\n                            var rowOffsetBytes = rowOffsets[i][row];\n                            for(var x = 0; x < cd.width; ++x){\n                                for(var byte = 0; byte < INT16_SIZE * cd.type; ++byte){\n                                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                                }\n                                rleOffset++;\n                            }\n                            row++;\n                        }\n                        break;\n                    case LOSSY_DCT:\n                    default:\n                        throw \"EXRLoader.parse: unsupported channel compression\";\n                }\n            }\n            return new DataView(outBuffer.buffer);\n        }\n        function parseNullTerminatedString(buffer2, offset2) {\n            var uintBuffer = new Uint8Array(buffer2);\n            var endOffset = 0;\n            while(uintBuffer[offset2.value + endOffset] != 0){\n                endOffset += 1;\n            }\n            var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n            offset2.value = offset2.value + endOffset + 1;\n            return stringValue;\n        }\n        function parseFixedLengthString(buffer2, offset2, size) {\n            var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n            offset2.value = offset2.value + size;\n            return stringValue;\n        }\n        function parseRational(dataView, offset2) {\n            var x = parseInt32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseTimecode(dataView, offset2) {\n            var x = parseUint32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseInt32(dataView, offset2) {\n            var Int32 = dataView.getInt32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Int32;\n        }\n        function parseUint32(dataView, offset2) {\n            var Uint32 = dataView.getUint32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Uint32;\n        }\n        function parseUint8Array(uInt8Array2, offset2) {\n            var Uint8 = uInt8Array2[offset2.value];\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        function parseUint8(dataView, offset2) {\n            var Uint8 = dataView.getUint8(offset2.value);\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        const parseInt64 = function(dataView, offset2) {\n            let int;\n            if (\"getBigInt64\" in DataView.prototype) {\n                int = Number(dataView.getBigInt64(offset2.value, true));\n            } else {\n                int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n            }\n            offset2.value += ULONG_SIZE;\n            return int;\n        };\n        function parseFloat32(dataView, offset2) {\n            var float = dataView.getFloat32(offset2.value, true);\n            offset2.value += FLOAT32_SIZE;\n            return float;\n        }\n        function decodeFloat32(dataView, offset2) {\n            return three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n        }\n        function decodeFloat16(binary) {\n            var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n            return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n        }\n        function parseUint16(dataView, offset2) {\n            var Uint16 = dataView.getUint16(offset2.value, true);\n            offset2.value += INT16_SIZE;\n            return Uint16;\n        }\n        function parseFloat16(buffer2, offset2) {\n            return decodeFloat16(parseUint16(buffer2, offset2));\n        }\n        function parseChlist(dataView, buffer2, offset2, size) {\n            var startOffset = offset2.value;\n            var channels = [];\n            while(offset2.value < startOffset + size - 1){\n                var name = parseNullTerminatedString(buffer2, offset2);\n                var pixelType = parseInt32(dataView, offset2);\n                var pLinear = parseUint8(dataView, offset2);\n                offset2.value += 3;\n                var xSampling = parseInt32(dataView, offset2);\n                var ySampling = parseInt32(dataView, offset2);\n                channels.push({\n                    name,\n                    pixelType,\n                    pLinear,\n                    xSampling,\n                    ySampling\n                });\n            }\n            offset2.value += 1;\n            return channels;\n        }\n        function parseChromaticities(dataView, offset2) {\n            var redX = parseFloat32(dataView, offset2);\n            var redY = parseFloat32(dataView, offset2);\n            var greenX = parseFloat32(dataView, offset2);\n            var greenY = parseFloat32(dataView, offset2);\n            var blueX = parseFloat32(dataView, offset2);\n            var blueY = parseFloat32(dataView, offset2);\n            var whiteX = parseFloat32(dataView, offset2);\n            var whiteY = parseFloat32(dataView, offset2);\n            return {\n                redX,\n                redY,\n                greenX,\n                greenY,\n                blueX,\n                blueY,\n                whiteX,\n                whiteY\n            };\n        }\n        function parseCompression(dataView, offset2) {\n            var compressionCodes = [\n                \"NO_COMPRESSION\",\n                \"RLE_COMPRESSION\",\n                \"ZIPS_COMPRESSION\",\n                \"ZIP_COMPRESSION\",\n                \"PIZ_COMPRESSION\",\n                \"PXR24_COMPRESSION\",\n                \"B44_COMPRESSION\",\n                \"B44A_COMPRESSION\",\n                \"DWAA_COMPRESSION\",\n                \"DWAB_COMPRESSION\"\n            ];\n            var compression = parseUint8(dataView, offset2);\n            return compressionCodes[compression];\n        }\n        function parseBox2i(dataView, offset2) {\n            var xMin = parseUint32(dataView, offset2);\n            var yMin = parseUint32(dataView, offset2);\n            var xMax = parseUint32(dataView, offset2);\n            var yMax = parseUint32(dataView, offset2);\n            return {\n                xMin,\n                yMin,\n                xMax,\n                yMax\n            };\n        }\n        function parseLineOrder(dataView, offset2) {\n            var lineOrders = [\n                \"INCREASING_Y\"\n            ];\n            var lineOrder = parseUint8(dataView, offset2);\n            return lineOrders[lineOrder];\n        }\n        function parseV2f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseV3f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            var z = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y,\n                z\n            ];\n        }\n        function parseValue(dataView, buffer2, offset2, type, size) {\n            if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n                return parseFixedLengthString(buffer2, offset2, size);\n            } else if (type === \"chlist\") {\n                return parseChlist(dataView, buffer2, offset2, size);\n            } else if (type === \"chromaticities\") {\n                return parseChromaticities(dataView, offset2);\n            } else if (type === \"compression\") {\n                return parseCompression(dataView, offset2);\n            } else if (type === \"box2i\") {\n                return parseBox2i(dataView, offset2);\n            } else if (type === \"lineOrder\") {\n                return parseLineOrder(dataView, offset2);\n            } else if (type === \"float\") {\n                return parseFloat32(dataView, offset2);\n            } else if (type === \"v2f\") {\n                return parseV2f(dataView, offset2);\n            } else if (type === \"v3f\") {\n                return parseV3f(dataView, offset2);\n            } else if (type === \"int\") {\n                return parseInt32(dataView, offset2);\n            } else if (type === \"rational\") {\n                return parseRational(dataView, offset2);\n            } else if (type === \"timecode\") {\n                return parseTimecode(dataView, offset2);\n            } else if (type === \"preview\") {\n                offset2.value += size;\n                return \"skipped\";\n            } else {\n                offset2.value += size;\n                return void 0;\n            }\n        }\n        function parseHeader(dataView, buffer2, offset2) {\n            const EXRHeader2 = {};\n            if (dataView.getUint32(0, true) != 20000630) {\n                throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n            }\n            EXRHeader2.version = dataView.getUint8(4);\n            const spec = dataView.getUint8(5);\n            EXRHeader2.spec = {\n                singleTile: !!(spec & 2),\n                longName: !!(spec & 4),\n                deepFormat: !!(spec & 8),\n                multiPart: !!(spec & 16)\n            };\n            offset2.value = 8;\n            var keepReading = true;\n            while(keepReading){\n                var attributeName = parseNullTerminatedString(buffer2, offset2);\n                if (attributeName == 0) {\n                    keepReading = false;\n                } else {\n                    var attributeType = parseNullTerminatedString(buffer2, offset2);\n                    var attributeSize = parseUint32(dataView, offset2);\n                    var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n                    if (attributeValue === void 0) {\n                        console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n                    } else {\n                        EXRHeader2[attributeName] = attributeValue;\n                    }\n                }\n            }\n            if ((spec & ~4) != 0) {\n                console.error(\"EXRHeader:\", EXRHeader2);\n                throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n            }\n            return EXRHeader2;\n        }\n        function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n            const EXRDecoder2 = {\n                size: 0,\n                viewer: dataView,\n                array: uInt8Array2,\n                offset: offset2,\n                width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n                height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n                channels: EXRHeader2.channels.length,\n                bytesPerLine: null,\n                lines: null,\n                inputSize: null,\n                type: EXRHeader2.channels[0].pixelType,\n                uncompress: null,\n                getter: null,\n                format: null,\n                [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n            };\n            switch(EXRHeader2.compression){\n                case \"NO_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRAW;\n                    break;\n                case \"RLE_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRLE;\n                    break;\n                case \"ZIPS_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"ZIP_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"PIZ_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressPIZ;\n                    break;\n                case \"PXR24_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressPXR;\n                    break;\n                case \"DWAA_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                case \"DWAB_COMPRESSION\":\n                    EXRDecoder2.lines = 256;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                default:\n                    throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n            }\n            EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n            if (EXRDecoder2.type == 1) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        EXRDecoder2.getter = parseFloat16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        EXRDecoder2.getter = parseUint16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                }\n            } else if (EXRDecoder2.type == 2) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        EXRDecoder2.getter = parseFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        EXRDecoder2.getter = decodeFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                }\n            } else {\n                throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n            }\n            EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n            for(var i = 0; i < EXRDecoder2.blockCount; i++)parseInt64(dataView, offset2);\n            EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n            const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n            switch(outputType){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                    EXRDecoder2.byteArray = new Float32Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    EXRDecoder2.byteArray = new Uint16Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n                    break;\n                default:\n                    console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n                    break;\n            }\n            EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n            if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n            else EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_0__.RedFormat;\n            if (hasColorSpace) EXRDecoder2.colorSpace = \"srgb-linear\";\n            else EXRDecoder2.encoding = 3e3;\n            return EXRDecoder2;\n        }\n        const bufferDataView = new DataView(buffer);\n        const uInt8Array = new Uint8Array(buffer);\n        const offset = {\n            value: 0\n        };\n        const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n        const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n        const tmpOffset = {\n            value: 0\n        };\n        const channelOffsets = {\n            R: 0,\n            G: 1,\n            B: 2,\n            A: 3,\n            Y: 0\n        };\n        for(let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++){\n            const line = parseUint32(bufferDataView, offset);\n            EXRDecoder.size = parseUint32(bufferDataView, offset);\n            EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n            const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n            const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n            offset.value += EXRDecoder.size;\n            for(let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++){\n                const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n                if (true_y >= EXRDecoder.height) break;\n                for(let channelID = 0; channelID < EXRDecoder.channels; channelID++){\n                    const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n                    for(let x = 0; x < EXRDecoder.width; x++){\n                        tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n                        const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n                        EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n                    }\n                }\n            }\n        }\n        return {\n            header: EXRHeader,\n            width: EXRDecoder.width,\n            height: EXRDecoder.height,\n            data: EXRDecoder.byteArray,\n            format: EXRDecoder.format,\n            [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n            type: this.type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            if (hasColorSpace) texture.colorSpace = texData.colorSpace;\n            else texture.encoding = texData.encoding;\n            texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = false;\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=EXRLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRVhSTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2SDtBQUN6RjtBQUNwQyxNQUFNUyxnQkFBZ0IsZ0JBQWdCLElBQUlULDBDQUFPQTtBQUNqRCxNQUFNVSxrQkFBa0JULG9EQUFpQkE7SUFDdkNVLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUdYLGdEQUFhQTtJQUMzQjtJQUNBWSxNQUFNQyxNQUFNLEVBQUU7UUFDWixNQUFNQyxlQUFlLEtBQUs7UUFDMUIsTUFBTUMsY0FBY0QsZ0JBQWdCO1FBQ3BDLE1BQU1FLGNBQWM7UUFDcEIsTUFBTUMsY0FBYztRQUNwQixNQUFNQyxjQUFjLENBQUMsS0FBS0YsV0FBVSxJQUFLO1FBQ3pDLE1BQU1HLGNBQWMsS0FBS0Y7UUFDekIsTUFBTUcsY0FBY0QsY0FBYztRQUNsQyxNQUFNRSxRQUFRO1FBQ2QsTUFBTUMsV0FBVyxLQUFLRCxRQUFRO1FBQzlCLE1BQU1FLFdBQVcsQ0FBQyxLQUFLRixLQUFJLElBQUs7UUFDaEMsTUFBTUcscUJBQXFCO1FBQzNCLE1BQU1DLG9CQUFvQjtRQUMxQixNQUFNQyxvQkFBb0IsSUFBSUQsb0JBQW9CRDtRQUNsRCxNQUFNRyxhQUFhO1FBQ25CLE1BQU1DLGVBQWU7UUFDckIsTUFBTUMsYUFBYTtRQUNuQixNQUFNQyxhQUFhO1FBQ25CLE1BQU1DLFlBQVk7UUFDbEIsTUFBTUMsaUJBQWlCO1FBQ3ZCLE1BQU1DLFVBQVU7UUFDaEIsTUFBTUMsVUFBVTtRQUNoQixNQUFNQyxZQUFZO1FBQ2xCLE1BQU1DLE1BQU07UUFDWixNQUFNQyxVQUFVQyxLQUFLQyxHQUFHLENBQUMsV0FBVztRQUNwQyxTQUFTQyxxQkFBcUJDLE1BQU0sRUFBRUMsR0FBRztZQUN2QyxJQUFJQyxJQUFJO1lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUk5QixjQUFjLEVBQUU4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R0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsRUFBRTtZQUM5QmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEVBQUU7WUFDOUJjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxFQUFFO1lBQzlCYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdB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U0FBUyxHQUFHcGEsK0NBQVlBO1lBQ2hDaWEsUUFBUUksZUFBZSxHQUFHO1lBQzFCSixRQUFRSyxLQUFLLEdBQUc7WUFDaEIsSUFBSVQsUUFDRkEsT0FBT0ksU0FBU0M7UUFDcEI7UUFDQSxPQUFPLEtBQUssQ0FBQ1AsS0FBS0MsS0FBS0ksZ0JBQWdCRixZQUFZQztJQUNyRDtBQUNGO0FBR0UsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtY3JlYXRpdmUtcG9ydGZvbGlvLXN0YXJ0ZXItY29kZS1maWxlcy8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9FWFJMb2FkZXIuanM/N2U0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0dXJlLCBEYXRhVGV4dHVyZUxvYWRlciwgSGFsZkZsb2F0VHlwZSwgRmxvYXRUeXBlLCBSR0JBRm9ybWF0LCBSZWRGb3JtYXQsIExpbmVhckZpbHRlciwgRGF0YVV0aWxzIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyB1bnpsaWJTeW5jIH0gZnJvbSBcImZmbGF0ZVwiO1xuY29uc3QgaGFzQ29sb3JTcGFjZSA9IFwiY29sb3JTcGFjZVwiIGluIG5ldyBUZXh0dXJlKCk7XG5jbGFzcyBFWFJMb2FkZXIgZXh0ZW5kcyBEYXRhVGV4dHVyZUxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLnR5cGUgPSBIYWxmRmxvYXRUeXBlO1xuICB9XG4gIHBhcnNlKGJ1ZmZlcikge1xuICAgIGNvbnN0IFVTSE9SVF9SQU5HRSA9IDEgPDwgMTY7XG4gICAgY29uc3QgQklUTUFQX1NJWkUgPSBVU0hPUlRfUkFOR0UgPj4gMztcbiAgICBjb25zdCBIVUZfRU5DQklUUyA9IDE2O1xuICAgIGNvbnN0IEhVRl9ERUNCSVRTID0gMTQ7XG4gICAgY29uc3QgSFVGX0VOQ1NJWkUgPSAoMSA8PCBIVUZfRU5DQklUUykgKyAxO1xuICAgIGNvbnN0IEhVRl9ERUNTSVpFID0gMSA8PCBIVUZfREVDQklUUztcbiAgICBjb25zdCBIVUZfREVDTUFTSyA9IEhVRl9ERUNTSVpFIC0gMTtcbiAgICBjb25zdCBOQklUUyA9IDE2O1xuICAgIGNvbnN0IEFfT0ZGU0VUID0gMSA8PCBOQklUUyAtIDE7XG4gICAgY29uc3QgTU9EX01BU0sgPSAoMSA8PCBOQklUUykgLSAxO1xuICAgIGNvbnN0IFNIT1JUX1pFUk9DT0RFX1JVTiA9IDU5O1xuICAgIGNvbnN0IExPTkdfWkVST0NPREVfUlVOID0gNjM7XG4gICAgY29uc3QgU0hPUlRFU1RfTE9OR19SVU4gPSAyICsgTE9OR19aRVJPQ09ERV9SVU4gLSBTSE9SVF9aRVJPQ09ERV9SVU47XG4gICAgY29uc3QgVUxPTkdfU0laRSA9IDg7XG4gICAgY29uc3QgRkxPQVQzMl9TSVpFID0gNDtcbiAgICBjb25zdCBJTlQzMl9TSVpFID0gNDtcbiAgICBjb25zdCBJTlQxNl9TSVpFID0gMjtcbiAgICBjb25zdCBJTlQ4X1NJWkUgPSAxO1xuICAgIGNvbnN0IFNUQVRJQ19IVUZGTUFOID0gMDtcbiAgICBjb25zdCBERUZMQVRFID0gMTtcbiAgICBjb25zdCBVTktOT1dOID0gMDtcbiAgICBjb25zdCBMT1NTWV9EQ1QgPSAxO1xuICAgIGNvbnN0IFJMRSA9IDI7XG4gICAgY29uc3QgbG9nQmFzZSA9IE1hdGgucG93KDIuNzE4MjgxOCwgMi4yKTtcbiAgICBmdW5jdGlvbiByZXZlcnNlTHV0RnJvbUJpdG1hcChiaXRtYXAsIGx1dCkge1xuICAgICAgdmFyIGsgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBVU0hPUlRfUkFOR0U7ICsraSkge1xuICAgICAgICBpZiAoaSA9PSAwIHx8IGJpdG1hcFtpID4+IDNdICYgMSA8PCAoaSAmIDcpKSB7XG4gICAgICAgICAgbHV0W2srK10gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbiA9IGsgLSAxO1xuICAgICAgd2hpbGUgKGsgPCBVU0hPUlRfUkFOR0UpXG4gICAgICAgIGx1dFtrKytdID0gMDtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZDbGVhckRlY1RhYmxlKGhkZWMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSFVGX0RFQ1NJWkU7IGkrKykge1xuICAgICAgICBoZGVjW2ldID0ge307XG4gICAgICAgIGhkZWNbaV0ubGVuID0gMDtcbiAgICAgICAgaGRlY1tpXS5saXQgPSAwO1xuICAgICAgICBoZGVjW2ldLnAgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBnZXRCaXRzUmV0dXJuID0geyBsOiAwLCBjOiAwLCBsYzogMCB9O1xuICAgIGZ1bmN0aW9uIGdldEJpdHMobkJpdHMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpIHtcbiAgICAgIHdoaWxlIChsYyA8IG5CaXRzKSB7XG4gICAgICAgIGMgPSBjIDw8IDggfCBwYXJzZVVpbnQ4QXJyYXkodUludDhBcnJheTIsIGluT2Zmc2V0KTtcbiAgICAgICAgbGMgKz0gODtcbiAgICAgIH1cbiAgICAgIGxjIC09IG5CaXRzO1xuICAgICAgZ2V0Qml0c1JldHVybi5sID0gYyA+PiBsYyAmICgxIDw8IG5CaXRzKSAtIDE7XG4gICAgICBnZXRCaXRzUmV0dXJuLmMgPSBjO1xuICAgICAgZ2V0Qml0c1JldHVybi5sYyA9IGxjO1xuICAgIH1cbiAgICBjb25zdCBodWZUYWJsZUJ1ZmZlciA9IG5ldyBBcnJheSg1OSk7XG4gICAgZnVuY3Rpb24gaHVmQ2Fub25pY2FsQ29kZVRhYmxlKGhjb2RlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSA1ODsgKytpKVxuICAgICAgICBodWZUYWJsZUJ1ZmZlcltpXSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhVRl9FTkNTSVpFOyArK2kpXG4gICAgICAgIGh1ZlRhYmxlQnVmZmVyW2hjb2RlW2ldXSArPSAxO1xuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDU4OyBpID4gMDsgLS1pKSB7XG4gICAgICAgIHZhciBuYyA9IGMgKyBodWZUYWJsZUJ1ZmZlcltpXSA+PiAxO1xuICAgICAgICBodWZUYWJsZUJ1ZmZlcltpXSA9IGM7XG4gICAgICAgIGMgPSBuYztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSFVGX0VOQ1NJWkU7ICsraSkge1xuICAgICAgICB2YXIgbCA9IGhjb2RlW2ldO1xuICAgICAgICBpZiAobCA+IDApXG4gICAgICAgICAgaGNvZGVbaV0gPSBsIHwgaHVmVGFibGVCdWZmZXJbbF0rKyA8PCA2O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBodWZVbnBhY2tFbmNUYWJsZSh1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5pLCBpbSwgaU0sIGhjb2RlKSB7XG4gICAgICB2YXIgcCA9IGluT2Zmc2V0O1xuICAgICAgdmFyIGMgPSAwO1xuICAgICAgdmFyIGxjID0gMDtcbiAgICAgIGZvciAoOyBpbSA8PSBpTTsgaW0rKykge1xuICAgICAgICBpZiAocC52YWx1ZSAtIGluT2Zmc2V0LnZhbHVlID4gbmkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBnZXRCaXRzKDYsIGMsIGxjLCB1SW50OEFycmF5MiwgcCk7XG4gICAgICAgIHZhciBsID0gZ2V0Qml0c1JldHVybi5sO1xuICAgICAgICBjID0gZ2V0Qml0c1JldHVybi5jO1xuICAgICAgICBsYyA9IGdldEJpdHNSZXR1cm4ubGM7XG4gICAgICAgIGhjb2RlW2ltXSA9IGw7XG4gICAgICAgIGlmIChsID09IExPTkdfWkVST0NPREVfUlVOKSB7XG4gICAgICAgICAgaWYgKHAudmFsdWUgLSBpbk9mZnNldC52YWx1ZSA+IG5pKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVucGFja0VuY1RhYmxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldEJpdHMoOCwgYywgbGMsIHVJbnQ4QXJyYXkyLCBwKTtcbiAgICAgICAgICB2YXIgemVydW4gPSBnZXRCaXRzUmV0dXJuLmwgKyBTSE9SVEVTVF9MT05HX1JVTjtcbiAgICAgICAgICBjID0gZ2V0Qml0c1JldHVybi5jO1xuICAgICAgICAgIGxjID0gZ2V0Qml0c1JldHVybi5sYztcbiAgICAgICAgICBpZiAoaW0gKyB6ZXJ1biA+IGlNICsgMSkge1xuICAgICAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoemVydW4tLSlcbiAgICAgICAgICAgIGhjb2RlW2ltKytdID0gMDtcbiAgICAgICAgICBpbS0tO1xuICAgICAgICB9IGVsc2UgaWYgKGwgPj0gU0hPUlRfWkVST0NPREVfUlVOKSB7XG4gICAgICAgICAgdmFyIHplcnVuID0gbCAtIFNIT1JUX1pFUk9DT0RFX1JVTiArIDI7XG4gICAgICAgICAgaWYgKGltICsgemVydW4gPiBpTSArIDEpIHtcbiAgICAgICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5wYWNrRW5jVGFibGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHplcnVuLS0pXG4gICAgICAgICAgICBoY29kZVtpbSsrXSA9IDA7XG4gICAgICAgICAgaW0tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaHVmQ2Fub25pY2FsQ29kZVRhYmxlKGhjb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmTGVuZ3RoKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlICYgNjM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZkNvZGUoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPj4gNjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmQnVpbGREZWNUYWJsZShoY29kZSwgaW0sIGlNLCBoZGVjb2QpIHtcbiAgICAgIGZvciAoOyBpbSA8PSBpTTsgaW0rKykge1xuICAgICAgICB2YXIgYyA9IGh1ZkNvZGUoaGNvZGVbaW1dKTtcbiAgICAgICAgdmFyIGwgPSBodWZMZW5ndGgoaGNvZGVbaW1dKTtcbiAgICAgICAgaWYgKGMgPj4gbCkge1xuICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0YWJsZSBlbnRyeVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsID4gSFVGX0RFQ0JJVFMpIHtcbiAgICAgICAgICB2YXIgcGwgPSBoZGVjb2RbYyA+PiBsIC0gSFVGX0RFQ0JJVFNdO1xuICAgICAgICAgIGlmIChwbC5sZW4pIHtcbiAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0YWJsZSBlbnRyeVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwbC5saXQrKztcbiAgICAgICAgICBpZiAocGwucCkge1xuICAgICAgICAgICAgdmFyIHAgPSBwbC5wO1xuICAgICAgICAgICAgcGwucCA9IG5ldyBBcnJheShwbC5saXQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbC5saXQgLSAxOyArK2kpIHtcbiAgICAgICAgICAgICAgcGwucFtpXSA9IHBbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBsLnAgPSBuZXcgQXJyYXkoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBsLnBbcGwubGl0IC0gMV0gPSBpbTtcbiAgICAgICAgfSBlbHNlIGlmIChsKSB7XG4gICAgICAgICAgdmFyIHBsT2Zmc2V0ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMSA8PCBIVUZfREVDQklUUyAtIGw7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBwbCA9IGhkZWNvZFsoYyA8PCBIVUZfREVDQklUUyAtIGwpICsgcGxPZmZzZXRdO1xuICAgICAgICAgICAgaWYgKHBsLmxlbiB8fCBwbC5wKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0YWJsZSBlbnRyeVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGwubGVuID0gbDtcbiAgICAgICAgICAgIHBsLmxpdCA9IGltO1xuICAgICAgICAgICAgcGxPZmZzZXQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBnZXRDaGFyUmV0dXJuID0geyBjOiAwLCBsYzogMCB9O1xuICAgIGZ1bmN0aW9uIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCkge1xuICAgICAgYyA9IGMgPDwgOCB8IHBhcnNlVWludDhBcnJheSh1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgbGMgKz0gODtcbiAgICAgIGdldENoYXJSZXR1cm4uYyA9IGM7XG4gICAgICBnZXRDaGFyUmV0dXJuLmxjID0gbGM7XG4gICAgfVxuICAgIGNvbnN0IGdldENvZGVSZXR1cm4gPSB7IGM6IDAsIGxjOiAwIH07XG4gICAgZnVuY3Rpb24gZ2V0Q29kZShwbywgcmxjLCBjLCBsYywgdUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBvdXRCdWZmZXIsIG91dEJ1ZmZlck9mZnNldCwgb3V0QnVmZmVyRW5kT2Zmc2V0KSB7XG4gICAgICBpZiAocG8gPT0gcmxjKSB7XG4gICAgICAgIGlmIChsYyA8IDgpIHtcbiAgICAgICAgICBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICAgIGMgPSBnZXRDaGFyUmV0dXJuLmM7XG4gICAgICAgICAgbGMgPSBnZXRDaGFyUmV0dXJuLmxjO1xuICAgICAgICB9XG4gICAgICAgIGxjIC09IDg7XG4gICAgICAgIHZhciBjcyA9IGMgPj4gbGM7XG4gICAgICAgIHZhciBjcyA9IG5ldyBVaW50OEFycmF5KFtjc10pWzBdO1xuICAgICAgICBpZiAob3V0QnVmZmVyT2Zmc2V0LnZhbHVlICsgY3MgPiBvdXRCdWZmZXJFbmRPZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSBvdXRCdWZmZXJbb3V0QnVmZmVyT2Zmc2V0LnZhbHVlIC0gMV07XG4gICAgICAgIHdoaWxlIChjcy0tID4gMCkge1xuICAgICAgICAgIG91dEJ1ZmZlcltvdXRCdWZmZXJPZmZzZXQudmFsdWUrK10gPSBzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG91dEJ1ZmZlck9mZnNldC52YWx1ZSA8IG91dEJ1ZmZlckVuZE9mZnNldCkge1xuICAgICAgICBvdXRCdWZmZXJbb3V0QnVmZmVyT2Zmc2V0LnZhbHVlKytdID0gcG87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnZXRDb2RlUmV0dXJuLmMgPSBjO1xuICAgICAgZ2V0Q29kZVJldHVybi5sYyA9IGxjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVSW50MTYodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmIDY1NTM1O1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbnQxNih2YWx1ZSkge1xuICAgICAgdmFyIHJlZiA9IFVJbnQxNih2YWx1ZSk7XG4gICAgICByZXR1cm4gcmVmID4gMzI3NjcgPyByZWYgLSA2NTUzNiA6IHJlZjtcbiAgICB9XG4gICAgY29uc3Qgd2RlYzE0UmV0dXJuID0geyBhOiAwLCBiOiAwIH07XG4gICAgZnVuY3Rpb24gd2RlYzE0KGwsIGgpIHtcbiAgICAgIHZhciBscyA9IEludDE2KGwpO1xuICAgICAgdmFyIGhzID0gSW50MTYoaCk7XG4gICAgICB2YXIgaGkgPSBocztcbiAgICAgIHZhciBhaSA9IGxzICsgKGhpICYgMSkgKyAoaGkgPj4gMSk7XG4gICAgICB2YXIgYXMgPSBhaTtcbiAgICAgIHZhciBicyA9IGFpIC0gaGk7XG4gICAgICB3ZGVjMTRSZXR1cm4uYSA9IGFzO1xuICAgICAgd2RlYzE0UmV0dXJuLmIgPSBicztcbiAgICB9XG4gICAgZnVuY3Rpb24gd2RlYzE2KGwsIGgpIHtcbiAgICAgIHZhciBtID0gVUludDE2KGwpO1xuICAgICAgdmFyIGQgPSBVSW50MTYoaCk7XG4gICAgICB2YXIgYmIgPSBtIC0gKGQgPj4gMSkgJiBNT0RfTUFTSztcbiAgICAgIHZhciBhYSA9IGQgKyBiYiAtIEFfT0ZGU0VUICYgTU9EX01BU0s7XG4gICAgICB3ZGVjMTRSZXR1cm4uYSA9IGFhO1xuICAgICAgd2RlYzE0UmV0dXJuLmIgPSBiYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2F2MkRlY29kZShidWZmZXIyLCBqLCBueCwgb3gsIG55LCBveSwgbXgpIHtcbiAgICAgIHZhciB3MTQgPSBteCA8IDEgPDwgMTQ7XG4gICAgICB2YXIgbiA9IG54ID4gbnkgPyBueSA6IG54O1xuICAgICAgdmFyIHAgPSAxO1xuICAgICAgdmFyIHAyO1xuICAgICAgd2hpbGUgKHAgPD0gbilcbiAgICAgICAgcCA8PD0gMTtcbiAgICAgIHAgPj49IDE7XG4gICAgICBwMiA9IHA7XG4gICAgICBwID4+PSAxO1xuICAgICAgd2hpbGUgKHAgPj0gMSkge1xuICAgICAgICB2YXIgcHkgPSAwO1xuICAgICAgICB2YXIgZXkgPSBweSArIG95ICogKG55IC0gcDIpO1xuICAgICAgICB2YXIgb3kxID0gb3kgKiBwO1xuICAgICAgICB2YXIgb3kyID0gb3kgKiBwMjtcbiAgICAgICAgdmFyIG94MSA9IG94ICogcDtcbiAgICAgICAgdmFyIG94MiA9IG94ICogcDI7XG4gICAgICAgIHZhciBpMDAsIGkwMSwgaTEwLCBpMTE7XG4gICAgICAgIGZvciAoOyBweSA8PSBleTsgcHkgKz0gb3kyKSB7XG4gICAgICAgICAgdmFyIHB4ID0gcHk7XG4gICAgICAgICAgdmFyIGV4ID0gcHkgKyBveCAqIChueCAtIHAyKTtcbiAgICAgICAgICBmb3IgKDsgcHggPD0gZXg7IHB4ICs9IG94Mikge1xuICAgICAgICAgICAgdmFyIHAwMSA9IHB4ICsgb3gxO1xuICAgICAgICAgICAgdmFyIHAxMCA9IHB4ICsgb3kxO1xuICAgICAgICAgICAgdmFyIHAxMSA9IHAxMCArIG94MTtcbiAgICAgICAgICAgIGlmICh3MTQpIHtcbiAgICAgICAgICAgICAgd2RlYzE0KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMTAgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTAgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE0KGJ1ZmZlcjJbcDAxICsgal0sIGJ1ZmZlcjJbcDExICsgal0pO1xuICAgICAgICAgICAgICBpMDEgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgaTExID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNChpMDAsIGkwMSk7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcHggKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AwMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNChpMTAsIGkxMSk7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDEwICsgal0gPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTEgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2RlYzE2KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMTAgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTAgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE2KGJ1ZmZlcjJbcDAxICsgal0sIGJ1ZmZlcjJbcDExICsgal0pO1xuICAgICAgICAgICAgICBpMDEgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgaTExID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNihpMDAsIGkwMSk7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcHggKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AwMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNihpMTAsIGkxMSk7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDEwICsgal0gPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTEgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnggJiBwKSB7XG4gICAgICAgICAgICB2YXIgcDEwID0gcHggKyBveTE7XG4gICAgICAgICAgICBpZiAodzE0KVxuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgd2RlYzE2KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMTAgKyBqXSk7XG4gICAgICAgICAgICBpMDAgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgIGJ1ZmZlcjJbcDEwICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgIGJ1ZmZlcjJbcHggKyBqXSA9IGkwMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG55ICYgcCkge1xuICAgICAgICAgIHZhciBweCA9IHB5O1xuICAgICAgICAgIHZhciBleCA9IHB5ICsgb3ggKiAobnggLSBwMik7XG4gICAgICAgICAgZm9yICg7IHB4IDw9IGV4OyBweCArPSBveDIpIHtcbiAgICAgICAgICAgIHZhciBwMDEgPSBweCArIG94MTtcbiAgICAgICAgICAgIGlmICh3MTQpXG4gICAgICAgICAgICAgIHdkZWMxNChidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDAxICsgal0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AwMSArIGpdKTtcbiAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgYnVmZmVyMltwMDEgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gaTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwMiA9IHA7XG4gICAgICAgIHAgPj49IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZkRlY29kZShlbmNvZGluZ1RhYmxlLCBkZWNvZGluZ1RhYmxlLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5pLCBybGMsIG5vLCBvdXRCdWZmZXIsIG91dE9mZnNldCkge1xuICAgICAgdmFyIGMgPSAwO1xuICAgICAgdmFyIGxjID0gMDtcbiAgICAgIHZhciBvdXRCdWZmZXJFbmRPZmZzZXQgPSBubztcbiAgICAgIHZhciBpbk9mZnNldEVuZCA9IE1hdGgudHJ1bmMoaW5PZmZzZXQudmFsdWUgKyAobmkgKyA3KSAvIDgpO1xuICAgICAgd2hpbGUgKGluT2Zmc2V0LnZhbHVlIDwgaW5PZmZzZXRFbmQpIHtcbiAgICAgICAgZ2V0Q2hhcihjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KTtcbiAgICAgICAgYyA9IGdldENoYXJSZXR1cm4uYztcbiAgICAgICAgbGMgPSBnZXRDaGFyUmV0dXJuLmxjO1xuICAgICAgICB3aGlsZSAobGMgPj0gSFVGX0RFQ0JJVFMpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBjID4+IGxjIC0gSFVGX0RFQ0JJVFMgJiBIVUZfREVDTUFTSztcbiAgICAgICAgICB2YXIgcGwgPSBkZWNvZGluZ1RhYmxlW2luZGV4XTtcbiAgICAgICAgICBpZiAocGwubGVuKSB7XG4gICAgICAgICAgICBsYyAtPSBwbC5sZW47XG4gICAgICAgICAgICBnZXRDb2RlKHBsLmxpdCwgcmxjLCBjLCBsYywgdUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBvdXRCdWZmZXIsIG91dE9mZnNldCwgb3V0QnVmZmVyRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgIGMgPSBnZXRDb2RlUmV0dXJuLmM7XG4gICAgICAgICAgICBsYyA9IGdldENvZGVSZXR1cm4ubGM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcGwucCkge1xuICAgICAgICAgICAgICB0aHJvdyBcImh1ZkRlY29kZSBpc3N1ZXNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBsLmxpdDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBsID0gaHVmTGVuZ3RoKGVuY29kaW5nVGFibGVbcGwucFtqXV0pO1xuICAgICAgICAgICAgICB3aGlsZSAobGMgPCBsICYmIGluT2Zmc2V0LnZhbHVlIDwgaW5PZmZzZXRFbmQpIHtcbiAgICAgICAgICAgICAgICBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIGMgPSBnZXRDaGFyUmV0dXJuLmM7XG4gICAgICAgICAgICAgICAgbGMgPSBnZXRDaGFyUmV0dXJuLmxjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsYyA+PSBsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGh1ZkNvZGUoZW5jb2RpbmdUYWJsZVtwbC5wW2pdXSkgPT0gKGMgPj4gbGMgLSBsICYgKDEgPDwgbCkgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgbGMgLT0gbDtcbiAgICAgICAgICAgICAgICAgIGdldENvZGUoXG4gICAgICAgICAgICAgICAgICAgIHBsLnBbal0sXG4gICAgICAgICAgICAgICAgICAgIHJsYyxcbiAgICAgICAgICAgICAgICAgICAgYyxcbiAgICAgICAgICAgICAgICAgICAgbGMsXG4gICAgICAgICAgICAgICAgICAgIHVJbnQ4QXJyYXkyLFxuICAgICAgICAgICAgICAgICAgICBpbkRhdGFWaWV3LFxuICAgICAgICAgICAgICAgICAgICBpbk9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICBvdXRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG91dEJ1ZmZlckVuZE9mZnNldFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGMgPSBnZXRDb2RlUmV0dXJuLmM7XG4gICAgICAgICAgICAgICAgICBsYyA9IGdldENvZGVSZXR1cm4ubGM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqID09IHBsLmxpdCkge1xuICAgICAgICAgICAgICB0aHJvdyBcImh1ZkRlY29kZSBpc3N1ZXNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpID0gOCAtIG5pICYgNztcbiAgICAgIGMgPj49IGk7XG4gICAgICBsYyAtPSBpO1xuICAgICAgd2hpbGUgKGxjID4gMCkge1xuICAgICAgICB2YXIgcGwgPSBkZWNvZGluZ1RhYmxlW2MgPDwgSFVGX0RFQ0JJVFMgLSBsYyAmIEhVRl9ERUNNQVNLXTtcbiAgICAgICAgaWYgKHBsLmxlbikge1xuICAgICAgICAgIGxjIC09IHBsLmxlbjtcbiAgICAgICAgICBnZXRDb2RlKHBsLmxpdCwgcmxjLCBjLCBsYywgdUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBvdXRCdWZmZXIsIG91dE9mZnNldCwgb3V0QnVmZmVyRW5kT2Zmc2V0KTtcbiAgICAgICAgICBjID0gZ2V0Q29kZVJldHVybi5jO1xuICAgICAgICAgIGxjID0gZ2V0Q29kZVJldHVybi5sYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcImh1ZkRlY29kZSBpc3N1ZXNcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZlVuY29tcHJlc3ModUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBuQ29tcHJlc3NlZCwgb3V0QnVmZmVyLCBuUmF3KSB7XG4gICAgICB2YXIgb3V0T2Zmc2V0ID0geyB2YWx1ZTogMCB9O1xuICAgICAgdmFyIGluaXRpYWxJbk9mZnNldCA9IGluT2Zmc2V0LnZhbHVlO1xuICAgICAgdmFyIGltID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgdmFyIGlNID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaW5PZmZzZXQudmFsdWUgKz0gNDtcbiAgICAgIHZhciBuQml0cyA9IHBhcnNlVWludDMyKGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIGluT2Zmc2V0LnZhbHVlICs9IDQ7XG4gICAgICBpZiAoaW0gPCAwIHx8IGltID49IEhVRl9FTkNTSVpFIHx8IGlNIDwgMCB8fCBpTSA+PSBIVUZfRU5DU0laRSkge1xuICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIEhVRl9FTkNTSVpFXCI7XG4gICAgICB9XG4gICAgICB2YXIgZnJlcSA9IG5ldyBBcnJheShIVUZfRU5DU0laRSk7XG4gICAgICB2YXIgaGRlYyA9IG5ldyBBcnJheShIVUZfREVDU0laRSk7XG4gICAgICBodWZDbGVhckRlY1RhYmxlKGhkZWMpO1xuICAgICAgdmFyIG5pID0gbkNvbXByZXNzZWQgLSAoaW5PZmZzZXQudmFsdWUgLSBpbml0aWFsSW5PZmZzZXQpO1xuICAgICAgaHVmVW5wYWNrRW5jVGFibGUodUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBuaSwgaW0sIGlNLCBmcmVxKTtcbiAgICAgIGlmIChuQml0cyA+IDggKiAobkNvbXByZXNzZWQgLSAoaW5PZmZzZXQudmFsdWUgLSBpbml0aWFsSW5PZmZzZXQpKSkge1xuICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVuY29tcHJlc3NcIjtcbiAgICAgIH1cbiAgICAgIGh1ZkJ1aWxkRGVjVGFibGUoZnJlcSwgaW0sIGlNLCBoZGVjKTtcbiAgICAgIGh1ZkRlY29kZShmcmVxLCBoZGVjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5CaXRzLCBpTSwgblJhdywgb3V0QnVmZmVyLCBvdXRPZmZzZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseUx1dChsdXQsIGRhdGEsIG5EYXRhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5EYXRhOyArK2kpIHtcbiAgICAgICAgZGF0YVtpXSA9IGx1dFtkYXRhW2ldXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlZGljdG9yKHNvdXJjZSkge1xuICAgICAgZm9yICh2YXIgdCA9IDE7IHQgPCBzb3VyY2UubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgdmFyIGQgPSBzb3VyY2VbdCAtIDFdICsgc291cmNlW3RdIC0gMTI4O1xuICAgICAgICBzb3VyY2VbdF0gPSBkO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcmxlYXZlU2NhbGFyKHNvdXJjZSwgb3V0KSB7XG4gICAgICB2YXIgdDEgPSAwO1xuICAgICAgdmFyIHQyID0gTWF0aC5mbG9vcigoc291cmNlLmxlbmd0aCArIDEpIC8gMik7XG4gICAgICB2YXIgcyA9IDA7XG4gICAgICB2YXIgc3RvcCA9IHNvdXJjZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKHMgPiBzdG9wKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvdXRbcysrXSA9IHNvdXJjZVt0MSsrXTtcbiAgICAgICAgaWYgKHMgPiBzdG9wKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvdXRbcysrXSA9IHNvdXJjZVt0MisrXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlUnVuTGVuZ3RoKHNvdXJjZSkge1xuICAgICAgdmFyIHNpemUgPSBzb3VyY2UuYnl0ZUxlbmd0aDtcbiAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoKTtcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIHZhciByZWFkZXIgPSBuZXcgRGF0YVZpZXcoc291cmNlKTtcbiAgICAgIHdoaWxlIChzaXplID4gMCkge1xuICAgICAgICB2YXIgbCA9IHJlYWRlci5nZXRJbnQ4KHArKyk7XG4gICAgICAgIGlmIChsIDwgMCkge1xuICAgICAgICAgIHZhciBjb3VudCA9IC1sO1xuICAgICAgICAgIHNpemUgLT0gY291bnQgKyAxO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgb3V0LnB1c2gocmVhZGVyLmdldFVpbnQ4KHArKykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY291bnQgPSBsO1xuICAgICAgICAgIHNpemUgLT0gMjtcbiAgICAgICAgICB2YXIgdmFsdWUgPSByZWFkZXIuZ2V0VWludDgocCsrKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBvdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb3NzeURjdERlY29kZShjc2NTZXQsIHJvd1B0cnMsIGNoYW5uZWxEYXRhLCBhY0J1ZmZlciwgZGNCdWZmZXIsIG91dEJ1ZmZlcikge1xuICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG91dEJ1ZmZlci5idWZmZXIpO1xuICAgICAgdmFyIHdpZHRoID0gY2hhbm5lbERhdGFbY3NjU2V0LmlkeFswXV0ud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gY2hhbm5lbERhdGFbY3NjU2V0LmlkeFswXV0uaGVpZ2h0O1xuICAgICAgdmFyIG51bUNvbXAgPSAzO1xuICAgICAgdmFyIG51bUZ1bGxCbG9ja3NYID0gTWF0aC5mbG9vcih3aWR0aCAvIDgpO1xuICAgICAgdmFyIG51bUJsb2Nrc1ggPSBNYXRoLmNlaWwod2lkdGggLyA4KTtcbiAgICAgIHZhciBudW1CbG9ja3NZID0gTWF0aC5jZWlsKGhlaWdodCAvIDgpO1xuICAgICAgdmFyIGxlZnRvdmVyWCA9IHdpZHRoIC0gKG51bUJsb2Nrc1ggLSAxKSAqIDg7XG4gICAgICB2YXIgbGVmdG92ZXJZID0gaGVpZ2h0IC0gKG51bUJsb2Nrc1kgLSAxKSAqIDg7XG4gICAgICB2YXIgY3VyckFjQ29tcCA9IHsgdmFsdWU6IDAgfTtcbiAgICAgIHZhciBjdXJyRGNDb21wID0gbmV3IEFycmF5KG51bUNvbXApO1xuICAgICAgdmFyIGRjdERhdGEgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgaGFsZlppZ0Jsb2NrID0gbmV3IEFycmF5KG51bUNvbXApO1xuICAgICAgdmFyIHJvd0Jsb2NrID0gbmV3IEFycmF5KG51bUNvbXApO1xuICAgICAgdmFyIHJvd09mZnNldHMgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICBmb3IgKGxldCBjb21wMiA9IDA7IGNvbXAyIDwgbnVtQ29tcDsgKytjb21wMikge1xuICAgICAgICByb3dPZmZzZXRzW2NvbXAyXSA9IHJvd1B0cnNbY3NjU2V0LmlkeFtjb21wMl1dO1xuICAgICAgICBjdXJyRGNDb21wW2NvbXAyXSA9IGNvbXAyIDwgMSA/IDAgOiBjdXJyRGNDb21wW2NvbXAyIC0gMV0gKyBudW1CbG9ja3NYICogbnVtQmxvY2tzWTtcbiAgICAgICAgZGN0RGF0YVtjb21wMl0gPSBuZXcgRmxvYXQzMkFycmF5KDY0KTtcbiAgICAgICAgaGFsZlppZ0Jsb2NrW2NvbXAyXSA9IG5ldyBVaW50MTZBcnJheSg2NCk7XG4gICAgICAgIHJvd0Jsb2NrW2NvbXAyXSA9IG5ldyBVaW50MTZBcnJheShudW1CbG9ja3NYICogNjQpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgYmxvY2t5ID0gMDsgYmxvY2t5IDwgbnVtQmxvY2tzWTsgKytibG9ja3kpIHtcbiAgICAgICAgdmFyIG1heFkgPSA4O1xuICAgICAgICBpZiAoYmxvY2t5ID09IG51bUJsb2Nrc1kgLSAxKVxuICAgICAgICAgIG1heFkgPSBsZWZ0b3Zlclk7XG4gICAgICAgIHZhciBtYXhYID0gODtcbiAgICAgICAgZm9yIChsZXQgYmxvY2t4ID0gMDsgYmxvY2t4IDwgbnVtQmxvY2tzWDsgKytibG9ja3gpIHtcbiAgICAgICAgICBpZiAoYmxvY2t4ID09IG51bUJsb2Nrc1ggLSAxKVxuICAgICAgICAgICAgbWF4WCA9IGxlZnRvdmVyWDtcbiAgICAgICAgICBmb3IgKGxldCBjb21wMiA9IDA7IGNvbXAyIDwgbnVtQ29tcDsgKytjb21wMikge1xuICAgICAgICAgICAgaGFsZlppZ0Jsb2NrW2NvbXAyXS5maWxsKDApO1xuICAgICAgICAgICAgaGFsZlppZ0Jsb2NrW2NvbXAyXVswXSA9IGRjQnVmZmVyW2N1cnJEY0NvbXBbY29tcDJdKytdO1xuICAgICAgICAgICAgdW5SbGVBQyhjdXJyQWNDb21wLCBhY0J1ZmZlciwgaGFsZlppZ0Jsb2NrW2NvbXAyXSk7XG4gICAgICAgICAgICB1blppZ1phZyhoYWxmWmlnQmxvY2tbY29tcDJdLCBkY3REYXRhW2NvbXAyXSk7XG4gICAgICAgICAgICBkY3RJbnZlcnNlKGRjdERhdGFbY29tcDJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAge1xuICAgICAgICAgICAgY3NjNzA5SW52ZXJzZShkY3REYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgY29tcDIgPSAwOyBjb21wMiA8IG51bUNvbXA7ICsrY29tcDIpIHtcbiAgICAgICAgICAgIGNvbnZlcnRUb0hhbGYoZGN0RGF0YVtjb21wMl0sIHJvd0Jsb2NrW2NvbXAyXSwgYmxvY2t4ICogNjQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgb2Zmc2V0MiA9IDA7XG4gICAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgICAgY29uc3QgdHlwZTIgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXAyXV0udHlwZTtcbiAgICAgICAgICBmb3IgKGxldCB5MiA9IDggKiBibG9ja3k7IHkyIDwgOCAqIGJsb2NreSArIG1heFk7ICsreTIpIHtcbiAgICAgICAgICAgIG9mZnNldDIgPSByb3dPZmZzZXRzW2NvbXAyXVt5Ml07XG4gICAgICAgICAgICBmb3IgKGxldCBibG9ja3ggPSAwOyBibG9ja3ggPCBudW1GdWxsQmxvY2tzWDsgKytibG9ja3gpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3JjID0gYmxvY2t4ICogNjQgKyAoeTIgJiA3KSAqIDg7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgMCAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDBdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAxICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgMV0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDIgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyAyXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgMyAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDNdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyA0ICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgNF0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDUgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA1XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgNiAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDZdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyA3ICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgN10sIHRydWUpO1xuICAgICAgICAgICAgICBvZmZzZXQyICs9IDggKiBJTlQxNl9TSVpFICogdHlwZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudW1GdWxsQmxvY2tzWCAhPSBudW1CbG9ja3NYKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5MiA9IDggKiBibG9ja3k7IHkyIDwgOCAqIGJsb2NreSArIG1heFk7ICsreTIpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MyA9IHJvd09mZnNldHNbY29tcDJdW3kyXSArIDggKiBudW1GdWxsQmxvY2tzWCAqIElOVDE2X1NJWkUgKiB0eXBlMjtcbiAgICAgICAgICAgICAgY29uc3Qgc3JjID0gbnVtRnVsbEJsb2Nrc1ggKiA2NCArICh5MiAmIDcpICogODtcbiAgICAgICAgICAgICAgZm9yIChsZXQgeDIgPSAwOyB4MiA8IG1heFg7ICsreDIpIHtcbiAgICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MyArIHgyICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgeDJdLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGhhbGZSb3cgPSBuZXcgVWludDE2QXJyYXkod2lkdGgpO1xuICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG91dEJ1ZmZlci5idWZmZXIpO1xuICAgICAgZm9yICh2YXIgY29tcCA9IDA7IGNvbXAgPCBudW1Db21wOyArK2NvbXApIHtcbiAgICAgICAgY2hhbm5lbERhdGFbY3NjU2V0LmlkeFtjb21wXV0uZGVjb2RlZCA9IHRydWU7XG4gICAgICAgIHZhciB0eXBlID0gY2hhbm5lbERhdGFbY3NjU2V0LmlkeFtjb21wXV0udHlwZTtcbiAgICAgICAgaWYgKGNoYW5uZWxEYXRhW2NvbXBdLnR5cGUgIT0gMilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSByb3dPZmZzZXRzW2NvbXBdW3ldO1xuICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgICAgICAgaGFsZlJvd1t4XSA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQyICsgeCAqIElOVDE2X1NJWkUgKiB0eXBlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRGbG9hdDMyKG9mZnNldDIgKyB4ICogSU5UMTZfU0laRSAqIHR5cGUsIGRlY29kZUZsb2F0MTYoaGFsZlJvd1t4XSksIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1blJsZUFDKGN1cnJBY0NvbXAsIGFjQnVmZmVyLCBoYWxmWmlnQmxvY2spIHtcbiAgICAgIHZhciBhY1ZhbHVlO1xuICAgICAgdmFyIGRjdENvbXAgPSAxO1xuICAgICAgd2hpbGUgKGRjdENvbXAgPCA2NCkge1xuICAgICAgICBhY1ZhbHVlID0gYWNCdWZmZXJbY3VyckFjQ29tcC52YWx1ZV07XG4gICAgICAgIGlmIChhY1ZhbHVlID09IDY1MjgwKSB7XG4gICAgICAgICAgZGN0Q29tcCA9IDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFjVmFsdWUgPj4gOCA9PSAyNTUpIHtcbiAgICAgICAgICBkY3RDb21wICs9IGFjVmFsdWUgJiAyNTU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFsZlppZ0Jsb2NrW2RjdENvbXBdID0gYWNWYWx1ZTtcbiAgICAgICAgICBkY3RDb21wKys7XG4gICAgICAgIH1cbiAgICAgICAgY3VyckFjQ29tcC52YWx1ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1blppZ1phZyhzcmMsIGRzdCkge1xuICAgICAgZHN0WzBdID0gZGVjb2RlRmxvYXQxNihzcmNbMF0pO1xuICAgICAgZHN0WzFdID0gZGVjb2RlRmxvYXQxNihzcmNbMV0pO1xuICAgICAgZHN0WzJdID0gZGVjb2RlRmxvYXQxNihzcmNbNV0pO1xuICAgICAgZHN0WzNdID0gZGVjb2RlRmxvYXQxNihzcmNbNl0pO1xuICAgICAgZHN0WzRdID0gZGVjb2RlRmxvYXQxNihzcmNbMTRdKTtcbiAgICAgIGRzdFs1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE1XSk7XG4gICAgICBkc3RbNl0gPSBkZWNvZGVGbG9hdDE2KHNyY1syN10pO1xuICAgICAgZHN0WzddID0gZGVjb2RlRmxvYXQxNihzcmNbMjhdKTtcbiAgICAgIGRzdFs4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzJdKTtcbiAgICAgIGRzdFs5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzRdKTtcbiAgICAgIGRzdFsxMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s3XSk7XG4gICAgICBkc3RbMTFdID0gZGVjb2RlRmxvYXQxNihzcmNbMTNdKTtcbiAgICAgIGRzdFsxMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxNl0pO1xuICAgICAgZHN0WzEzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzI2XSk7XG4gICAgICBkc3RbMTRdID0gZGVjb2RlRmxvYXQxNihzcmNbMjldKTtcbiAgICAgIGRzdFsxNV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0Ml0pO1xuICAgICAgZHN0WzE2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzNdKTtcbiAgICAgIGRzdFsxN10gPSBkZWNvZGVGbG9hdDE2KHNyY1s4XSk7XG4gICAgICBkc3RbMThdID0gZGVjb2RlRmxvYXQxNihzcmNbMTJdKTtcbiAgICAgIGRzdFsxOV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxN10pO1xuICAgICAgZHN0WzIwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzI1XSk7XG4gICAgICBkc3RbMjFdID0gZGVjb2RlRmxvYXQxNihzcmNbMzBdKTtcbiAgICAgIGRzdFsyMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0MV0pO1xuICAgICAgZHN0WzIzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQzXSk7XG4gICAgICBkc3RbMjRdID0gZGVjb2RlRmxvYXQxNihzcmNbOV0pO1xuICAgICAgZHN0WzI1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzExXSk7XG4gICAgICBkc3RbMjZdID0gZGVjb2RlRmxvYXQxNihzcmNbMThdKTtcbiAgICAgIGRzdFsyN10gPSBkZWNvZGVGbG9hdDE2KHNyY1syNF0pO1xuICAgICAgZHN0WzI4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzMxXSk7XG4gICAgICBkc3RbMjldID0gZGVjb2RlRmxvYXQxNihzcmNbNDBdKTtcbiAgICAgIGRzdFszMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0NF0pO1xuICAgICAgZHN0WzMxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzUzXSk7XG4gICAgICBkc3RbMzJdID0gZGVjb2RlRmxvYXQxNihzcmNbMTBdKTtcbiAgICAgIGRzdFszM10gPSBkZWNvZGVGbG9hdDE2KHNyY1sxOV0pO1xuICAgICAgZHN0WzM0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzIzXSk7XG4gICAgICBkc3RbMzVdID0gZGVjb2RlRmxvYXQxNihzcmNbMzJdKTtcbiAgICAgIGRzdFszNl0gPSBkZWNvZGVGbG9hdDE2KHNyY1szOV0pO1xuICAgICAgZHN0WzM3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ1XSk7XG4gICAgICBkc3RbMzhdID0gZGVjb2RlRmxvYXQxNihzcmNbNTJdKTtcbiAgICAgIGRzdFszOV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1NF0pO1xuICAgICAgZHN0WzQwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzIwXSk7XG4gICAgICBkc3RbNDFdID0gZGVjb2RlRmxvYXQxNihzcmNbMjJdKTtcbiAgICAgIGRzdFs0Ml0gPSBkZWNvZGVGbG9hdDE2KHNyY1szM10pO1xuICAgICAgZHN0WzQzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzM4XSk7XG4gICAgICBkc3RbNDRdID0gZGVjb2RlRmxvYXQxNihzcmNbNDZdKTtcbiAgICAgIGRzdFs0NV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1MV0pO1xuICAgICAgZHN0WzQ2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU1XSk7XG4gICAgICBkc3RbNDddID0gZGVjb2RlRmxvYXQxNihzcmNbNjBdKTtcbiAgICAgIGRzdFs0OF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syMV0pO1xuICAgICAgZHN0WzQ5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM0XSk7XG4gICAgICBkc3RbNTBdID0gZGVjb2RlRmxvYXQxNihzcmNbMzddKTtcbiAgICAgIGRzdFs1MV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0N10pO1xuICAgICAgZHN0WzUyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzUwXSk7XG4gICAgICBkc3RbNTNdID0gZGVjb2RlRmxvYXQxNihzcmNbNTZdKTtcbiAgICAgIGRzdFs1NF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1OV0pO1xuICAgICAgZHN0WzU1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzYxXSk7XG4gICAgICBkc3RbNTZdID0gZGVjb2RlRmxvYXQxNihzcmNbMzVdKTtcbiAgICAgIGRzdFs1N10gPSBkZWNvZGVGbG9hdDE2KHNyY1szNl0pO1xuICAgICAgZHN0WzU4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ4XSk7XG4gICAgICBkc3RbNTldID0gZGVjb2RlRmxvYXQxNihzcmNbNDldKTtcbiAgICAgIGRzdFs2MF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1N10pO1xuICAgICAgZHN0WzYxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzU4XSk7XG4gICAgICBkc3RbNjJdID0gZGVjb2RlRmxvYXQxNihzcmNbNjJdKTtcbiAgICAgIGRzdFs2M10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2M10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkY3RJbnZlcnNlKGRhdGEpIHtcbiAgICAgIGNvbnN0IGEgPSAwLjUgKiBNYXRoLmNvcygzLjE0MTU5IC8gNCk7XG4gICAgICBjb25zdCBiID0gMC41ICogTWF0aC5jb3MoMy4xNDE1OSAvIDE2KTtcbiAgICAgIGNvbnN0IGMgPSAwLjUgKiBNYXRoLmNvcygzLjE0MTU5IC8gOCk7XG4gICAgICBjb25zdCBkID0gMC41ICogTWF0aC5jb3MoMyAqIDMuMTQxNTkgLyAxNik7XG4gICAgICBjb25zdCBlID0gMC41ICogTWF0aC5jb3MoNSAqIDMuMTQxNTkgLyAxNik7XG4gICAgICBjb25zdCBmID0gMC41ICogTWF0aC5jb3MoMyAqIDMuMTQxNTkgLyA4KTtcbiAgICAgIGNvbnN0IGcgPSAwLjUgKiBNYXRoLmNvcyg3ICogMy4xNDE1OSAvIDE2KTtcbiAgICAgIHZhciBhbHBoYSA9IG5ldyBBcnJheSg0KTtcbiAgICAgIHZhciBiZXRhID0gbmV3IEFycmF5KDQpO1xuICAgICAgdmFyIHRoZXRhID0gbmV3IEFycmF5KDQpO1xuICAgICAgdmFyIGdhbW1hID0gbmV3IEFycmF5KDQpO1xuICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgODsgKytyb3cpIHtcbiAgICAgICAgdmFyIHJvd1B0ciA9IHJvdyAqIDg7XG4gICAgICAgIGFscGhhWzBdID0gYyAqIGRhdGFbcm93UHRyICsgMl07XG4gICAgICAgIGFscGhhWzFdID0gZiAqIGRhdGFbcm93UHRyICsgMl07XG4gICAgICAgIGFscGhhWzJdID0gYyAqIGRhdGFbcm93UHRyICsgNl07XG4gICAgICAgIGFscGhhWzNdID0gZiAqIGRhdGFbcm93UHRyICsgNl07XG4gICAgICAgIGJldGFbMF0gPSBiICogZGF0YVtyb3dQdHIgKyAxXSArIGQgKiBkYXRhW3Jvd1B0ciArIDNdICsgZSAqIGRhdGFbcm93UHRyICsgNV0gKyBnICogZGF0YVtyb3dQdHIgKyA3XTtcbiAgICAgICAgYmV0YVsxXSA9IGQgKiBkYXRhW3Jvd1B0ciArIDFdIC0gZyAqIGRhdGFbcm93UHRyICsgM10gLSBiICogZGF0YVtyb3dQdHIgKyA1XSAtIGUgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICBiZXRhWzJdID0gZSAqIGRhdGFbcm93UHRyICsgMV0gLSBiICogZGF0YVtyb3dQdHIgKyAzXSArIGcgKiBkYXRhW3Jvd1B0ciArIDVdICsgZCAqIGRhdGFbcm93UHRyICsgN107XG4gICAgICAgIGJldGFbM10gPSBnICogZGF0YVtyb3dQdHIgKyAxXSAtIGUgKiBkYXRhW3Jvd1B0ciArIDNdICsgZCAqIGRhdGFbcm93UHRyICsgNV0gLSBiICogZGF0YVtyb3dQdHIgKyA3XTtcbiAgICAgICAgdGhldGFbMF0gPSBhICogKGRhdGFbcm93UHRyICsgMF0gKyBkYXRhW3Jvd1B0ciArIDRdKTtcbiAgICAgICAgdGhldGFbM10gPSBhICogKGRhdGFbcm93UHRyICsgMF0gLSBkYXRhW3Jvd1B0ciArIDRdKTtcbiAgICAgICAgdGhldGFbMV0gPSBhbHBoYVswXSArIGFscGhhWzNdO1xuICAgICAgICB0aGV0YVsyXSA9IGFscGhhWzFdIC0gYWxwaGFbMl07XG4gICAgICAgIGdhbW1hWzBdID0gdGhldGFbMF0gKyB0aGV0YVsxXTtcbiAgICAgICAgZ2FtbWFbMV0gPSB0aGV0YVszXSArIHRoZXRhWzJdO1xuICAgICAgICBnYW1tYVsyXSA9IHRoZXRhWzNdIC0gdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzNdID0gdGhldGFbMF0gLSB0aGV0YVsxXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyAwXSA9IGdhbW1hWzBdICsgYmV0YVswXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyAxXSA9IGdhbW1hWzFdICsgYmV0YVsxXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyAyXSA9IGdhbW1hWzJdICsgYmV0YVsyXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyAzXSA9IGdhbW1hWzNdICsgYmV0YVszXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyA0XSA9IGdhbW1hWzNdIC0gYmV0YVszXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyA1XSA9IGdhbW1hWzJdIC0gYmV0YVsyXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyA2XSA9IGdhbW1hWzFdIC0gYmV0YVsxXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyA3XSA9IGdhbW1hWzBdIC0gYmV0YVswXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IDg7ICsrY29sdW1uKSB7XG4gICAgICAgIGFscGhhWzBdID0gYyAqIGRhdGFbMTYgKyBjb2x1bW5dO1xuICAgICAgICBhbHBoYVsxXSA9IGYgKiBkYXRhWzE2ICsgY29sdW1uXTtcbiAgICAgICAgYWxwaGFbMl0gPSBjICogZGF0YVs0OCArIGNvbHVtbl07XG4gICAgICAgIGFscGhhWzNdID0gZiAqIGRhdGFbNDggKyBjb2x1bW5dO1xuICAgICAgICBiZXRhWzBdID0gYiAqIGRhdGFbOCArIGNvbHVtbl0gKyBkICogZGF0YVsyNCArIGNvbHVtbl0gKyBlICogZGF0YVs0MCArIGNvbHVtbl0gKyBnICogZGF0YVs1NiArIGNvbHVtbl07XG4gICAgICAgIGJldGFbMV0gPSBkICogZGF0YVs4ICsgY29sdW1uXSAtIGcgKiBkYXRhWzI0ICsgY29sdW1uXSAtIGIgKiBkYXRhWzQwICsgY29sdW1uXSAtIGUgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgYmV0YVsyXSA9IGUgKiBkYXRhWzggKyBjb2x1bW5dIC0gYiAqIGRhdGFbMjQgKyBjb2x1bW5dICsgZyAqIGRhdGFbNDAgKyBjb2x1bW5dICsgZCAqIGRhdGFbNTYgKyBjb2x1bW5dO1xuICAgICAgICBiZXRhWzNdID0gZyAqIGRhdGFbOCArIGNvbHVtbl0gLSBlICogZGF0YVsyNCArIGNvbHVtbl0gKyBkICogZGF0YVs0MCArIGNvbHVtbl0gLSBiICogZGF0YVs1NiArIGNvbHVtbl07XG4gICAgICAgIHRoZXRhWzBdID0gYSAqIChkYXRhW2NvbHVtbl0gKyBkYXRhWzMyICsgY29sdW1uXSk7XG4gICAgICAgIHRoZXRhWzNdID0gYSAqIChkYXRhW2NvbHVtbl0gLSBkYXRhWzMyICsgY29sdW1uXSk7XG4gICAgICAgIHRoZXRhWzFdID0gYWxwaGFbMF0gKyBhbHBoYVszXTtcbiAgICAgICAgdGhldGFbMl0gPSBhbHBoYVsxXSAtIGFscGhhWzJdO1xuICAgICAgICBnYW1tYVswXSA9IHRoZXRhWzBdICsgdGhldGFbMV07XG4gICAgICAgIGdhbW1hWzFdID0gdGhldGFbM10gKyB0aGV0YVsyXTtcbiAgICAgICAgZ2FtbWFbMl0gPSB0aGV0YVszXSAtIHRoZXRhWzJdO1xuICAgICAgICBnYW1tYVszXSA9IHRoZXRhWzBdIC0gdGhldGFbMV07XG4gICAgICAgIGRhdGFbMCArIGNvbHVtbl0gPSBnYW1tYVswXSArIGJldGFbMF07XG4gICAgICAgIGRhdGFbOCArIGNvbHVtbl0gPSBnYW1tYVsxXSArIGJldGFbMV07XG4gICAgICAgIGRhdGFbMTYgKyBjb2x1bW5dID0gZ2FtbWFbMl0gKyBiZXRhWzJdO1xuICAgICAgICBkYXRhWzI0ICsgY29sdW1uXSA9IGdhbW1hWzNdICsgYmV0YVszXTtcbiAgICAgICAgZGF0YVszMiArIGNvbHVtbl0gPSBnYW1tYVszXSAtIGJldGFbM107XG4gICAgICAgIGRhdGFbNDAgKyBjb2x1bW5dID0gZ2FtbWFbMl0gLSBiZXRhWzJdO1xuICAgICAgICBkYXRhWzQ4ICsgY29sdW1uXSA9IGdhbW1hWzFdIC0gYmV0YVsxXTtcbiAgICAgICAgZGF0YVs1NiArIGNvbHVtbl0gPSBnYW1tYVswXSAtIGJldGFbMF07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNzYzcwOUludmVyc2UoZGF0YSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgIHZhciB5ID0gZGF0YVswXVtpXTtcbiAgICAgICAgdmFyIGNiID0gZGF0YVsxXVtpXTtcbiAgICAgICAgdmFyIGNyID0gZGF0YVsyXVtpXTtcbiAgICAgICAgZGF0YVswXVtpXSA9IHkgKyAxLjU3NDcgKiBjcjtcbiAgICAgICAgZGF0YVsxXVtpXSA9IHkgLSAwLjE4NzMgKiBjYiAtIDAuNDY4MiAqIGNyO1xuICAgICAgICBkYXRhWzJdW2ldID0geSArIDEuODU1NiAqIGNiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VG9IYWxmKHNyYywgZHN0LCBpZHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICBkc3RbaWR4ICsgaV0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQodG9MaW5lYXIoc3JjW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvTGluZWFyKGZsb2F0KSB7XG4gICAgICBpZiAoZmxvYXQgPD0gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zaWduKGZsb2F0KSAqIE1hdGgucG93KE1hdGguYWJzKGZsb2F0KSwgMi4yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpZ24oZmxvYXQpICogTWF0aC5wb3cobG9nQmFzZSwgTWF0aC5hYnMoZmxvYXQpIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NSQVcoaW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhpbmZvLmFycmF5LmJ1ZmZlciwgaW5mby5vZmZzZXQudmFsdWUsIGluZm8uc2l6ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NSTEUoaW5mbykge1xuICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLnZpZXdlci5idWZmZXIuc2xpY2UoaW5mby5vZmZzZXQudmFsdWUsIGluZm8ub2Zmc2V0LnZhbHVlICsgaW5mby5zaXplKTtcbiAgICAgIHZhciByYXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShkZWNvZGVSdW5MZW5ndGgoY29tcHJlc3NlZCkpO1xuICAgICAgdmFyIHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHJhd0J1ZmZlci5sZW5ndGgpO1xuICAgICAgcHJlZGljdG9yKHJhd0J1ZmZlcik7XG4gICAgICBpbnRlcmxlYXZlU2NhbGFyKHJhd0J1ZmZlciwgdG1wQnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NaSVAoaW5mbykge1xuICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKGluZm8ub2Zmc2V0LnZhbHVlLCBpbmZvLm9mZnNldC52YWx1ZSArIGluZm8uc2l6ZSk7XG4gICAgICB2YXIgcmF3QnVmZmVyID0gdW56bGliU3luYyhjb21wcmVzc2VkKTtcbiAgICAgIHZhciB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShyYXdCdWZmZXIubGVuZ3RoKTtcbiAgICAgIHByZWRpY3RvcihyYXdCdWZmZXIpO1xuICAgICAgaW50ZXJsZWF2ZVNjYWxhcihyYXdCdWZmZXIsIHRtcEJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzUElaKGluZm8pIHtcbiAgICAgIHZhciBpbkRhdGFWaWV3ID0gaW5mby52aWV3ZXI7XG4gICAgICB2YXIgaW5PZmZzZXQgPSB7IHZhbHVlOiBpbmZvLm9mZnNldC52YWx1ZSB9O1xuICAgICAgdmFyIG91dEJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShpbmZvLndpZHRoICogaW5mby5zY2FubGluZUJsb2NrU2l6ZSAqIChpbmZvLmNoYW5uZWxzICogaW5mby50eXBlKSk7XG4gICAgICB2YXIgYml0bWFwID0gbmV3IFVpbnQ4QXJyYXkoQklUTUFQX1NJWkUpO1xuICAgICAgdmFyIG91dEJ1ZmZlckVuZCA9IDA7XG4gICAgICB2YXIgcGl6Q2hhbm5lbERhdGEgPSBuZXcgQXJyYXkoaW5mby5jaGFubmVscyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZm8uY2hhbm5lbHM7IGkrKykge1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXSA9IHt9O1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcInN0YXJ0XCJdID0gb3V0QnVmZmVyRW5kO1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcImVuZFwiXSA9IHBpekNoYW5uZWxEYXRhW2ldW1wic3RhcnRcIl07XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wibnhcIl0gPSBpbmZvLndpZHRoO1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcIm55XCJdID0gaW5mby5saW5lcztcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJzaXplXCJdID0gaW5mby50eXBlO1xuICAgICAgICBvdXRCdWZmZXJFbmQgKz0gcGl6Q2hhbm5lbERhdGFbaV0ubnggKiBwaXpDaGFubmVsRGF0YVtpXS5ueSAqIHBpekNoYW5uZWxEYXRhW2ldLnNpemU7XG4gICAgICB9XG4gICAgICB2YXIgbWluTm9uWmVybyA9IHBhcnNlVWludDE2KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIHZhciBtYXhOb25aZXJvID0gcGFyc2VVaW50MTYoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaWYgKG1heE5vblplcm8gPj0gQklUTUFQX1NJWkUpIHtcbiAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCBQSVpfQ09NUFJFU1NJT04gQklUTUFQX1NJWkVcIjtcbiAgICAgIH1cbiAgICAgIGlmIChtaW5Ob25aZXJvIDw9IG1heE5vblplcm8pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhOb25aZXJvIC0gbWluTm9uWmVybyArIDE7IGkrKykge1xuICAgICAgICAgIGJpdG1hcFtpICsgbWluTm9uWmVyb10gPSBwYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGx1dCA9IG5ldyBVaW50MTZBcnJheShVU0hPUlRfUkFOR0UpO1xuICAgICAgdmFyIG1heFZhbHVlID0gcmV2ZXJzZUx1dEZyb21CaXRtYXAoYml0bWFwLCBsdXQpO1xuICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlVWludDMyKGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIGh1ZlVuY29tcHJlc3MoaW5mby5hcnJheSwgaW5EYXRhVmlldywgaW5PZmZzZXQsIGxlbmd0aCwgb3V0QnVmZmVyLCBvdXRCdWZmZXJFbmQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZvLmNoYW5uZWxzOyArK2kpIHtcbiAgICAgICAgdmFyIGNkID0gcGl6Q2hhbm5lbERhdGFbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGl6Q2hhbm5lbERhdGFbaV0uc2l6ZTsgKytqKSB7XG4gICAgICAgICAgd2F2MkRlY29kZShvdXRCdWZmZXIsIGNkLnN0YXJ0ICsgaiwgY2QubngsIGNkLnNpemUsIGNkLm55LCBjZC5ueCAqIGNkLnNpemUsIG1heFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXBwbHlMdXQobHV0LCBvdXRCdWZmZXIsIG91dEJ1ZmZlckVuZCk7XG4gICAgICB2YXIgdG1wT2Zmc2V0MiA9IDA7XG4gICAgICB2YXIgdG1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkob3V0QnVmZmVyLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaW5mby5saW5lczsgeSsrKSB7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgaW5mby5jaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgdmFyIGNkID0gcGl6Q2hhbm5lbERhdGFbY107XG4gICAgICAgICAgdmFyIG4gPSBjZC5ueCAqIGNkLnNpemU7XG4gICAgICAgICAgdmFyIGNwID0gbmV3IFVpbnQ4QXJyYXkob3V0QnVmZmVyLmJ1ZmZlciwgY2QuZW5kICogSU5UMTZfU0laRSwgbiAqIElOVDE2X1NJWkUpO1xuICAgICAgICAgIHRtcEJ1ZmZlci5zZXQoY3AsIHRtcE9mZnNldDIpO1xuICAgICAgICAgIHRtcE9mZnNldDIgKz0gbiAqIElOVDE2X1NJWkU7XG4gICAgICAgICAgY2QuZW5kICs9IG47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NQWFIoaW5mbykge1xuICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKGluZm8ub2Zmc2V0LnZhbHVlLCBpbmZvLm9mZnNldC52YWx1ZSArIGluZm8uc2l6ZSk7XG4gICAgICB2YXIgcmF3QnVmZmVyID0gdW56bGliU3luYyhjb21wcmVzc2VkKTtcbiAgICAgIGNvbnN0IHN6ID0gaW5mby5saW5lcyAqIGluZm8uY2hhbm5lbHMgKiBpbmZvLndpZHRoO1xuICAgICAgY29uc3QgdG1wQnVmZmVyID0gaW5mby50eXBlID09IDEgPyBuZXcgVWludDE2QXJyYXkoc3opIDogbmV3IFVpbnQzMkFycmF5KHN6KTtcbiAgICAgIGxldCB0bXBCdWZmZXJFbmQgPSAwO1xuICAgICAgbGV0IHdyaXRlUHRyID0gMDtcbiAgICAgIGNvbnN0IHB0ciA9IG5ldyBBcnJheSg0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaW5mby5saW5lczsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgaW5mby5jaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgbGV0IHBpeGVsID0gMDtcbiAgICAgICAgICBzd2l0Y2ggKGluZm8udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBwdHJbMF0gPSB0bXBCdWZmZXJFbmQ7XG4gICAgICAgICAgICAgIHB0clsxXSA9IHB0clswXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIHRtcEJ1ZmZlckVuZCA9IHB0clsxXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5mby53aWR0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IHJhd0J1ZmZlcltwdHJbMF0rK10gPDwgOCB8IHJhd0J1ZmZlcltwdHJbMV0rK107XG4gICAgICAgICAgICAgICAgcGl4ZWwgKz0gZGlmZjtcbiAgICAgICAgICAgICAgICB0bXBCdWZmZXJbd3JpdGVQdHJdID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgd3JpdGVQdHIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcHRyWzBdID0gdG1wQnVmZmVyRW5kO1xuICAgICAgICAgICAgICBwdHJbMV0gPSBwdHJbMF0gKyBpbmZvLndpZHRoO1xuICAgICAgICAgICAgICBwdHJbMl0gPSBwdHJbMV0gKyBpbmZvLndpZHRoO1xuICAgICAgICAgICAgICB0bXBCdWZmZXJFbmQgPSBwdHJbMl0gKyBpbmZvLndpZHRoO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZm8ud2lkdGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSByYXdCdWZmZXJbcHRyWzBdKytdIDw8IDI0IHwgcmF3QnVmZmVyW3B0clsxXSsrXSA8PCAxNiB8IHJhd0J1ZmZlcltwdHJbMl0rK10gPDwgODtcbiAgICAgICAgICAgICAgICBwaXhlbCArPSBkaWZmO1xuICAgICAgICAgICAgICAgIHRtcEJ1ZmZlclt3cml0ZVB0cl0gPSBwaXhlbDtcbiAgICAgICAgICAgICAgICB3cml0ZVB0cisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc0RXQShpbmZvKSB7XG4gICAgICB2YXIgaW5EYXRhVmlldyA9IGluZm8udmlld2VyO1xuICAgICAgdmFyIGluT2Zmc2V0ID0geyB2YWx1ZTogaW5mby5vZmZzZXQudmFsdWUgfTtcbiAgICAgIHZhciBvdXRCdWZmZXIgPSBuZXcgVWludDhBcnJheShpbmZvLndpZHRoICogaW5mby5saW5lcyAqIChpbmZvLmNoYW5uZWxzICogaW5mby50eXBlICogSU5UMTZfU0laRSkpO1xuICAgICAgdmFyIGR3YUhlYWRlciA9IHtcbiAgICAgICAgdmVyc2lvbjogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHVua25vd25VbmNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgdW5rbm93bkNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgYWNDb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIGRjQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBybGVDb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHJsZVVuY29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBybGVSYXdTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgdG90YWxBY1VuY29tcHJlc3NlZENvdW50OiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgdG90YWxEY1VuY29tcHJlc3NlZENvdW50OiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgYWNDb21wcmVzc2lvbjogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldClcbiAgICAgIH07XG4gICAgICBpZiAoZHdhSGVhZGVyLnZlcnNpb24gPCAyKSB7XG4gICAgICAgIHRocm93IFwiRVhSTG9hZGVyLnBhcnNlOiBcIiArIEVYUkhlYWRlci5jb21wcmVzc2lvbiArIFwiIHZlcnNpb24gXCIgKyBkd2FIZWFkZXIudmVyc2lvbiArIFwiIGlzIHVuc3VwcG9ydGVkXCI7XG4gICAgICB9XG4gICAgICB2YXIgY2hhbm5lbFJ1bGVzID0gbmV3IEFycmF5KCk7XG4gICAgICB2YXIgcnVsZVNpemUgPSBwYXJzZVVpbnQxNihpbkRhdGFWaWV3LCBpbk9mZnNldCkgLSBJTlQxNl9TSVpFO1xuICAgICAgd2hpbGUgKHJ1bGVTaXplID4gMCkge1xuICAgICAgICB2YXIgbmFtZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoaW5EYXRhVmlldy5idWZmZXIsIGluT2Zmc2V0KTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VVaW50OChpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiA9IHZhbHVlID4+IDIgJiAzO1xuICAgICAgICB2YXIgY3NjID0gKHZhbHVlID4+IDQpIC0gMTtcbiAgICAgICAgdmFyIGluZGV4ID0gbmV3IEludDhBcnJheShbY3NjXSlbMF07XG4gICAgICAgIHZhciB0eXBlID0gcGFyc2VVaW50OChpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICAgIGNoYW5uZWxSdWxlcy5wdXNoKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgY29tcHJlc3Npb25cbiAgICAgICAgfSk7XG4gICAgICAgIHJ1bGVTaXplIC09IG5hbWUubGVuZ3RoICsgMztcbiAgICAgIH1cbiAgICAgIHZhciBjaGFubmVscyA9IEVYUkhlYWRlci5jaGFubmVscztcbiAgICAgIHZhciBjaGFubmVsRGF0YSA9IG5ldyBBcnJheShpbmZvLmNoYW5uZWxzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby5jaGFubmVsczsgKytpKSB7XG4gICAgICAgIHZhciBjZCA9IGNoYW5uZWxEYXRhW2ldID0ge307XG4gICAgICAgIHZhciBjaGFubmVsID0gY2hhbm5lbHNbaV07XG4gICAgICAgIGNkLm5hbWUgPSBjaGFubmVsLm5hbWU7XG4gICAgICAgIGNkLmNvbXByZXNzaW9uID0gVU5LTk9XTjtcbiAgICAgICAgY2QuZGVjb2RlZCA9IGZhbHNlO1xuICAgICAgICBjZC50eXBlID0gY2hhbm5lbC5waXhlbFR5cGU7XG4gICAgICAgIGNkLnBMaW5lYXIgPSBjaGFubmVsLnBMaW5lYXI7XG4gICAgICAgIGNkLndpZHRoID0gaW5mby53aWR0aDtcbiAgICAgICAgY2QuaGVpZ2h0ID0gaW5mby5saW5lcztcbiAgICAgIH1cbiAgICAgIHZhciBjc2NTZXQgPSB7XG4gICAgICAgIGlkeDogbmV3IEFycmF5KDMpXG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgb2Zmc2V0MiA9IDA7IG9mZnNldDIgPCBpbmZvLmNoYW5uZWxzOyArK29mZnNldDIpIHtcbiAgICAgICAgdmFyIGNkID0gY2hhbm5lbERhdGFbb2Zmc2V0Ml07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbFJ1bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIHJ1bGUgPSBjaGFubmVsUnVsZXNbaV07XG4gICAgICAgICAgaWYgKGNkLm5hbWUgPT0gcnVsZS5uYW1lKSB7XG4gICAgICAgICAgICBjZC5jb21wcmVzc2lvbiA9IHJ1bGUuY29tcHJlc3Npb247XG4gICAgICAgICAgICBpZiAocnVsZS5pbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIGNzY1NldC5pZHhbcnVsZS5pbmRleF0gPSBvZmZzZXQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2Qub2Zmc2V0ID0gb2Zmc2V0MjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkd2FIZWFkZXIuYWNDb21wcmVzc2VkU2l6ZSA+IDApIHtcbiAgICAgICAgc3dpdGNoIChkd2FIZWFkZXIuYWNDb21wcmVzc2lvbikge1xuICAgICAgICAgIGNhc2UgU1RBVElDX0hVRkZNQU46XG4gICAgICAgICAgICB2YXIgYWNCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudCk7XG4gICAgICAgICAgICBodWZVbmNvbXByZXNzKFxuICAgICAgICAgICAgICBpbmZvLmFycmF5LFxuICAgICAgICAgICAgICBpbkRhdGFWaWV3LFxuICAgICAgICAgICAgICBpbk9mZnNldCxcbiAgICAgICAgICAgICAgZHdhSGVhZGVyLmFjQ29tcHJlc3NlZFNpemUsXG4gICAgICAgICAgICAgIGFjQnVmZmVyLFxuICAgICAgICAgICAgICBkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBERUZMQVRFOlxuICAgICAgICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKGluT2Zmc2V0LnZhbHVlLCBpbk9mZnNldC52YWx1ZSArIGR3YUhlYWRlci50b3RhbEFjVW5jb21wcmVzc2VkQ291bnQpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgICAgICAgdmFyIGFjQnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIGluT2Zmc2V0LnZhbHVlICs9IGR3YUhlYWRlci50b3RhbEFjVW5jb21wcmVzc2VkQ291bnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGR3YUhlYWRlci5kY0NvbXByZXNzZWRTaXplID4gMCkge1xuICAgICAgICB2YXIgemxpYkluZm8gPSB7XG4gICAgICAgICAgYXJyYXk6IGluZm8uYXJyYXksXG4gICAgICAgICAgb2Zmc2V0OiBpbk9mZnNldCxcbiAgICAgICAgICBzaXplOiBkd2FIZWFkZXIuZGNDb21wcmVzc2VkU2l6ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGNCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkodW5jb21wcmVzc1pJUCh6bGliSW5mbykuYnVmZmVyKTtcbiAgICAgICAgaW5PZmZzZXQudmFsdWUgKz0gZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemU7XG4gICAgICB9XG4gICAgICBpZiAoZHdhSGVhZGVyLnJsZVJhd1NpemUgPiAwKSB7XG4gICAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbk9mZnNldC52YWx1ZSwgaW5PZmZzZXQudmFsdWUgKyBkd2FIZWFkZXIucmxlQ29tcHJlc3NlZFNpemUpO1xuICAgICAgICB2YXIgZGF0YSA9IHVuemxpYlN5bmMoY29tcHJlc3NlZCk7XG4gICAgICAgIHZhciBybGVCdWZmZXIgPSBkZWNvZGVSdW5MZW5ndGgoZGF0YS5idWZmZXIpO1xuICAgICAgICBpbk9mZnNldC52YWx1ZSArPSBkd2FIZWFkZXIucmxlQ29tcHJlc3NlZFNpemU7XG4gICAgICB9XG4gICAgICB2YXIgb3V0QnVmZmVyRW5kID0gMDtcbiAgICAgIHZhciByb3dPZmZzZXRzID0gbmV3IEFycmF5KGNoYW5uZWxEYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd09mZnNldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcm93T2Zmc2V0c1tpXSA9IG5ldyBBcnJheSgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyArK3kpIHtcbiAgICAgICAgZm9yICh2YXIgY2hhbiA9IDA7IGNoYW4gPCBjaGFubmVsRGF0YS5sZW5ndGg7ICsrY2hhbikge1xuICAgICAgICAgIHJvd09mZnNldHNbY2hhbl0ucHVzaChvdXRCdWZmZXJFbmQpO1xuICAgICAgICAgIG91dEJ1ZmZlckVuZCArPSBjaGFubmVsRGF0YVtjaGFuXS53aWR0aCAqIGluZm8udHlwZSAqIElOVDE2X1NJWkU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxvc3N5RGN0RGVjb2RlKGNzY1NldCwgcm93T2Zmc2V0cywgY2hhbm5lbERhdGEsIGFjQnVmZmVyLCBkY0J1ZmZlciwgb3V0QnVmZmVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNkID0gY2hhbm5lbERhdGFbaV07XG4gICAgICAgIGlmIChjZC5kZWNvZGVkKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzd2l0Y2ggKGNkLmNvbXByZXNzaW9uKSB7XG4gICAgICAgICAgY2FzZSBSTEU6XG4gICAgICAgICAgICB2YXIgcm93ID0gMDtcbiAgICAgICAgICAgIHZhciBybGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyArK3kpIHtcbiAgICAgICAgICAgICAgdmFyIHJvd09mZnNldEJ5dGVzID0gcm93T2Zmc2V0c1tpXVtyb3ddO1xuICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNkLndpZHRoOyArK3gpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBieXRlID0gMDsgYnl0ZSA8IElOVDE2X1NJWkUgKiBjZC50eXBlOyArK2J5dGUpIHtcbiAgICAgICAgICAgICAgICAgIG91dEJ1ZmZlcltyb3dPZmZzZXRCeXRlcysrXSA9IHJsZUJ1ZmZlcltybGVPZmZzZXQgKyBieXRlICogY2Qud2lkdGggKiBjZC5oZWlnaHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBybGVPZmZzZXQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByb3crKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTE9TU1lfRENUOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBcIkVYUkxvYWRlci5wYXJzZTogdW5zdXBwb3J0ZWQgY2hhbm5lbCBjb21wcmVzc2lvblwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KG91dEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpIHtcbiAgICAgIHZhciB1aW50QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMik7XG4gICAgICB2YXIgZW5kT2Zmc2V0ID0gMDtcbiAgICAgIHdoaWxlICh1aW50QnVmZmVyW29mZnNldDIudmFsdWUgKyBlbmRPZmZzZXRdICE9IDApIHtcbiAgICAgICAgZW5kT2Zmc2V0ICs9IDE7XG4gICAgICB9XG4gICAgICB2YXIgc3RyaW5nVmFsdWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodWludEJ1ZmZlci5zbGljZShvZmZzZXQyLnZhbHVlLCBvZmZzZXQyLnZhbHVlICsgZW5kT2Zmc2V0KSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIGVuZE9mZnNldCArIDE7XG4gICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlRml4ZWRMZW5ndGhTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Miwgc2l6ZSkge1xuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcjIpLnNsaWNlKG9mZnNldDIudmFsdWUsIG9mZnNldDIudmFsdWUgKyBzaXplKSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIHNpemU7XG4gICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlUmF0aW9uYWwoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4ID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeSA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZWNvZGUoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHkgPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgSW50MzIgPSBkYXRhVmlldy5nZXRJbnQzMihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgSU5UMzJfU0laRTtcbiAgICAgIHJldHVybiBJbnQzMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBVaW50MzIgPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDMyX1NJWkU7XG4gICAgICByZXR1cm4gVWludDMyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQ4QXJyYXkodUludDhBcnJheTIsIG9mZnNldDIpIHtcbiAgICAgIHZhciBVaW50OCA9IHVJbnQ4QXJyYXkyW29mZnNldDIudmFsdWVdO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBJTlQ4X1NJWkU7XG4gICAgICByZXR1cm4gVWludDg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDgoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBVaW50OCA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldDIudmFsdWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBJTlQ4X1NJWkU7XG4gICAgICByZXR1cm4gVWludDg7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlSW50NjQgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgbGV0IGludDtcbiAgICAgIGlmIChcImdldEJpZ0ludDY0XCIgaW4gRGF0YVZpZXcucHJvdG90eXBlKSB7XG4gICAgICAgIGludCA9IE51bWJlcihkYXRhVmlldy5nZXRCaWdJbnQ2NChvZmZzZXQyLnZhbHVlLCB0cnVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnQgPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0Mi52YWx1ZSArIDQsIHRydWUpICsgTnVtYmVyKGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQyLnZhbHVlLCB0cnVlKSA8PCAzMik7XG4gICAgICB9XG4gICAgICBvZmZzZXQyLnZhbHVlICs9IFVMT05HX1NJWkU7XG4gICAgICByZXR1cm4gaW50O1xuICAgIH07XG4gICAgZnVuY3Rpb24gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgZmxvYXQgPSBkYXRhVmlldy5nZXRGbG9hdDMyKG9mZnNldDIudmFsdWUsIHRydWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBGTE9BVDMyX1NJWkU7XG4gICAgICByZXR1cm4gZmxvYXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHJldHVybiBEYXRhVXRpbHMudG9IYWxmRmxvYXQocGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZUZsb2F0MTYoYmluYXJ5KSB7XG4gICAgICB2YXIgZXhwb25lbnQgPSAoYmluYXJ5ICYgMzE3NDQpID4+IDEwLCBmcmFjdGlvbiA9IGJpbmFyeSAmIDEwMjM7XG4gICAgICByZXR1cm4gKGJpbmFyeSA+PiAxNSA/IC0xIDogMSkgKiAoZXhwb25lbnQgPyBleHBvbmVudCA9PT0gMzEgPyBmcmFjdGlvbiA/IE5hTiA6IEluZmluaXR5IDogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNSkgKiAoMSArIGZyYWN0aW9uIC8gMTAyNCkgOiA2MTAzNTE1NjI1ZS0xNCAqIChmcmFjdGlvbiAvIDEwMjQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVaW50MTYoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBVaW50MTYgPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlICs9IElOVDE2X1NJWkU7XG4gICAgICByZXR1cm4gVWludDE2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUZsb2F0MTYoYnVmZmVyMiwgb2Zmc2V0Mikge1xuICAgICAgcmV0dXJuIGRlY29kZUZsb2F0MTYocGFyc2VVaW50MTYoYnVmZmVyMiwgb2Zmc2V0MikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNobGlzdChkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0Miwgc2l6ZSkge1xuICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0Mi52YWx1ZTtcbiAgICAgIHZhciBjaGFubmVscyA9IFtdO1xuICAgICAgd2hpbGUgKG9mZnNldDIudmFsdWUgPCBzdGFydE9mZnNldCArIHNpemUgLSAxKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhidWZmZXIyLCBvZmZzZXQyKTtcbiAgICAgICAgdmFyIHBpeGVsVHlwZSA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICB2YXIgcExpbmVhciA9IHBhcnNlVWludDgoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICBvZmZzZXQyLnZhbHVlICs9IDM7XG4gICAgICAgIHZhciB4U2FtcGxpbmcgPSBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgICAgdmFyIHlTYW1wbGluZyA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICBjaGFubmVscy5wdXNoKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBpeGVsVHlwZSxcbiAgICAgICAgICBwTGluZWFyLFxuICAgICAgICAgIHhTYW1wbGluZyxcbiAgICAgICAgICB5U2FtcGxpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBvZmZzZXQyLnZhbHVlICs9IDE7XG4gICAgICByZXR1cm4gY2hhbm5lbHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ2hyb21hdGljaXRpZXMoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciByZWRYID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciByZWRZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciBncmVlblggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIGdyZWVuWSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgYmx1ZVggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIGJsdWVZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB3aGl0ZVggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHdoaXRlWSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWRYLFxuICAgICAgICByZWRZLFxuICAgICAgICBncmVlblgsXG4gICAgICAgIGdyZWVuWSxcbiAgICAgICAgYmx1ZVgsXG4gICAgICAgIGJsdWVZLFxuICAgICAgICB3aGl0ZVgsXG4gICAgICAgIHdoaXRlWVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VDb21wcmVzc2lvbihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIGNvbXByZXNzaW9uQ29kZXMgPSBbXG4gICAgICAgIFwiTk9fQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJSTEVfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJaSVBTX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiWklQX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiUElaX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiUFhSMjRfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJCNDRfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJCNDRBX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiRFdBQV9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkRXQUJfQ09NUFJFU1NJT05cIlxuICAgICAgXTtcbiAgICAgIHZhciBjb21wcmVzc2lvbiA9IHBhcnNlVWludDgoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIGNvbXByZXNzaW9uQ29kZXNbY29tcHJlc3Npb25dO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUJveDJpKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgeE1pbiA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5TWluID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHhNYXggPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeU1heCA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiB7IHhNaW4sIHlNaW4sIHhNYXgsIHlNYXggfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VMaW5lT3JkZXIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBsaW5lT3JkZXJzID0gW1wiSU5DUkVBU0lOR19ZXCJdO1xuICAgICAgdmFyIGxpbmVPcmRlciA9IHBhcnNlVWludDgoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIGxpbmVPcmRlcnNbbGluZU9yZGVyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VWMmYoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVjNmKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgeCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeiA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVZhbHVlKGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCB0eXBlLCBzaXplKSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcInN0cmluZ3ZlY3RvclwiIHx8IHR5cGUgPT09IFwiaWNjUHJvZmlsZVwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZpeGVkTGVuZ3RoU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIsIHNpemUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNobGlzdFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNobGlzdChkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0Miwgc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY2hyb21hdGljaXRpZXNcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VDaHJvbWF0aWNpdGllcyhkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tcHJlc3Npb25cIikge1xuICAgICAgICByZXR1cm4gcGFyc2VDb21wcmVzc2lvbihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYm94MmlcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VCb3gyaShkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibGluZU9yZGVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTGluZU9yZGVyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJmbG9hdFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInYyZlwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVYyZihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidjNmXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVjNmKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJpbnRcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicmF0aW9uYWxcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VSYXRpb25hbChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidGltZWNvZGVcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VUaW1lY29kZShkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicHJldmlld1wiKSB7XG4gICAgICAgIG9mZnNldDIudmFsdWUgKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIFwic2tpcHBlZFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBzaXplO1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0Mikge1xuICAgICAgY29uc3QgRVhSSGVhZGVyMiA9IHt9O1xuICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQzMigwLCB0cnVlKSAhPSAyMDAwMDYzMCkge1xuICAgICAgICB0aHJvdyBcIlRIUkVFLkVYUkxvYWRlcjogcHJvdmlkZWQgZmlsZSBkb2Vzbid0IGFwcGVhciB0byBiZSBpbiBPcGVuRVhSIGZvcm1hdC5cIjtcbiAgICAgIH1cbiAgICAgIEVYUkhlYWRlcjIudmVyc2lvbiA9IGRhdGFWaWV3LmdldFVpbnQ4KDQpO1xuICAgICAgY29uc3Qgc3BlYyA9IGRhdGFWaWV3LmdldFVpbnQ4KDUpO1xuICAgICAgRVhSSGVhZGVyMi5zcGVjID0ge1xuICAgICAgICBzaW5nbGVUaWxlOiAhIShzcGVjICYgMiksXG4gICAgICAgIGxvbmdOYW1lOiAhIShzcGVjICYgNCksXG4gICAgICAgIGRlZXBGb3JtYXQ6ICEhKHNwZWMgJiA4KSxcbiAgICAgICAgbXVsdGlQYXJ0OiAhIShzcGVjICYgMTYpXG4gICAgICB9O1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IDg7XG4gICAgICB2YXIga2VlcFJlYWRpbmcgPSB0cnVlO1xuICAgICAgd2hpbGUgKGtlZXBSZWFkaW5nKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhidWZmZXIyLCBvZmZzZXQyKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT0gMCkge1xuICAgICAgICAgIGtlZXBSZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZVR5cGUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVTaXplID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVWYWx1ZSA9IHBhcnNlVmFsdWUoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIsIGF0dHJpYnV0ZVR5cGUsIGF0dHJpYnV0ZVNpemUpO1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVYUkxvYWRlci5wYXJzZTogc2tpcHBlZCB1bmtub3duIGhlYWRlciBhdHRyaWJ1dGUgdHlwZSAnJHthdHRyaWJ1dGVUeXBlfScuYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEVYUkhlYWRlcjJbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgoc3BlYyAmIH40KSAhPSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFWFJIZWFkZXI6XCIsIEVYUkhlYWRlcjIpO1xuICAgICAgICB0aHJvdyBcIlRIUkVFLkVYUkxvYWRlcjogcHJvdmlkZWQgZmlsZSBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gRVhSSGVhZGVyMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0dXBEZWNvZGVyKEVYUkhlYWRlcjIsIGRhdGFWaWV3LCB1SW50OEFycmF5Miwgb2Zmc2V0Miwgb3V0cHV0VHlwZSkge1xuICAgICAgY29uc3QgRVhSRGVjb2RlcjIgPSB7XG4gICAgICAgIHNpemU6IDAsXG4gICAgICAgIHZpZXdlcjogZGF0YVZpZXcsXG4gICAgICAgIGFycmF5OiB1SW50OEFycmF5MixcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQyLFxuICAgICAgICB3aWR0aDogRVhSSGVhZGVyMi5kYXRhV2luZG93LnhNYXggLSBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueE1pbiArIDEsXG4gICAgICAgIGhlaWdodDogRVhSSGVhZGVyMi5kYXRhV2luZG93LnlNYXggLSBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueU1pbiArIDEsXG4gICAgICAgIGNoYW5uZWxzOiBFWFJIZWFkZXIyLmNoYW5uZWxzLmxlbmd0aCxcbiAgICAgICAgYnl0ZXNQZXJMaW5lOiBudWxsLFxuICAgICAgICBsaW5lczogbnVsbCxcbiAgICAgICAgaW5wdXRTaXplOiBudWxsLFxuICAgICAgICB0eXBlOiBFWFJIZWFkZXIyLmNoYW5uZWxzWzBdLnBpeGVsVHlwZSxcbiAgICAgICAgdW5jb21wcmVzczogbnVsbCxcbiAgICAgICAgZ2V0dGVyOiBudWxsLFxuICAgICAgICBmb3JtYXQ6IG51bGwsXG4gICAgICAgIFtoYXNDb2xvclNwYWNlID8gXCJjb2xvclNwYWNlXCIgOiBcImVuY29kaW5nXCJdOiBudWxsXG4gICAgICB9O1xuICAgICAgc3dpdGNoIChFWFJIZWFkZXIyLmNvbXByZXNzaW9uKSB7XG4gICAgICAgIGNhc2UgXCJOT19DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1JBVztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJMRV9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1JMRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlpJUFNfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NaSVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJaSVBfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE2O1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzWklQO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUElaX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAzMjtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1BJWjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBYUjI0X0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxNjtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1BYUjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRXQUFfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDMyO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzRFdBO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFdBQl9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMjU2O1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzRFdBO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IFwiRVhSTG9hZGVyLnBhcnNlOiBcIiArIEVYUkhlYWRlcjIuY29tcHJlc3Npb24gKyBcIiBpcyB1bnN1cHBvcnRlZFwiO1xuICAgICAgfVxuICAgICAgRVhSRGVjb2RlcjIuc2NhbmxpbmVCbG9ja1NpemUgPSBFWFJEZWNvZGVyMi5saW5lcztcbiAgICAgIGlmIChFWFJEZWNvZGVyMi50eXBlID09IDEpIHtcbiAgICAgICAgc3dpdGNoIChvdXRwdXRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBwYXJzZUZsb2F0MTY7XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5pbnB1dFNpemUgPSBJTlQxNl9TSVpFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuZ2V0dGVyID0gcGFyc2VVaW50MTY7XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5pbnB1dFNpemUgPSBJTlQxNl9TSVpFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRVhSRGVjb2RlcjIudHlwZSA9PSAyKSB7XG4gICAgICAgIHN3aXRjaCAob3V0cHV0VHlwZSkge1xuICAgICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuZ2V0dGVyID0gcGFyc2VGbG9hdDMyO1xuICAgICAgICAgICAgRVhSRGVjb2RlcjIuaW5wdXRTaXplID0gRkxPQVQzMl9TSVpFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuZ2V0dGVyID0gZGVjb2RlRmxvYXQzMjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IEZMT0FUMzJfU0laRTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IHVuc3VwcG9ydGVkIHBpeGVsVHlwZSBcIiArIEVYUkRlY29kZXIyLnR5cGUgKyBcIiBmb3IgXCIgKyBFWFJIZWFkZXIyLmNvbXByZXNzaW9uICsgXCIuXCI7XG4gICAgICB9XG4gICAgICBFWFJEZWNvZGVyMi5ibG9ja0NvdW50ID0gKEVYUkhlYWRlcjIuZGF0YVdpbmRvdy55TWF4ICsgMSkgLyBFWFJEZWNvZGVyMi5zY2FubGluZUJsb2NrU2l6ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRVhSRGVjb2RlcjIuYmxvY2tDb3VudDsgaSsrKVxuICAgICAgICBwYXJzZUludDY0KGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzID0gRVhSRGVjb2RlcjIuY2hhbm5lbHMgPT0gMyA/IDQgOiBFWFJEZWNvZGVyMi5jaGFubmVscztcbiAgICAgIGNvbnN0IHNpemUgPSBFWFJEZWNvZGVyMi53aWR0aCAqIEVYUkRlY29kZXIyLmhlaWdodCAqIEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzO1xuICAgICAgc3dpdGNoIChvdXRwdXRUeXBlKSB7XG4gICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmJ5dGVBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgaWYgKEVYUkRlY29kZXIyLmNoYW5uZWxzIDwgRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMpXG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5ieXRlQXJyYXkuZmlsbCgxLCAwLCBzaXplKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmJ5dGVBcnJheSA9IG5ldyBVaW50MTZBcnJheShzaXplKTtcbiAgICAgICAgICBpZiAoRVhSRGVjb2RlcjIuY2hhbm5lbHMgPCBFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscylcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmJ5dGVBcnJheS5maWxsKDE1MzYwLCAwLCBzaXplKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuRVhSTG9hZGVyOiB1bnN1cHBvcnRlZCB0eXBlOiBcIiwgb3V0cHV0VHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBFWFJEZWNvZGVyMi5ieXRlc1BlckxpbmUgPSBFWFJEZWNvZGVyMi53aWR0aCAqIEVYUkRlY29kZXIyLmlucHV0U2l6ZSAqIEVYUkRlY29kZXIyLmNoYW5uZWxzO1xuICAgICAgaWYgKEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzID09IDQpXG4gICAgICAgIEVYUkRlY29kZXIyLmZvcm1hdCA9IFJHQkFGb3JtYXQ7XG4gICAgICBlbHNlXG4gICAgICAgIEVYUkRlY29kZXIyLmZvcm1hdCA9IFJlZEZvcm1hdDtcbiAgICAgIGlmIChoYXNDb2xvclNwYWNlKVxuICAgICAgICBFWFJEZWNvZGVyMi5jb2xvclNwYWNlID0gXCJzcmdiLWxpbmVhclwiO1xuICAgICAgZWxzZVxuICAgICAgICBFWFJEZWNvZGVyMi5lbmNvZGluZyA9IDNlMztcbiAgICAgIHJldHVybiBFWFJEZWNvZGVyMjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyRGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBjb25zdCB1SW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBvZmZzZXQgPSB7IHZhbHVlOiAwIH07XG4gICAgY29uc3QgRVhSSGVhZGVyID0gcGFyc2VIZWFkZXIoYnVmZmVyRGF0YVZpZXcsIGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBjb25zdCBFWFJEZWNvZGVyID0gc2V0dXBEZWNvZGVyKEVYUkhlYWRlciwgYnVmZmVyRGF0YVZpZXcsIHVJbnQ4QXJyYXksIG9mZnNldCwgdGhpcy50eXBlKTtcbiAgICBjb25zdCB0bXBPZmZzZXQgPSB7IHZhbHVlOiAwIH07XG4gICAgY29uc3QgY2hhbm5lbE9mZnNldHMgPSB7IFI6IDAsIEc6IDEsIEI6IDIsIEE6IDMsIFk6IDAgfTtcbiAgICBmb3IgKGxldCBzY2FubGluZUJsb2NrSWR4ID0gMDsgc2NhbmxpbmVCbG9ja0lkeCA8IEVYUkRlY29kZXIuaGVpZ2h0IC8gRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTsgc2NhbmxpbmVCbG9ja0lkeCsrKSB7XG4gICAgICBjb25zdCBsaW5lID0gcGFyc2VVaW50MzIoYnVmZmVyRGF0YVZpZXcsIG9mZnNldCk7XG4gICAgICBFWFJEZWNvZGVyLnNpemUgPSBwYXJzZVVpbnQzMihidWZmZXJEYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgIEVYUkRlY29kZXIubGluZXMgPSBsaW5lICsgRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZSA+IEVYUkRlY29kZXIuaGVpZ2h0ID8gRVhSRGVjb2Rlci5oZWlnaHQgLSBsaW5lIDogRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTtcbiAgICAgIGNvbnN0IGlzQ29tcHJlc3NlZCA9IEVYUkRlY29kZXIuc2l6ZSA8IEVYUkRlY29kZXIubGluZXMgKiBFWFJEZWNvZGVyLmJ5dGVzUGVyTGluZTtcbiAgICAgIGNvbnN0IHZpZXdlciA9IGlzQ29tcHJlc3NlZCA/IEVYUkRlY29kZXIudW5jb21wcmVzcyhFWFJEZWNvZGVyKSA6IHVuY29tcHJlc3NSQVcoRVhSRGVjb2Rlcik7XG4gICAgICBvZmZzZXQudmFsdWUgKz0gRVhSRGVjb2Rlci5zaXplO1xuICAgICAgZm9yIChsZXQgbGluZV95ID0gMDsgbGluZV95IDwgRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTsgbGluZV95KyspIHtcbiAgICAgICAgY29uc3QgdHJ1ZV95ID0gbGluZV95ICsgc2NhbmxpbmVCbG9ja0lkeCAqIEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7XG4gICAgICAgIGlmICh0cnVlX3kgPj0gRVhSRGVjb2Rlci5oZWlnaHQpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZvciAobGV0IGNoYW5uZWxJRCA9IDA7IGNoYW5uZWxJRCA8IEVYUkRlY29kZXIuY2hhbm5lbHM7IGNoYW5uZWxJRCsrKSB7XG4gICAgICAgICAgY29uc3QgY09mZiA9IGNoYW5uZWxPZmZzZXRzW0VYUkhlYWRlci5jaGFubmVsc1tjaGFubmVsSURdLm5hbWVdO1xuICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgRVhSRGVjb2Rlci53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICB0bXBPZmZzZXQudmFsdWUgPSAobGluZV95ICogKEVYUkRlY29kZXIuY2hhbm5lbHMgKiBFWFJEZWNvZGVyLndpZHRoKSArIGNoYW5uZWxJRCAqIEVYUkRlY29kZXIud2lkdGggKyB4KSAqIEVYUkRlY29kZXIuaW5wdXRTaXplO1xuICAgICAgICAgICAgY29uc3Qgb3V0SW5kZXggPSAoRVhSRGVjb2Rlci5oZWlnaHQgLSAxIC0gdHJ1ZV95KSAqIChFWFJEZWNvZGVyLndpZHRoICogRVhSRGVjb2Rlci5vdXRwdXRDaGFubmVscykgKyB4ICogRVhSRGVjb2Rlci5vdXRwdXRDaGFubmVscyArIGNPZmY7XG4gICAgICAgICAgICBFWFJEZWNvZGVyLmJ5dGVBcnJheVtvdXRJbmRleF0gPSBFWFJEZWNvZGVyLmdldHRlcih2aWV3ZXIsIHRtcE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXI6IEVYUkhlYWRlcixcbiAgICAgIHdpZHRoOiBFWFJEZWNvZGVyLndpZHRoLFxuICAgICAgaGVpZ2h0OiBFWFJEZWNvZGVyLmhlaWdodCxcbiAgICAgIGRhdGE6IEVYUkRlY29kZXIuYnl0ZUFycmF5LFxuICAgICAgZm9ybWF0OiBFWFJEZWNvZGVyLmZvcm1hdCxcbiAgICAgIFtoYXNDb2xvclNwYWNlID8gXCJjb2xvclNwYWNlXCIgOiBcImVuY29kaW5nXCJdOiBFWFJEZWNvZGVyW2hhc0NvbG9yU3BhY2UgPyBcImNvbG9yU3BhY2VcIiA6IFwiZW5jb2RpbmdcIl0sXG4gICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICB9O1xuICB9XG4gIHNldERhdGFUeXBlKHZhbHVlKSB7XG4gICAgdGhpcy50eXBlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGZ1bmN0aW9uIG9uTG9hZENhbGxiYWNrKHRleHR1cmUsIHRleERhdGEpIHtcbiAgICAgIGlmIChoYXNDb2xvclNwYWNlKVxuICAgICAgICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSB0ZXhEYXRhLmNvbG9yU3BhY2U7XG4gICAgICBlbHNlXG4gICAgICAgIHRleHR1cmUuZW5jb2RpbmcgPSB0ZXhEYXRhLmVuY29kaW5nO1xuICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgICB0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG4gICAgICBpZiAob25Mb2FkKVxuICAgICAgICBvbkxvYWQodGV4dHVyZSwgdGV4RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5sb2FkKHVybCwgb25Mb2FkQ2FsbGJhY2ssIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuICB9XG59XG5leHBvcnQge1xuICBFWFJMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FWFJMb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOlsiVGV4dHVyZSIsIkRhdGFUZXh0dXJlTG9hZGVyIiwiSGFsZkZsb2F0VHlwZSIsIkZsb2F0VHlwZSIsIlJHQkFGb3JtYXQiLCJSZWRGb3JtYXQiLCJMaW5lYXJGaWx0ZXIiLCJEYXRhVXRpbHMiLCJ1bnpsaWJTeW5jIiwiaGFzQ29sb3JTcGFjZSIsIkVYUkxvYWRlciIsImNvbnN0cnVjdG9yIiwibWFuYWdlciIsInR5cGUiLCJwYXJzZSIsImJ1ZmZlciIsIlVTSE9SVF9SQU5HRSIsIkJJVE1BUF9TSVpFIiwiSFVGX0VOQ0JJVFMiLCJIVUZfREVDQklUUyIsIkhVRl9FTkNTSVpFIiwiSFVGX0RFQ1NJWkUiLCJIVUZfREVDTUFTSyIsIk5CSVRTIiwiQV9PRkZTRVQiLCJNT0RfTUFTSyIsIlNIT1JUX1pFUk9DT0RFX1JVTiIsIkxPTkdfWkVST0NPREVfUlVOIiwiU0hPUlRFU1RfTE9OR19SVU4iLCJVTE9OR19TSVpFIiwiRkxPQVQzMl9TSVpFIiwiSU5UMzJfU0laRSIsIklOVDE2X1NJWkUiLCJJTlQ4X1NJWkUiLCJTVEFUSUNfSFVGRk1BTiIsIkRFRkxBVEUiLCJVTktOT1dOIiwiTE9TU1lfRENUIiwiUkxFIiwibG9nQmFzZSIsIk1hdGgiLCJwb3ciLCJyZXZlcnNlTHV0RnJvbUJpdG1hcCIsImJpdG1hcCIsImx1dCIsImsiLCJpIiwibiIsImh1ZkNsZWFyRGVjVGFibGUiLCJoZGVjIiwibGVuIiwibGl0IiwicCIsImdldEJpdHNSZXR1cm4iLCJsIiwiYyIsImxjIiwiZ2V0Qml0cyIsIm5CaXRzIiwidUludDhBcnJheTIiLCJpbk9mZnNldCIsInBhcnNlVWludDhBcnJheSIsImh1ZlRhYmxlQnVmZmVyIiwiQXJyYXkiLCJodWZDYW5vbmljYWxDb2RlVGFibGUiLCJoY29kZSIsIm5jIiwiaHVmVW5wYWNrRW5jVGFibGUiLCJpbkRhdGFWaWV3IiwibmkiLCJpbSIsImlNIiwidmFsdWUiLCJ6ZXJ1biIsImh1Zkxlbmd0aCIsImNvZGUiLCJodWZDb2RlIiwiaHVmQnVpbGREZWNUYWJsZSIsImhkZWNvZCIsInBsIiwicGxPZmZzZXQiLCJnZXRDaGFyUmV0dXJuIiwiZ2V0Q2hhciIsImdldENvZGVSZXR1cm4iLCJnZXRDb2RlIiwicG8iLCJybGMiLCJvdXRCdWZmZXIiLCJvdXRCdWZmZXJPZmZzZXQiLCJvdXRCdWZmZXJFbmRPZmZzZXQiLCJjcyIsIlVpbnQ4QXJyYXkiLCJzIiwiVUludDE2IiwiSW50MTYiLCJyZWYiLCJ3ZGVjMTRSZXR1cm4iLCJhIiwiYiIsIndkZWMxNCIsImgiLCJscyIsImhzIiwiaGkiLCJhaSIsImFzIiwiYnMiLCJ3ZGVjMTYiLCJtIiwiZCIsImJiIiwiYWEiLCJ3YXYyRGVjb2RlIiwiYnVmZmVyMiIsImoiLCJueCIsIm94IiwibnkiLCJveSIsIm14IiwidzE0IiwicDIiLCJweSIsImV5Iiwib3kxIiwib3kyIiwib3gxIiwib3gyIiwiaTAwIiwiaTAxIiwiaTEwIiwiaTExIiwicHgiLCJleCIsInAwMSIsInAxMCIsInAxMSIsImh1ZkRlY29kZSIsImVuY29kaW5nVGFibGUiLCJkZWNvZGluZ1RhYmxlIiwibm8iLCJvdXRPZmZzZXQiLCJpbk9mZnNldEVuZCIsInRydW5jIiwiaW5kZXgiLCJodWZVbmNvbXByZXNzIiwibkNvbXByZXNzZWQiLCJuUmF3IiwiaW5pdGlhbEluT2Zmc2V0IiwicGFyc2VVaW50MzIiLCJmcmVxIiwiYXBwbHlMdXQiLCJkYXRhIiwibkRhdGEiLCJwcmVkaWN0b3IiLCJzb3VyY2UiLCJ0IiwibGVuZ3RoIiwiaW50ZXJsZWF2ZVNjYWxhciIsIm91dCIsInQxIiwidDIiLCJmbG9vciIsInN0b3AiLCJkZWNvZGVSdW5MZW5ndGgiLCJzaXplIiwiYnl0ZUxlbmd0aCIsInJlYWRlciIsIkRhdGFWaWV3IiwiZ2V0SW50OCIsImNvdW50IiwicHVzaCIsImdldFVpbnQ4IiwibG9zc3lEY3REZWNvZGUiLCJjc2NTZXQiLCJyb3dQdHJzIiwiY2hhbm5lbERhdGEiLCJhY0J1ZmZlciIsImRjQnVmZmVyIiwiZGF0YVZpZXciLCJ3aWR0aCIsImlkeCIsImhlaWdodCIsIm51bUNvbXAiLCJudW1GdWxsQmxvY2tzWCIsIm51bUJsb2Nrc1giLCJjZWlsIiwibnVtQmxvY2tzWSIsImxlZnRvdmVyWCIsImxlZnRvdmVyWSIsImN1cnJBY0NvbXAiLCJjdXJyRGNDb21wIiwiZGN0RGF0YSIsImhhbGZaaWdCbG9jayIsInJvd0Jsb2NrIiwicm93T2Zmc2V0cyIsImNvbXAyIiwiRmxvYXQzMkFycmF5IiwiVWludDE2QXJyYXkiLCJibG9ja3kiLCJtYXhZIiwibWF4WCIsImJsb2NreCIsImZpbGwiLCJ1blJsZUFDIiwidW5aaWdaYWciLCJkY3RJbnZlcnNlIiwiY3NjNzA5SW52ZXJzZSIsImNvbnZlcnRUb0hhbGYiLCJvZmZzZXQyIiwidHlwZTIiLCJ5MiIsInNyYyIsInNldFVpbnQxNiIsIm9mZnNldDMiLCJ4MiIsImhhbGZSb3ciLCJjb21wIiwiZGVjb2RlZCIsInkiLCJ4IiwiZ2V0VWludDE2Iiwic2V0RmxvYXQzMiIsImRlY29kZUZsb2F0MTYiLCJhY1ZhbHVlIiwiZGN0Q29tcCIsImRzdCIsImNvcyIsImUiLCJmIiwiZyIsImFscGhhIiwiYmV0YSIsInRoZXRhIiwiZ2FtbWEiLCJyb3ciLCJyb3dQdHIiLCJjb2x1bW4iLCJjYiIsImNyIiwidG9IYWxmRmxvYXQiLCJ0b0xpbmVhciIsImZsb2F0Iiwic2lnbiIsImFicyIsInVuY29tcHJlc3NSQVciLCJpbmZvIiwiYXJyYXkiLCJvZmZzZXQiLCJ1bmNvbXByZXNzUkxFIiwiY29tcHJlc3NlZCIsInZpZXdlciIsInNsaWNlIiwicmF3QnVmZmVyIiwidG1wQnVmZmVyIiwidW5jb21wcmVzc1pJUCIsInVuY29tcHJlc3NQSVoiLCJzY2FubGluZUJsb2NrU2l6ZSIsImNoYW5uZWxzIiwib3V0QnVmZmVyRW5kIiwicGl6Q2hhbm5lbERhdGEiLCJsaW5lcyIsIm1pbk5vblplcm8iLCJwYXJzZVVpbnQxNiIsIm1heE5vblplcm8iLCJwYXJzZVVpbnQ4IiwibWF4VmFsdWUiLCJjZCIsInN0YXJ0IiwidG1wT2Zmc2V0MiIsImNwIiwiZW5kIiwic2V0IiwidW5jb21wcmVzc1BYUiIsInN6IiwiVWludDMyQXJyYXkiLCJ0bXBCdWZmZXJFbmQiLCJ3cml0ZVB0ciIsInB0ciIsInBpeGVsIiwiZGlmZiIsInVuY29tcHJlc3NEV0EiLCJkd2FIZWFkZXIiLCJ2ZXJzaW9uIiwicGFyc2VJbnQ2NCIsInVua25vd25VbmNvbXByZXNzZWRTaXplIiwidW5rbm93bkNvbXByZXNzZWRTaXplIiwiYWNDb21wcmVzc2VkU2l6ZSIsImRjQ29tcHJlc3NlZFNpemUiLCJybGVDb21wcmVzc2VkU2l6ZSIsInJsZVVuY29tcHJlc3NlZFNpemUiLCJybGVSYXdTaXplIiwidG90YWxBY1VuY29tcHJlc3NlZENvdW50IiwidG90YWxEY1VuY29tcHJlc3NlZENvdW50IiwiYWNDb21wcmVzc2lvbiIsIkVYUkhlYWRlciIsImNvbXByZXNzaW9uIiwiY2hhbm5lbFJ1bGVzIiwicnVsZVNpemUiLCJuYW1lIiwicGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyIsImNzYyIsIkludDhBcnJheSIsImNoYW5uZWwiLCJwaXhlbFR5cGUiLCJwTGluZWFyIiwicnVsZSIsInpsaWJJbmZvIiwicmxlQnVmZmVyIiwiY2hhbiIsInJsZU9mZnNldCIsInJvd09mZnNldEJ5dGVzIiwiYnl0ZSIsInVpbnRCdWZmZXIiLCJlbmRPZmZzZXQiLCJzdHJpbmdWYWx1ZSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwicGFyc2VGaXhlZExlbmd0aFN0cmluZyIsInBhcnNlUmF0aW9uYWwiLCJwYXJzZUludDMyIiwicGFyc2VUaW1lY29kZSIsIkludDMyIiwiZ2V0SW50MzIiLCJVaW50MzIiLCJnZXRVaW50MzIiLCJVaW50OCIsImludCIsInByb3RvdHlwZSIsIk51bWJlciIsImdldEJpZ0ludDY0IiwicGFyc2VGbG9hdDMyIiwiZ2V0RmxvYXQzMiIsImRlY29kZUZsb2F0MzIiLCJiaW5hcnkiLCJleHBvbmVudCIsImZyYWN0aW9uIiwiTmFOIiwiSW5maW5pdHkiLCJVaW50MTYiLCJwYXJzZUZsb2F0MTYiLCJwYXJzZUNobGlzdCIsInN0YXJ0T2Zmc2V0IiwieFNhbXBsaW5nIiwieVNhbXBsaW5nIiwicGFyc2VDaHJvbWF0aWNpdGllcyIsInJlZFgiLCJyZWRZIiwiZ3JlZW5YIiwiZ3JlZW5ZIiwiYmx1ZVgiLCJibHVlWSIsIndoaXRlWCIsIndoaXRlWSIsInBhcnNlQ29tcHJlc3Npb24iLCJjb21wcmVzc2lvbkNvZGVzIiwicGFyc2VCb3gyaSIsInhNaW4iLCJ5TWluIiwieE1heCIsInlNYXgiLCJwYXJzZUxpbmVPcmRlciIsImxpbmVPcmRlcnMiLCJsaW5lT3JkZXIiLCJwYXJzZVYyZiIsInBhcnNlVjNmIiwieiIsInBhcnNlVmFsdWUiLCJwYXJzZUhlYWRlciIsIkVYUkhlYWRlcjIiLCJzcGVjIiwic2luZ2xlVGlsZSIsImxvbmdOYW1lIiwiZGVlcEZvcm1hdCIsIm11bHRpUGFydCIsImtlZXBSZWFkaW5nIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZVR5cGUiLCJhdHRyaWJ1dGVTaXplIiwiYXR0cmlidXRlVmFsdWUiLCJjb25zb2xlIiwid2FybiIsImVycm9yIiwic2V0dXBEZWNvZGVyIiwib3V0cHV0VHlwZSIsIkVYUkRlY29kZXIyIiwiZGF0YVdpbmRvdyIsImJ5dGVzUGVyTGluZSIsImlucHV0U2l6ZSIsInVuY29tcHJlc3MiLCJnZXR0ZXIiLCJmb3JtYXQiLCJibG9ja0NvdW50Iiwib3V0cHV0Q2hhbm5lbHMiLCJieXRlQXJyYXkiLCJjb2xvclNwYWNlIiwiZW5jb2RpbmciLCJidWZmZXJEYXRhVmlldyIsInVJbnQ4QXJyYXkiLCJFWFJEZWNvZGVyIiwidG1wT2Zmc2V0IiwiY2hhbm5lbE9mZnNldHMiLCJSIiwiRyIsIkIiLCJBIiwiWSIsInNjYW5saW5lQmxvY2tJZHgiLCJsaW5lIiwiaXNDb21wcmVzc2VkIiwibGluZV95IiwidHJ1ZV95IiwiY2hhbm5lbElEIiwiY09mZiIsIm91dEluZGV4IiwiaGVhZGVyIiwic2V0RGF0YVR5cGUiLCJsb2FkIiwidXJsIiwib25Mb2FkIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJvbkxvYWRDYWxsYmFjayIsInRleHR1cmUiLCJ0ZXhEYXRhIiwibWluRmlsdGVyIiwibWFnRmlsdGVyIiwiZ2VuZXJhdGVNaXBtYXBzIiwiZmxpcFkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n/* harmony import */ var _polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/LoaderUtils.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\");\n\n\n\n\nconst SRGBColorSpace = \"srgb\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst sRGBEncoding = 3001;\nconst LinearEncoding = 3e3;\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.dracoLoader = null;\n        this.ktx2Loader = null;\n        this.meshoptDecoder = null;\n        this.pluginCallbacks = [];\n        this.register(function(parser) {\n            return new GLTFMaterialsClearcoatExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsDispersionExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureBasisUExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureWebPExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureAVIFExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSheenExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsTransmissionExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsVolumeExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIorExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsEmissiveStrengthExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSpecularExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIridescenceExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsAnisotropyExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsBumpExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFLightsExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshoptCompression(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshGpuInstancing(parser);\n        });\n    }\n    load(url, onLoad, onProgress, onError) {\n        const scope = this;\n        let resourcePath;\n        if (this.resourcePath !== \"\") {\n            resourcePath = this.resourcePath;\n        } else if (this.path !== \"\") {\n            const relativeUrl = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(relativeUrl, this.path);\n        } else {\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n        }\n        this.manager.itemStart(url);\n        const _onError = function(e) {\n            if (onError) {\n                onError(e);\n            } else {\n                console.error(e);\n            }\n            scope.manager.itemError(url);\n            scope.manager.itemEnd(url);\n        };\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, function(data) {\n            try {\n                scope.parse(data, resourcePath, function(gltf) {\n                    onLoad(gltf);\n                    scope.manager.itemEnd(url);\n                }, _onError);\n            } catch (e) {\n                _onError(e);\n            }\n        }, onProgress, _onError);\n    }\n    setDRACOLoader(dracoLoader) {\n        this.dracoLoader = dracoLoader;\n        return this;\n    }\n    setDDSLoader() {\n        throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n    }\n    setKTX2Loader(ktx2Loader) {\n        this.ktx2Loader = ktx2Loader;\n        return this;\n    }\n    setMeshoptDecoder(meshoptDecoder) {\n        this.meshoptDecoder = meshoptDecoder;\n        return this;\n    }\n    register(callback) {\n        if (this.pluginCallbacks.indexOf(callback) === -1) {\n            this.pluginCallbacks.push(callback);\n        }\n        return this;\n    }\n    unregister(callback) {\n        if (this.pluginCallbacks.indexOf(callback) !== -1) {\n            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n        }\n        return this;\n    }\n    parse(data, path, onLoad, onError) {\n        let json;\n        const extensions = {};\n        const plugins = {};\n        if (typeof data === \"string\") {\n            json = JSON.parse(data);\n        } else if (data instanceof ArrayBuffer) {\n            const magic = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4)));\n            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n                try {\n                    extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n                } catch (error) {\n                    if (onError) onError(error);\n                    return;\n                }\n                json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n            } else {\n                json = JSON.parse((0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data)));\n            }\n        } else {\n            json = data;\n        }\n        if (json.asset === void 0 || json.asset.version[0] < 2) {\n            if (onError) onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n            return;\n        }\n        const parser = new GLTFParser(json, {\n            path: path || this.resourcePath || \"\",\n            crossOrigin: this.crossOrigin,\n            requestHeader: this.requestHeader,\n            manager: this.manager,\n            ktx2Loader: this.ktx2Loader,\n            meshoptDecoder: this.meshoptDecoder\n        });\n        parser.fileLoader.setRequestHeader(this.requestHeader);\n        for(let i = 0; i < this.pluginCallbacks.length; i++){\n            const plugin = this.pluginCallbacks[i](parser);\n            if (!plugin.name) console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n            plugins[plugin.name] = plugin;\n            extensions[plugin.name] = true;\n        }\n        if (json.extensionsUsed) {\n            for(let i = 0; i < json.extensionsUsed.length; ++i){\n                const extensionName = json.extensionsUsed[i];\n                const extensionsRequired = json.extensionsRequired || [];\n                switch(extensionName){\n                    case EXTENSIONS.KHR_MATERIALS_UNLIT:\n                        extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n                        break;\n                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n                        extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n                        break;\n                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n                        extensions[extensionName] = new GLTFTextureTransformExtension();\n                        break;\n                    case EXTENSIONS.KHR_MESH_QUANTIZATION:\n                        extensions[extensionName] = new GLTFMeshQuantizationExtension();\n                        break;\n                    default:\n                        if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n                            console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n                        }\n                }\n            }\n        }\n        parser.setExtensions(extensions);\n        parser.setPlugins(plugins);\n        parser.parse(onLoad, onError);\n    }\n    parseAsync(data, path) {\n        const scope = this;\n        return new Promise(function(resolve, reject) {\n            scope.parse(data, path, resolve, reject);\n        });\n    }\n}\nfunction GLTFRegistry() {\n    let objects = {};\n    return {\n        get: function(key) {\n            return objects[key];\n        },\n        add: function(key, object) {\n            objects[key] = object;\n        },\n        remove: function(key) {\n            delete objects[key];\n        },\n        removeAll: function() {\n            objects = {};\n        }\n    };\n}\nconst EXTENSIONS = {\n    KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n    KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n    KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n    KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n    KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n    KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n    KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n    KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n    KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n    KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n    KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n    KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n    KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n    KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n    KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n    KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n    KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n    EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n    EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n    EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n    EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n    EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n        this.cache = {\n            refs: {},\n            uses: {}\n        };\n    }\n    _markDefs() {\n        const parser = this.parser;\n        const nodeDefs = this.parser.json.nodes || [];\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n                parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n            }\n        }\n    }\n    _loadLight(lightIndex) {\n        const parser = this.parser;\n        const cacheKey = \"light:\" + lightIndex;\n        let dependency = parser.cache.get(cacheKey);\n        if (dependency) return dependency;\n        const json = parser.json;\n        const extensions = json.extensions && json.extensions[this.name] || {};\n        const lightDefs = extensions.lights || [];\n        const lightDef = lightDefs[lightIndex];\n        let lightNode;\n        const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n        if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);\n        const range = lightDef.range !== void 0 ? lightDef.range : 0;\n        switch(lightDef.type){\n            case \"directional\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            case \"point\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n                lightNode.distance = range;\n                break;\n            case \"spot\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n                lightNode.distance = range;\n                lightDef.spot = lightDef.spot || {};\n                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n                lightNode.angle = lightDef.spot.outerConeAngle;\n                lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            default:\n                throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n        }\n        lightNode.position.set(0, 0, 0);\n        lightNode.decay = 2;\n        assignExtrasToUserData(lightNode, lightDef);\n        if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;\n        lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n        dependency = Promise.resolve(lightNode);\n        parser.cache.add(cacheKey, dependency);\n        return dependency;\n    }\n    getDependency(type, index) {\n        if (type !== \"light\") return;\n        return this._loadLight(index);\n    }\n    createNodeAttachment(nodeIndex) {\n        const self2 = this;\n        const parser = this.parser;\n        const json = parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n        const lightIndex = lightDef.light;\n        if (lightIndex === void 0) return null;\n        return this._loadLight(lightIndex).then(function(light) {\n            return parser._getNodeRef(self2.cache, lightIndex, light);\n        });\n    }\n}\nclass GLTFMaterialsUnlitExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n    }\n    extendParams(materialParams, materialDef, parser) {\n        const pending = [];\n        materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n        materialParams.opacity = 1;\n        const metallicRoughness = materialDef.pbrMetallicRoughness;\n        if (metallicRoughness) {\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n        if (emissiveStrength !== void 0) {\n            materialParams.emissiveIntensity = emissiveStrength;\n        }\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsClearcoatExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.clearcoatFactor !== void 0) {\n            materialParams.clearcoat = extension.clearcoatFactor;\n        }\n        if (extension.clearcoatTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n        }\n        if (extension.clearcoatRoughnessFactor !== void 0) {\n            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n        }\n        if (extension.clearcoatRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n        }\n        if (extension.clearcoatNormalTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n            if (extension.clearcoatNormalTexture.scale !== void 0) {\n                const scale = extension.clearcoatNormalTexture.scale;\n                materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsDispersionExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const extension = materialDef.extensions[this.name];\n        materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsIridescenceExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.iridescenceFactor !== void 0) {\n            materialParams.iridescence = extension.iridescenceFactor;\n        }\n        if (extension.iridescenceTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n        }\n        if (extension.iridescenceIor !== void 0) {\n            materialParams.iridescenceIOR = extension.iridescenceIor;\n        }\n        if (materialParams.iridescenceThicknessRange === void 0) {\n            materialParams.iridescenceThicknessRange = [\n                100,\n                400\n            ];\n        }\n        if (extension.iridescenceThicknessMinimum !== void 0) {\n            materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n        }\n        if (extension.iridescenceThicknessMaximum !== void 0) {\n            materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n        }\n        if (extension.iridescenceThicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsSheenExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n        materialParams.sheenRoughness = 0;\n        materialParams.sheen = 1;\n        const extension = materialDef.extensions[this.name];\n        if (extension.sheenColorFactor !== void 0) {\n            const colorFactor = extension.sheenColorFactor;\n            materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);\n        }\n        if (extension.sheenRoughnessFactor !== void 0) {\n            materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n        }\n        if (extension.sheenColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, SRGBColorSpace));\n        }\n        if (extension.sheenRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsTransmissionExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.transmissionFactor !== void 0) {\n            materialParams.transmission = extension.transmissionFactor;\n        }\n        if (extension.transmissionTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsVolumeExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n        if (extension.thicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n        }\n        materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n        const colorArray = extension.attenuationColor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsIorExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const extension = materialDef.extensions[this.name];\n        materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsSpecularExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n        if (extension.specularTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n        }\n        const colorArray = extension.specularColorFactor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n        if (extension.specularColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, SRGBColorSpace));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsBumpExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;\n        if (extension.bumpTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsAnisotropyExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.anisotropyStrength !== void 0) {\n            materialParams.anisotropy = extension.anisotropyStrength;\n        }\n        if (extension.anisotropyRotation !== void 0) {\n            materialParams.anisotropyRotation = extension.anisotropyRotation;\n        }\n        if (extension.anisotropyTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFTextureBasisUExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n    }\n    loadTexture(textureIndex) {\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[this.name];\n        const loader = parser.options.ktx2Loader;\n        if (!loader) {\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n            } else {\n                return null;\n            }\n        }\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n    }\n}\nclass GLTFTextureWebPExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFTextureAVIFExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFMeshoptCompression {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n        this.parser = parser;\n    }\n    loadBufferView(index) {\n        const json = this.parser.json;\n        const bufferView = json.bufferViews[index];\n        if (bufferView.extensions && bufferView.extensions[this.name]) {\n            const extensionDef = bufferView.extensions[this.name];\n            const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n            const decoder = this.parser.options.meshoptDecoder;\n            if (!decoder || !decoder.supported) {\n                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                    throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n                } else {\n                    return null;\n                }\n            }\n            return buffer.then(function(res) {\n                const byteOffset = extensionDef.byteOffset || 0;\n                const byteLength = extensionDef.byteLength || 0;\n                const count = extensionDef.count;\n                const stride = extensionDef.byteStride;\n                const source = new Uint8Array(res, byteOffset, byteLength);\n                if (decoder.decodeGltfBufferAsync) {\n                    return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n                        return res2.buffer;\n                    });\n                } else {\n                    return decoder.ready.then(function() {\n                        const result = new ArrayBuffer(count * stride);\n                        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n                        return result;\n                    });\n                }\n            });\n        } else {\n            return null;\n        }\n    }\n}\nclass GLTFMeshGpuInstancing {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n        this.parser = parser;\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n            return null;\n        }\n        const meshDef = json.meshes[nodeDef.mesh];\n        for (const primitive of meshDef.primitives){\n            if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n                return null;\n            }\n        }\n        const extensionDef = nodeDef.extensions[this.name];\n        const attributesDef = extensionDef.attributes;\n        const pending = [];\n        const attributes = {};\n        for(const key in attributesDef){\n            pending.push(this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor)=>{\n                attributes[key] = accessor;\n                return attributes[key];\n            }));\n        }\n        if (pending.length < 1) {\n            return null;\n        }\n        pending.push(this.parser.createNodeMesh(nodeIndex));\n        return Promise.all(pending).then((results)=>{\n            const nodeObject = results.pop();\n            const meshes = nodeObject.isGroup ? nodeObject.children : [\n                nodeObject\n            ];\n            const count = results[0].count;\n            const instancedMeshes = [];\n            for (const mesh of meshes){\n                const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n                const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n                const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n                for(let i = 0; i < count; i++){\n                    if (attributes.TRANSLATION) {\n                        p.fromBufferAttribute(attributes.TRANSLATION, i);\n                    }\n                    if (attributes.ROTATION) {\n                        q.fromBufferAttribute(attributes.ROTATION, i);\n                    }\n                    if (attributes.SCALE) {\n                        s.fromBufferAttribute(attributes.SCALE, i);\n                    }\n                    instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n                }\n                for(const attributeName in attributes){\n                    if (attributeName === \"_COLOR_0\") {\n                        const attr = attributes[attributeName];\n                        instancedMesh.instanceColor = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n                    } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n                        mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n                    }\n                }\n                three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n                this.parser.assignFinalMaterial(instancedMesh);\n                instancedMeshes.push(instancedMesh);\n            }\n            if (nodeObject.isGroup) {\n                nodeObject.clear();\n                nodeObject.add(...instancedMeshes);\n                return nodeObject;\n            }\n            return instancedMeshes[0];\n        });\n    }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 1313821514,\n    BIN: 5130562\n};\nclass GLTFBinaryExtension {\n    constructor(data){\n        this.name = EXTENSIONS.KHR_BINARY_GLTF;\n        this.content = null;\n        this.body = null;\n        const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n        this.header = {\n            magic: (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4))),\n            version: headerView.getUint32(4, true),\n            length: headerView.getUint32(8, true)\n        };\n        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n            throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n        } else if (this.header.version < 2) {\n            throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n        }\n        const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n        const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n        let chunkIndex = 0;\n        while(chunkIndex < chunkContentsLength){\n            const chunkLength = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            const chunkType = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n                const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n                this.content = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(contentArray);\n            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n                const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n                this.body = data.slice(byteOffset, byteOffset + chunkLength);\n            }\n            chunkIndex += chunkLength;\n        }\n        if (this.content === null) {\n            throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n        }\n    }\n}\nclass GLTFDracoMeshCompressionExtension {\n    constructor(json, dracoLoader){\n        if (!dracoLoader) {\n            throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n        }\n        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n        this.json = json;\n        this.dracoLoader = dracoLoader;\n        this.dracoLoader.preload();\n    }\n    decodePrimitive(primitive, parser) {\n        const json = this.json;\n        const dracoLoader = this.dracoLoader;\n        const bufferViewIndex = primitive.extensions[this.name].bufferView;\n        const gltfAttributeMap = primitive.extensions[this.name].attributes;\n        const threeAttributeMap = {};\n        const attributeNormalizedMap = {};\n        const attributeTypeMap = {};\n        for(const attributeName in gltfAttributeMap){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n        }\n        for(const attributeName in primitive.attributes){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            if (gltfAttributeMap[attributeName] !== void 0) {\n                const accessorDef = json.accessors[primitive.attributes[attributeName]];\n                const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n                attributeTypeMap[threeAttributeName] = componentType.name;\n                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n            }\n        }\n        return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n            return new Promise(function(resolve, reject) {\n                dracoLoader.decodeDracoFile(bufferView, function(geometry) {\n                    for(const attributeName in geometry.attributes){\n                        const attribute = geometry.attributes[attributeName];\n                        const normalized = attributeNormalizedMap[attributeName];\n                        if (normalized !== void 0) attribute.normalized = normalized;\n                    }\n                    resolve(geometry);\n                }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);\n            });\n        });\n    }\n}\nclass GLTFTextureTransformExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n    }\n    extendTexture(texture, transform) {\n        if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n            return texture;\n        }\n        texture = texture.clone();\n        if (transform.texCoord !== void 0) {\n            texture.channel = transform.texCoord;\n        }\n        if (transform.offset !== void 0) {\n            texture.offset.fromArray(transform.offset);\n        }\n        if (transform.rotation !== void 0) {\n            texture.rotation = transform.rotation;\n        }\n        if (transform.scale !== void 0) {\n            texture.repeat.fromArray(transform.scale);\n        }\n        texture.needsUpdate = true;\n        return texture;\n    }\n}\nclass GLTFMeshQuantizationExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n    }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){\n        super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    }\n    copySampleValue_(index) {\n        const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n        for(let i = 0; i !== valueSize; i++){\n            result[i] = values[offset + i];\n        }\n        return result;\n    }\n    interpolate_(i1, t0, t, t1) {\n        const result = this.resultBuffer;\n        const values = this.sampleValues;\n        const stride = this.valueSize;\n        const stride2 = stride * 2;\n        const stride3 = stride * 3;\n        const td = t1 - t0;\n        const p = (t - t0) / td;\n        const pp = p * p;\n        const ppp = pp * p;\n        const offset1 = i1 * stride3;\n        const offset0 = offset1 - stride3;\n        const s2 = -2 * ppp + 3 * pp;\n        const s3 = ppp - pp;\n        const s0 = 1 - s2;\n        const s1 = s3 - pp + p;\n        for(let i = 0; i !== stride; i++){\n            const p0 = values[offset0 + i + stride];\n            const m0 = values[offset0 + i + stride2] * td;\n            const p1 = values[offset1 + i + stride];\n            const m1 = values[offset1 + i] * td;\n            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n        }\n        return result;\n    }\n}\nconst _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n    interpolate_(i1, t0, t, t1) {\n        const result = super.interpolate_(i1, t0, t, t1);\n        _q.fromArray(result).normalize().toArray(result);\n        return result;\n    }\n}\nconst WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n    9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n    9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n    9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n    9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n    9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n    9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n    33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n    33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n    10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nconst ATTRIBUTES = {\n    POSITION: \"position\",\n    NORMAL: \"normal\",\n    TANGENT: \"tangent\",\n    // uv => uv1, 4 uv channels\n    // https://github.com/mrdoob/three.js/pull/25943\n    // https://github.com/mrdoob/three.js/pull/25788\n    ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 152 ? {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv1\",\n        TEXCOORD_2: \"uv2\",\n        TEXCOORD_3: \"uv3\"\n    } : {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv2\"\n    },\n    COLOR_0: \"color\",\n    WEIGHTS_0: \"skinWeight\",\n    JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n    scale: \"scale\",\n    translation: \"position\",\n    rotation: \"quaternion\",\n    weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n    CUBICSPLINE: void 0,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n    STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n    OPAQUE: \"OPAQUE\",\n    MASK: \"MASK\",\n    BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n    if (cache[\"DefaultMaterial\"] === void 0) {\n        cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: 16777215,\n            emissive: 0,\n            metalness: 1,\n            roughness: 1,\n            transparent: false,\n            depthTest: true,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n        });\n    }\n    return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    for(const name in objectDef.extensions){\n        if (knownExtensions[name] === void 0) {\n            object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n            object.userData.gltfExtensions[name] = objectDef.extensions[name];\n        }\n    }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== void 0) {\n        if (typeof gltfDef.extras === \"object\") {\n            Object.assign(object.userData, gltfDef.extras);\n        } else {\n            console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n        }\n    }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n    let hasMorphPosition = false;\n    let hasMorphNormal = false;\n    let hasMorphColor = false;\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (target.POSITION !== void 0) hasMorphPosition = true;\n        if (target.NORMAL !== void 0) hasMorphNormal = true;\n        if (target.COLOR_0 !== void 0) hasMorphColor = true;\n        if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\n    }\n    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\n    const pendingPositionAccessors = [];\n    const pendingNormalAccessors = [];\n    const pendingColorAccessors = [];\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (hasMorphPosition) {\n            const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n            pendingPositionAccessors.push(pendingAccessor);\n        }\n        if (hasMorphNormal) {\n            const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n            pendingNormalAccessors.push(pendingAccessor);\n        }\n        if (hasMorphColor) {\n            const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n            pendingColorAccessors.push(pendingAccessor);\n        }\n    }\n    return Promise.all([\n        Promise.all(pendingPositionAccessors),\n        Promise.all(pendingNormalAccessors),\n        Promise.all(pendingColorAccessors)\n    ]).then(function(accessors) {\n        const morphPositions = accessors[0];\n        const morphNormals = accessors[1];\n        const morphColors = accessors[2];\n        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n        if (hasMorphColor) geometry.morphAttributes.color = morphColors;\n        geometry.morphTargetsRelative = true;\n        return geometry;\n    });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n    if (meshDef.weights !== void 0) {\n        for(let i = 0, il = meshDef.weights.length; i < il; i++){\n            mesh.morphTargetInfluences[i] = meshDef.weights[i];\n        }\n    }\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n        const targetNames = meshDef.extras.targetNames;\n        if (mesh.morphTargetInfluences.length === targetNames.length) {\n            mesh.morphTargetDictionary = {};\n            for(let i = 0, il = targetNames.length; i < il; i++){\n                mesh.morphTargetDictionary[targetNames[i]] = i;\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n        }\n    }\n}\nfunction createPrimitiveKey(primitiveDef) {\n    let geometryKey;\n    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    if (dracoExtension) {\n        geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n    } else {\n        geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n    }\n    if (primitiveDef.targets !== void 0) {\n        for(let i = 0, il = primitiveDef.targets.length; i < il; i++){\n            geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n        }\n    }\n    return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n    let attributesKey = \"\";\n    const keys = Object.keys(attributes).sort();\n    for(let i = 0, il = keys.length; i < il; i++){\n        attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n    }\n    return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n    switch(constructor){\n        case Int8Array:\n            return 1 / 127;\n        case Uint8Array:\n            return 1 / 255;\n        case Int16Array:\n            return 1 / 32767;\n        case Uint16Array:\n            return 1 / 65535;\n        default:\n            throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n    }\n}\nfunction getImageURIMimeType(uri) {\n    if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return \"image/jpeg\";\n    if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return \"image/webp\";\n    return \"image/png\";\n}\nconst _identityMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n    constructor(json = {}, options = {}){\n        this.json = json;\n        this.extensions = {};\n        this.plugins = {};\n        this.options = options;\n        this.cache = new GLTFRegistry();\n        this.associations = /* @__PURE__ */ new Map();\n        this.primitiveCache = {};\n        this.nodeCache = {};\n        this.meshCache = {\n            refs: {},\n            uses: {}\n        };\n        this.cameraCache = {\n            refs: {},\n            uses: {}\n        };\n        this.lightCache = {\n            refs: {},\n            uses: {}\n        };\n        this.sourceCache = {};\n        this.textureCache = {};\n        this.nodeNamesUsed = {};\n        let isSafari = false;\n        let isFirefox = false;\n        let firefoxVersion = -1;\n        if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n            isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n            isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n            firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n        }\n        if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n        } else {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n        }\n        this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n        this.textureLoader.setRequestHeader(this.options.requestHeader);\n        this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n        this.fileLoader.setResponseType(\"arraybuffer\");\n        if (this.options.crossOrigin === \"use-credentials\") {\n            this.fileLoader.setWithCredentials(true);\n        }\n    }\n    setExtensions(extensions) {\n        this.extensions = extensions;\n    }\n    setPlugins(plugins) {\n        this.plugins = plugins;\n    }\n    parse(onLoad, onError) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        this.cache.removeAll();\n        this.nodeCache = {};\n        this._invokeAll(function(ext) {\n            return ext._markDefs && ext._markDefs();\n        });\n        Promise.all(this._invokeAll(function(ext) {\n            return ext.beforeRoot && ext.beforeRoot();\n        })).then(function() {\n            return Promise.all([\n                parser.getDependencies(\"scene\"),\n                parser.getDependencies(\"animation\"),\n                parser.getDependencies(\"camera\")\n            ]);\n        }).then(function(dependencies) {\n            const result = {\n                scene: dependencies[0][json.scene || 0],\n                scenes: dependencies[0],\n                animations: dependencies[1],\n                cameras: dependencies[2],\n                asset: json.asset,\n                parser,\n                userData: {}\n            };\n            addUnknownExtensionsToUserData(extensions, result, json);\n            assignExtrasToUserData(result, json);\n            return Promise.all(parser._invokeAll(function(ext) {\n                return ext.afterRoot && ext.afterRoot(result);\n            })).then(function() {\n                for (const scene of result.scenes){\n                    scene.updateMatrixWorld();\n                }\n                onLoad(result);\n            });\n        }).catch(onError);\n    }\n    /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */ _markDefs() {\n        const nodeDefs = this.json.nodes || [];\n        const skinDefs = this.json.skins || [];\n        const meshDefs = this.json.meshes || [];\n        for(let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++){\n            const joints = skinDefs[skinIndex].joints;\n            for(let i = 0, il = joints.length; i < il; i++){\n                nodeDefs[joints[i]].isBone = true;\n            }\n        }\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.mesh !== void 0) {\n                this._addNodeRef(this.meshCache, nodeDef.mesh);\n                if (nodeDef.skin !== void 0) {\n                    meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n                }\n            }\n            if (nodeDef.camera !== void 0) {\n                this._addNodeRef(this.cameraCache, nodeDef.camera);\n            }\n        }\n    }\n    /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */ _addNodeRef(cache, index) {\n        if (index === void 0) return;\n        if (cache.refs[index] === void 0) {\n            cache.refs[index] = cache.uses[index] = 0;\n        }\n        cache.refs[index]++;\n    }\n    /** Returns a reference to a shared resource, cloning it if necessary. */ _getNodeRef(cache, index, object) {\n        if (cache.refs[index] <= 1) return object;\n        const ref = object.clone();\n        const updateMappings = (original, clone)=>{\n            const mappings = this.associations.get(original);\n            if (mappings != null) {\n                this.associations.set(clone, mappings);\n            }\n            for (const [i, child] of original.children.entries()){\n                updateMappings(child, clone.children[i]);\n            }\n        };\n        updateMappings(object, ref);\n        ref.name += \"_instance_\" + cache.uses[index]++;\n        return ref;\n    }\n    _invokeOne(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.push(this);\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) return result;\n        }\n        return null;\n    }\n    _invokeAll(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.unshift(this);\n        const pending = [];\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) pending.push(result);\n        }\n        return pending;\n    }\n    /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */ getDependency(type, index) {\n        const cacheKey = type + \":\" + index;\n        let dependency = this.cache.get(cacheKey);\n        if (!dependency) {\n            switch(type){\n                case \"scene\":\n                    dependency = this.loadScene(index);\n                    break;\n                case \"node\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadNode && ext.loadNode(index);\n                    });\n                    break;\n                case \"mesh\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMesh && ext.loadMesh(index);\n                    });\n                    break;\n                case \"accessor\":\n                    dependency = this.loadAccessor(index);\n                    break;\n                case \"bufferView\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadBufferView && ext.loadBufferView(index);\n                    });\n                    break;\n                case \"buffer\":\n                    dependency = this.loadBuffer(index);\n                    break;\n                case \"material\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMaterial && ext.loadMaterial(index);\n                    });\n                    break;\n                case \"texture\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadTexture && ext.loadTexture(index);\n                    });\n                    break;\n                case \"skin\":\n                    dependency = this.loadSkin(index);\n                    break;\n                case \"animation\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadAnimation && ext.loadAnimation(index);\n                    });\n                    break;\n                case \"camera\":\n                    dependency = this.loadCamera(index);\n                    break;\n                default:\n                    dependency = this._invokeOne(function(ext) {\n                        return ext != this && ext.getDependency && ext.getDependency(type, index);\n                    });\n                    if (!dependency) {\n                        throw new Error(\"Unknown type: \" + type);\n                    }\n                    break;\n            }\n            this.cache.add(cacheKey, dependency);\n        }\n        return dependency;\n    }\n    /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */ getDependencies(type) {\n        let dependencies = this.cache.get(type);\n        if (!dependencies) {\n            const parser = this;\n            const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n            dependencies = Promise.all(defs.map(function(def, index) {\n                return parser.getDependency(type, index);\n            }));\n            this.cache.add(type, dependencies);\n        }\n        return dependencies;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBuffer(bufferIndex) {\n        const bufferDef = this.json.buffers[bufferIndex];\n        const loader = this.fileLoader;\n        if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n            throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n        }\n        if (bufferDef.uri === void 0 && bufferIndex === 0) {\n            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n        }\n        const options = this.options;\n        return new Promise(function(resolve, reject) {\n            loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n                reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n            });\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBufferView(bufferViewIndex) {\n        const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n        return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n            const byteLength = bufferViewDef.byteLength || 0;\n            const byteOffset = bufferViewDef.byteOffset || 0;\n            return buffer.slice(byteOffset, byteOffset + byteLength);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */ loadAccessor(accessorIndex) {\n        const parser = this;\n        const json = this.json;\n        const accessorDef = this.json.accessors[accessorIndex];\n        if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const normalized = accessorDef.normalized === true;\n            const array = new TypedArray(accessorDef.count * itemSize);\n            return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n        }\n        const pendingBufferViews = [];\n        if (accessorDef.bufferView !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n        } else {\n            pendingBufferViews.push(null);\n        }\n        if (accessorDef.sparse !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n        }\n        return Promise.all(pendingBufferViews).then(function(bufferViews) {\n            const bufferView = bufferViews[0];\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n            const itemBytes = elementBytes * itemSize;\n            const byteOffset = accessorDef.byteOffset || 0;\n            const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n            const normalized = accessorDef.normalized === true;\n            let array, bufferAttribute;\n            if (byteStride && byteStride !== itemBytes) {\n                const ibSlice = Math.floor(byteOffset / byteStride);\n                const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n                let ib = parser.cache.get(ibCacheKey);\n                if (!ib) {\n                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n                    ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n                    parser.cache.add(ibCacheKey, ib);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n            } else {\n                if (bufferView === null) {\n                    array = new TypedArray(accessorDef.count * itemSize);\n                } else {\n                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n            }\n            if (accessorDef.sparse !== void 0) {\n                const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n                const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n                const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n                const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n                const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n                const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n                if (bufferView !== null) {\n                    bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n                }\n                for(let i = 0, il = sparseIndices.length; i < il; i++){\n                    const index = sparseIndices[i];\n                    bufferAttribute.setX(index, sparseValues[i * itemSize]);\n                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n                    if (itemSize >= 5) throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n                }\n            }\n            return bufferAttribute;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */ loadTexture(textureIndex) {\n        const json = this.json;\n        const options = this.options;\n        const textureDef = json.textures[textureIndex];\n        const sourceIndex = textureDef.source;\n        const sourceDef = json.images[sourceIndex];\n        let loader = this.textureLoader;\n        if (sourceDef.uri) {\n            const handler = options.manager.getHandler(sourceDef.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.loadTextureImage(textureIndex, sourceIndex, loader);\n    }\n    loadTextureImage(textureIndex, sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const textureDef = json.textures[textureIndex];\n        const sourceDef = json.images[sourceIndex];\n        const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n        if (this.textureCache[cacheKey]) {\n            return this.textureCache[cacheKey];\n        }\n        const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n            texture.flipY = false;\n            texture.name = textureDef.name || sourceDef.name || \"\";\n            if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n                texture.name = sourceDef.uri;\n            }\n            const samplers = json.samplers || {};\n            const sampler = samplers[textureDef.sampler] || {};\n            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            parser.associations.set(texture, {\n                textures: textureIndex\n            });\n            return texture;\n        }).catch(function() {\n            return null;\n        });\n        this.textureCache[cacheKey] = promise;\n        return promise;\n    }\n    loadImageSource(sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const options = this.options;\n        if (this.sourceCache[sourceIndex] !== void 0) {\n            return this.sourceCache[sourceIndex].then((texture)=>texture.clone());\n        }\n        const sourceDef = json.images[sourceIndex];\n        const URL = self.URL || self.webkitURL;\n        let sourceURI = sourceDef.uri || \"\";\n        let isObjectURL = false;\n        if (sourceDef.bufferView !== void 0) {\n            sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n                isObjectURL = true;\n                const blob = new Blob([\n                    bufferView\n                ], {\n                    type: sourceDef.mimeType\n                });\n                sourceURI = URL.createObjectURL(blob);\n                return sourceURI;\n            });\n        } else if (sourceDef.uri === void 0) {\n            throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n        }\n        const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n            return new Promise(function(resolve, reject) {\n                let onLoad = resolve;\n                if (loader.isImageBitmapLoader === true) {\n                    onLoad = function(imageBitmap) {\n                        const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n                        texture.needsUpdate = true;\n                        resolve(texture);\n                    };\n                }\n                loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n            });\n        }).then(function(texture) {\n            if (isObjectURL === true) {\n                URL.revokeObjectURL(sourceURI);\n            }\n            assignExtrasToUserData(texture, sourceDef);\n            texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n            return texture;\n        }).catch(function(error) {\n            console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n            throw error;\n        });\n        this.sourceCache[sourceIndex] = promise;\n        return promise;\n    }\n    /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */ assignTexture(materialParams, mapName, mapDef, colorSpace) {\n        const parser = this;\n        return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n            if (!texture) return null;\n            if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n                texture = texture.clone();\n                texture.channel = mapDef.texCoord;\n            }\n            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n                const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n                if (transform) {\n                    const gltfReference = parser.associations.get(texture);\n                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n                    parser.associations.set(texture, gltfReference);\n                }\n            }\n            if (colorSpace !== void 0) {\n                if (typeof colorSpace === \"number\") colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n                if (\"colorSpace\" in texture) texture.colorSpace = colorSpace;\n                else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n            }\n            materialParams[mapName] = texture;\n            return texture;\n        });\n    }\n    /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */ assignFinalMaterial(mesh) {\n        const geometry = mesh.geometry;\n        let material = mesh.material;\n        const useDerivativeTangents = geometry.attributes.tangent === void 0;\n        const useVertexColors = geometry.attributes.color !== void 0;\n        const useFlatShading = geometry.attributes.normal === void 0;\n        if (mesh.isPoints) {\n            const cacheKey = \"PointsMaterial:\" + material.uuid;\n            let pointsMaterial = this.cache.get(cacheKey);\n            if (!pointsMaterial) {\n                pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n                pointsMaterial.color.copy(material.color);\n                pointsMaterial.map = material.map;\n                pointsMaterial.sizeAttenuation = false;\n                this.cache.add(cacheKey, pointsMaterial);\n            }\n            material = pointsMaterial;\n        } else if (mesh.isLine) {\n            const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n            let lineMaterial = this.cache.get(cacheKey);\n            if (!lineMaterial) {\n                lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n                lineMaterial.color.copy(material.color);\n                lineMaterial.map = material.map;\n                this.cache.add(cacheKey, lineMaterial);\n            }\n            material = lineMaterial;\n        }\n        if (useDerivativeTangents || useVertexColors || useFlatShading) {\n            let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n            if (useDerivativeTangents) cacheKey += \"derivative-tangents:\";\n            if (useVertexColors) cacheKey += \"vertex-colors:\";\n            if (useFlatShading) cacheKey += \"flat-shading:\";\n            let cachedMaterial = this.cache.get(cacheKey);\n            if (!cachedMaterial) {\n                cachedMaterial = material.clone();\n                if (useVertexColors) cachedMaterial.vertexColors = true;\n                if (useFlatShading) cachedMaterial.flatShading = true;\n                if (useDerivativeTangents) {\n                    if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n                    if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n                }\n                this.cache.add(cacheKey, cachedMaterial);\n                this.associations.set(cachedMaterial, this.associations.get(material));\n            }\n            material = cachedMaterial;\n        }\n        mesh.material = material;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */ loadMaterial(materialIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const materialDef = json.materials[materialIndex];\n        let materialType;\n        const materialParams = {};\n        const materialExtensions = materialDef.extensions || {};\n        const pending = [];\n        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n            materialType = kmuExtension.getMaterialType();\n            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n        } else {\n            const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n            materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            materialParams.opacity = 1;\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n            }\n            materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n            materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n            if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n                pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n            }\n            materialType = this._invokeOne(function(ext) {\n                return ext.getMaterialType && ext.getMaterialType(materialIndex);\n            });\n            pending.push(Promise.all(this._invokeAll(function(ext) {\n                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n            })));\n        }\n        if (materialDef.doubleSided === true) {\n            materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        }\n        const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n        if (alphaMode === ALPHA_MODES.BLEND) {\n            materialParams.transparent = true;\n            materialParams.depthWrite = false;\n        } else {\n            materialParams.transparent = false;\n            if (alphaMode === ALPHA_MODES.MASK) {\n                materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n            }\n        }\n        if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n            materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n            if (materialDef.normalTexture.scale !== void 0) {\n                const scale = materialDef.normalTexture.scale;\n                materialParams.normalScale.set(scale, scale);\n            }\n        }\n        if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n            if (materialDef.occlusionTexture.strength !== void 0) {\n                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n            }\n        }\n        if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            const emissiveFactor = materialDef.emissiveFactor;\n            materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);\n        }\n        if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, SRGBColorSpace));\n        }\n        return Promise.all(pending).then(function() {\n            const material = new materialType(materialParams);\n            if (materialDef.name) material.name = materialDef.name;\n            assignExtrasToUserData(material, materialDef);\n            parser.associations.set(material, {\n                materials: materialIndex\n            });\n            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n            return material;\n        });\n    }\n    /** When Object3D instances are targeted by animation, they need unique names. */ createUniqueName(originalName) {\n        const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n        if (sanitizedName in this.nodeNamesUsed) {\n            return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n        } else {\n            this.nodeNamesUsed[sanitizedName] = 0;\n            return sanitizedName;\n        }\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */ loadGeometries(primitives) {\n        const parser = this;\n        const extensions = this.extensions;\n        const cache = this.primitiveCache;\n        function createDracoPrimitive(primitive) {\n            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n                return addPrimitiveAttributes(geometry, primitive, parser);\n            });\n        }\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const primitive = primitives[i];\n            const cacheKey = createPrimitiveKey(primitive);\n            const cached = cache[cacheKey];\n            if (cached) {\n                pending.push(cached.promise);\n            } else {\n                let geometryPromise;\n                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n                    geometryPromise = createDracoPrimitive(primitive);\n                } else {\n                    geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n                }\n                cache[cacheKey] = {\n                    primitive,\n                    promise: geometryPromise\n                };\n                pending.push(geometryPromise);\n            }\n        }\n        return Promise.all(pending);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */ loadMesh(meshIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const meshDef = json.meshes[meshIndex];\n        const primitives = meshDef.primitives;\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n            pending.push(material);\n        }\n        pending.push(parser.loadGeometries(primitives));\n        return Promise.all(pending).then(function(results) {\n            const materials = results.slice(0, results.length - 1);\n            const geometries = results[results.length - 1];\n            const meshes = [];\n            for(let i = 0, il = geometries.length; i < il; i++){\n                const geometry = geometries[i];\n                const primitive = primitives[i];\n                let mesh;\n                const material = materials[i];\n                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n                    mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n                    if (mesh.isSkinnedMesh === true) {\n                        mesh.normalizeSkinWeights();\n                    }\n                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n                    }\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n                } else {\n                    throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n                }\n                if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n                    updateMorphTargets(mesh, meshDef);\n                }\n                mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n                assignExtrasToUserData(mesh, meshDef);\n                if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n                parser.assignFinalMaterial(mesh);\n                meshes.push(mesh);\n            }\n            for(let i = 0, il = meshes.length; i < il; i++){\n                parser.associations.set(meshes[i], {\n                    meshes: meshIndex,\n                    primitives: i\n                });\n            }\n            if (meshes.length === 1) {\n                if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n                return meshes[0];\n            }\n            const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);\n            parser.associations.set(group, {\n                meshes: meshIndex\n            });\n            for(let i = 0, il = meshes.length; i < il; i++){\n                group.add(meshes[i]);\n            }\n            return group;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */ loadCamera(cameraIndex) {\n        let camera;\n        const cameraDef = this.json.cameras[cameraIndex];\n        const params = cameraDef[cameraDef.type];\n        if (!params) {\n            console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n            return;\n        }\n        if (cameraDef.type === \"perspective\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n        } else if (cameraDef.type === \"orthographic\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n        }\n        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n        assignExtrasToUserData(camera, cameraDef);\n        return Promise.resolve(camera);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */ loadSkin(skinIndex) {\n        const skinDef = this.json.skins[skinIndex];\n        const pending = [];\n        for(let i = 0, il = skinDef.joints.length; i < il; i++){\n            pending.push(this._loadNodeShallow(skinDef.joints[i]));\n        }\n        if (skinDef.inverseBindMatrices !== void 0) {\n            pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n        } else {\n            pending.push(null);\n        }\n        return Promise.all(pending).then(function(results) {\n            const inverseBindMatrices = results.pop();\n            const jointNodes = results;\n            const bones = [];\n            const boneInverses = [];\n            for(let i = 0, il = jointNodes.length; i < il; i++){\n                const jointNode = jointNodes[i];\n                if (jointNode) {\n                    bones.push(jointNode);\n                    const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                    if (inverseBindMatrices !== null) {\n                        mat.fromArray(inverseBindMatrices.array, i * 16);\n                    }\n                    boneInverses.push(mat);\n                } else {\n                    console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */ loadAnimation(animationIndex) {\n        const json = this.json;\n        const parser = this;\n        const animationDef = json.animations[animationIndex];\n        const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n        const pendingNodes = [];\n        const pendingInputAccessors = [];\n        const pendingOutputAccessors = [];\n        const pendingSamplers = [];\n        const pendingTargets = [];\n        for(let i = 0, il = animationDef.channels.length; i < il; i++){\n            const channel = animationDef.channels[i];\n            const sampler = animationDef.samplers[channel.sampler];\n            const target = channel.target;\n            const name = target.node;\n            const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n            const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n            if (target.node === void 0) continue;\n            pendingNodes.push(this.getDependency(\"node\", name));\n            pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n            pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n            pendingSamplers.push(sampler);\n            pendingTargets.push(target);\n        }\n        return Promise.all([\n            Promise.all(pendingNodes),\n            Promise.all(pendingInputAccessors),\n            Promise.all(pendingOutputAccessors),\n            Promise.all(pendingSamplers),\n            Promise.all(pendingTargets)\n        ]).then(function(dependencies) {\n            const nodes = dependencies[0];\n            const inputAccessors = dependencies[1];\n            const outputAccessors = dependencies[2];\n            const samplers = dependencies[3];\n            const targets = dependencies[4];\n            const tracks = [];\n            for(let i = 0, il = nodes.length; i < il; i++){\n                const node = nodes[i];\n                const inputAccessor = inputAccessors[i];\n                const outputAccessor = outputAccessors[i];\n                const sampler = samplers[i];\n                const target = targets[i];\n                if (node === void 0) continue;\n                if (node.updateMatrix) {\n                    node.updateMatrix();\n                }\n                const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n                if (createdTracks) {\n                    for(let k = 0; k < createdTracks.length; k++){\n                        tracks.push(createdTracks[k]);\n                    }\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n        });\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        if (nodeDef.mesh === void 0) return null;\n        return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n            if (nodeDef.weights !== void 0) {\n                node.traverse(function(o) {\n                    if (!o.isMesh) return;\n                    for(let i = 0, il = nodeDef.weights.length; i < il; i++){\n                        o.morphTargetInfluences[i] = nodeDef.weights[i];\n                    }\n                });\n            }\n            return node;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */ loadNode(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        const nodePending = parser._loadNodeShallow(nodeIndex);\n        const childPending = [];\n        const childrenDef = nodeDef.children || [];\n        for(let i = 0, il = childrenDef.length; i < il; i++){\n            childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n        }\n        const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n        return Promise.all([\n            nodePending,\n            Promise.all(childPending),\n            skeletonPending\n        ]).then(function(results) {\n            const node = results[0];\n            const children = results[1];\n            const skeleton = results[2];\n            if (skeleton !== null) {\n                node.traverse(function(mesh) {\n                    if (!mesh.isSkinnedMesh) return;\n                    mesh.bind(skeleton, _identityMatrix);\n                });\n            }\n            for(let i = 0, il = children.length; i < il; i++){\n                node.add(children[i]);\n            }\n            return node;\n        });\n    }\n    // ._loadNodeShallow() parses a single node.\n    // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n    _loadNodeShallow(nodeIndex) {\n        const json = this.json;\n        const extensions = this.extensions;\n        const parser = this;\n        if (this.nodeCache[nodeIndex] !== void 0) {\n            return this.nodeCache[nodeIndex];\n        }\n        const nodeDef = json.nodes[nodeIndex];\n        const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n        const pending = [];\n        const meshPromise = parser._invokeOne(function(ext) {\n            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n        });\n        if (meshPromise) {\n            pending.push(meshPromise);\n        }\n        if (nodeDef.camera !== void 0) {\n            pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n            }));\n        }\n        parser._invokeAll(function(ext) {\n            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n        }).forEach(function(promise) {\n            pending.push(promise);\n        });\n        this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n            let node;\n            if (nodeDef.isBone === true) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n            } else if (objects.length > 1) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            } else if (objects.length === 1) {\n                node = objects[0];\n            } else {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n            }\n            if (node !== objects[0]) {\n                for(let i = 0, il = objects.length; i < il; i++){\n                    node.add(objects[i]);\n                }\n            }\n            if (nodeDef.name) {\n                node.userData.name = nodeDef.name;\n                node.name = nodeName;\n            }\n            assignExtrasToUserData(node, nodeDef);\n            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n            if (nodeDef.matrix !== void 0) {\n                const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                matrix.fromArray(nodeDef.matrix);\n                node.applyMatrix4(matrix);\n            } else {\n                if (nodeDef.translation !== void 0) {\n                    node.position.fromArray(nodeDef.translation);\n                }\n                if (nodeDef.rotation !== void 0) {\n                    node.quaternion.fromArray(nodeDef.rotation);\n                }\n                if (nodeDef.scale !== void 0) {\n                    node.scale.fromArray(nodeDef.scale);\n                }\n            }\n            if (!parser.associations.has(node)) {\n                parser.associations.set(node, {});\n            }\n            parser.associations.get(node).nodes = nodeIndex;\n            return node;\n        });\n        return this.nodeCache[nodeIndex];\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */ loadScene(sceneIndex) {\n        const extensions = this.extensions;\n        const sceneDef = this.json.scenes[sceneIndex];\n        const parser = this;\n        const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n        if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n        assignExtrasToUserData(scene, sceneDef);\n        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n        const nodeIds = sceneDef.nodes || [];\n        const pending = [];\n        for(let i = 0, il = nodeIds.length; i < il; i++){\n            pending.push(parser.getDependency(\"node\", nodeIds[i]));\n        }\n        return Promise.all(pending).then(function(nodes) {\n            for(let i = 0, il = nodes.length; i < il; i++){\n                scene.add(nodes[i]);\n            }\n            const reduceAssociations = (node)=>{\n                const reducedAssociations = /* @__PURE__ */ new Map();\n                for (const [key, value] of parser.associations){\n                    if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n                        reducedAssociations.set(key, value);\n                    }\n                }\n                node.traverse((node2)=>{\n                    const mappings = parser.associations.get(node2);\n                    if (mappings != null) {\n                        reducedAssociations.set(node2, mappings);\n                    }\n                });\n                return reducedAssociations;\n            };\n            parser.associations = reduceAssociations(scene);\n            return scene;\n        });\n    }\n    _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n        const tracks = [];\n        const targetName = node.name ? node.name : node.uuid;\n        const targetNames = [];\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n            node.traverse(function(object) {\n                if (object.morphTargetInfluences) {\n                    targetNames.push(object.name ? object.name : object.uuid);\n                }\n            });\n        } else {\n            targetNames.push(targetName);\n        }\n        let TypedKeyframeTrack;\n        switch(PATH_PROPERTIES[target.path]){\n            case PATH_PROPERTIES.weights:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                break;\n            case PATH_PROPERTIES.rotation:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n                break;\n            case PATH_PROPERTIES.position:\n            case PATH_PROPERTIES.scale:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                break;\n            default:\n                switch(outputAccessor.itemSize){\n                    case 1:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                        break;\n                    case 2:\n                    case 3:\n                    default:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                        break;\n                }\n                break;\n        }\n        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n        const outputArray = this._getArrayFromAccessor(outputAccessor);\n        for(let j = 0, jl = targetNames.length; j < jl; j++){\n            const track = new TypedKeyframeTrack(targetNames[j] + \".\" + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n            if (sampler.interpolation === \"CUBICSPLINE\") {\n                this._createCubicSplineTrackInterpolant(track);\n            }\n            tracks.push(track);\n        }\n        return tracks;\n    }\n    _getArrayFromAccessor(accessor) {\n        let outputArray = accessor.array;\n        if (accessor.normalized) {\n            const scale = getNormalizedComponentScale(outputArray.constructor);\n            const scaled = new Float32Array(outputArray.length);\n            for(let j = 0, jl = outputArray.length; j < jl; j++){\n                scaled[j] = outputArray[j] * scale;\n            }\n            outputArray = scaled;\n        }\n        return outputArray;\n    }\n    _createCubicSplineTrackInterpolant(track) {\n        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n            const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n            return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n        };\n        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n    }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n    if (attributes.POSITION !== void 0) {\n        const accessor = parser.json.accessors[attributes.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n            box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n            if (accessor.normalized) {\n                const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                box.min.multiplyScalar(boxScale);\n                box.max.multiplyScalar(boxScale);\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n            return;\n        }\n    } else {\n        return;\n    }\n    const targets = primitiveDef.targets;\n    if (targets !== void 0) {\n        const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        for(let i = 0, il = targets.length; i < il; i++){\n            const target = targets[i];\n            if (target.POSITION !== void 0) {\n                const accessor = parser.json.accessors[target.POSITION];\n                const min = accessor.min;\n                const max = accessor.max;\n                if (min !== void 0 && max !== void 0) {\n                    vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n                    vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n                    vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n                    if (accessor.normalized) {\n                        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                        vector.multiplyScalar(boxScale);\n                    }\n                    maxDisplacement.max(vector);\n                } else {\n                    console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n                }\n            }\n        }\n        box.expandByVector(maxDisplacement);\n    }\n    geometry.boundingBox = box;\n    const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n    box.getCenter(sphere.center);\n    sphere.radius = box.min.distanceTo(box.max) / 2;\n    geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const pending = [];\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n        return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n            geometry.setAttribute(attributeName, accessor);\n        });\n    }\n    for(const gltfAttributeName in attributes){\n        const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n        if (threeAttributeName in geometry.attributes) continue;\n        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n    if (primitiveDef.indices !== void 0 && !geometry.index) {\n        const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n            geometry.setIndex(accessor2);\n        });\n        pending.push(accessor);\n    }\n    assignExtrasToUserData(geometry, primitiveDef);\n    computeBounds(geometry, primitiveDef, parser);\n    return Promise.all(pending).then(function() {\n        return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n}\n //# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwOUI7QUFDcDVCO0FBQ2xCO0FBQ0s7QUFDekQsTUFBTWlFLGlCQUFpQjtBQUN2QixNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsZUFBZTtBQUNyQixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsbUJBQW1CckUseUNBQU1BO0lBQzdCc0UsWUFBWUMsT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLGVBQWUsR0FBRyxFQUFFO1FBQ3pCLElBQUksQ0FBQ0MsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJQyxnQ0FBZ0NEO1FBQzdDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlFLGlDQUFpQ0Y7UUFDOUM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSUcsMkJBQTJCSDtRQUN4QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJSSx5QkFBeUJKO1FBQ3RDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlLLHlCQUF5Qkw7UUFDdEM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSU0sNEJBQTRCTjtRQUN6QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJTyxtQ0FBbUNQO1FBQ2hEO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixP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eEMsU0FBU2IsVUFBVSxFQUMzQztRQUNGdkgsUUFBUW5ILElBQUksQ0FBQ3dyQix3QkFBd0I5YyxVQUFVLENBQUMrYyxrQkFBa0IsRUFBRTFaO0lBQ3RFO0lBQ0EsSUFBSTJJLGFBQWFHLE9BQU8sS0FBSyxLQUFLLEtBQUssQ0FBQ3RMLFNBQVM3SSxLQUFLLEVBQUU7UUFDdEQsTUFBTWlJLFdBQVdoUyxPQUFPOEosYUFBYSxDQUFDLFlBQVlpVSxhQUFhRyxPQUFPLEVBQUVoVSxJQUFJLENBQUMsU0FBUzZrQixTQUFTO1lBQzdGbmMsU0FBU29jLFFBQVEsQ0FBQ0Q7UUFDcEI7UUFDQXZrQixRQUFRbkgsSUFBSSxDQUFDMk87SUFDZjtJQUNBckksdUJBQXVCaUosVUFBVW1MO0lBQ2pDNlAsY0FBY2hiLFVBQVVtTCxjQUFjL2Q7SUFDdEMsT0FBTzRGLFFBQVFzRixHQUFHLENBQUNWLFNBQVNOLElBQUksQ0FBQztRQUMvQixPQUFPNlQsYUFBYXBCLE9BQU8sS0FBSyxLQUFLLElBQUlELGdCQUFnQjlKLFVBQVVtTCxhQUFhcEIsT0FBTyxFQUFFM2MsVUFBVTRTO0lBQ3JHO0FBQ0Y7QUFHRSxDQUNGLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jcmVhdGl2ZS1wb3J0Zm9saW8tc3RhcnRlci1jb2RlLWZpbGVzLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0dMVEZMb2FkZXIuanM/YmZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2FkZXIsIExvYWRlclV0aWxzLCBGaWxlTG9hZGVyLCBDb2xvciwgU3BvdExpZ2h0LCBQb2ludExpZ2h0LCBEaXJlY3Rpb25hbExpZ2h0LCBNZXNoQmFzaWNNYXRlcmlhbCwgTWVzaFBoeXNpY2FsTWF0ZXJpYWwsIFZlY3RvcjIsIE1hdHJpeDQsIFZlY3RvcjMsIFF1YXRlcm5pb24sIEluc3RhbmNlZE1lc2gsIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSwgT2JqZWN0M0QsIFRleHR1cmVMb2FkZXIsIEltYWdlQml0bWFwTG9hZGVyLCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIFJlcGVhdFdyYXBwaW5nLCBQb2ludHNNYXRlcmlhbCwgTWF0ZXJpYWwsIExpbmVCYXNpY01hdGVyaWFsLCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgRG91YmxlU2lkZSwgUHJvcGVydHlCaW5kaW5nLCBCdWZmZXJHZW9tZXRyeSwgU2tpbm5lZE1lc2gsIE1lc2gsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgTGluZVNlZ21lbnRzLCBMaW5lLCBMaW5lTG9vcCwgUG9pbnRzLCBHcm91cCwgUGVyc3BlY3RpdmVDYW1lcmEsIE1hdGhVdGlscywgT3J0aG9ncmFwaGljQ2FtZXJhLCBTa2VsZXRvbiwgQW5pbWF0aW9uQ2xpcCwgQm9uZSwgSW50ZXJwb2xhdGVMaW5lYXIsIE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLCBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLCBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLCBJbnRlcnBvbGF0ZURpc2NyZXRlLCBGcm9udFNpZGUsIFRleHR1cmUsIFZlY3RvcktleWZyYW1lVHJhY2ssIE51bWJlcktleWZyYW1lVHJhY2ssIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBCb3gzLCBTcGhlcmUsIEludGVycG9sYW50IH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyB0b1RyaWFuZ2xlc0RyYXdNb2RlIH0gZnJvbSBcIi4uL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3BvbHlmaWxsL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlVGV4dCB9IGZyb20gXCIuLi9fcG9seWZpbGwvTG9hZGVyVXRpbHMuanNcIjtcbmNvbnN0IFNSR0JDb2xvclNwYWNlID0gXCJzcmdiXCI7XG5jb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9IFwic3JnYi1saW5lYXJcIjtcbmNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG5jb25zdCBMaW5lYXJFbmNvZGluZyA9IDNlMztcbmNsYXNzIEdMVEZMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IG51bGw7XG4gICAgdGhpcy5rdHgyTG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLm1lc2hvcHREZWNvZGVyID0gbnVsbDtcbiAgICB0aGlzLnBsdWdpbkNhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzRGlzcGVyc2lvbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNWb2x1bWVFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzU3BlY3VsYXJFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQW5pc290cm9weUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNCdW1wRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURkxpZ2h0c0V4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNZXNob3B0Q29tcHJlc3Npb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWVzaEdwdUluc3RhbmNpbmcocGFyc2VyKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIGxldCByZXNvdXJjZVBhdGg7XG4gICAgaWYgKHRoaXMucmVzb3VyY2VQYXRoICE9PSBcIlwiKSB7XG4gICAgICByZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGF0aCAhPT0gXCJcIikge1xuICAgICAgY29uc3QgcmVsYXRpdmVVcmwgPSBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpO1xuICAgICAgcmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChyZWxhdGl2ZVVybCwgdGhpcy5wYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UodXJsKTtcbiAgICB9XG4gICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgIGNvbnN0IF9vbkVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgfTtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgbG9hZGVyLmxvYWQoXG4gICAgICB1cmwsXG4gICAgICBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2NvcGUucGFyc2UoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVzb3VyY2VQYXRoLFxuICAgICAgICAgICAgZnVuY3Rpb24oZ2x0Zikge1xuICAgICAgICAgICAgICBvbkxvYWQoZ2x0Zik7XG4gICAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF9vbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIF9vbkVycm9yXG4gICAgKTtcbiAgfVxuICBzZXREUkFDT0xvYWRlcihkcmFjb0xvYWRlcikge1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRERFNMb2FkZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUSFJFRS5HTFRGTG9hZGVyOiBcIk1TRlRfdGV4dHVyZV9kZHNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIHRvIFwiS0hSX3RleHR1cmVfYmFzaXN1XCIuJyk7XG4gIH1cbiAgc2V0S1RYMkxvYWRlcihrdHgyTG9hZGVyKSB7XG4gICAgdGhpcy5rdHgyTG9hZGVyID0ga3R4MkxvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRNZXNob3B0RGVjb2RlcihtZXNob3B0RGVjb2Rlcikge1xuICAgIHRoaXMubWVzaG9wdERlY29kZXIgPSBtZXNob3B0RGVjb2RlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWdpc3RlcihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1bnJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spICE9PSAtMSkge1xuICAgICAgdGhpcy5wbHVnaW5DYWxsYmFja3Muc3BsaWNlKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcGFyc2UoZGF0YSwgcGF0aCwgb25Mb2FkLCBvbkVycm9yKSB7XG4gICAgbGV0IGpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuICAgIGNvbnN0IHBsdWdpbnMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBjb25zdCBtYWdpYyA9IGRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgaWYgKG1hZ2ljID09PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdID0gbmV3IEdMVEZCaW5hcnlFeHRlbnNpb24oZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpXG4gICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IEpTT04ucGFyc2UoZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0uY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShkZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGpzb24gPSBkYXRhO1xuICAgIH1cbiAgICBpZiAoanNvbi5hc3NldCA9PT0gdm9pZCAwIHx8IGpzb24uYXNzZXQudmVyc2lvblswXSA8IDIpIHtcbiAgICAgIGlmIChvbkVycm9yKVxuICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGFzc2V0LiBnbFRGIHZlcnNpb25zID49Mi4wIGFyZSBzdXBwb3J0ZWQuXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IEdMVEZQYXJzZXIoanNvbiwge1xuICAgICAgcGF0aDogcGF0aCB8fCB0aGlzLnJlc291cmNlUGF0aCB8fCBcIlwiLFxuICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICByZXF1ZXN0SGVhZGVyOiB0aGlzLnJlcXVlc3RIZWFkZXIsXG4gICAgICBtYW5hZ2VyOiB0aGlzLm1hbmFnZXIsXG4gICAgICBrdHgyTG9hZGVyOiB0aGlzLmt0eDJMb2FkZXIsXG4gICAgICBtZXNob3B0RGVjb2RlcjogdGhpcy5tZXNob3B0RGVjb2RlclxuICAgIH0pO1xuICAgIHBhcnNlci5maWxlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnBsdWdpbkNhbGxiYWNrc1tpXShwYXJzZXIpO1xuICAgICAgaWYgKCFwbHVnaW4ubmFtZSlcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgcGx1Z2luIGZvdW5kOiBtaXNzaW5nIG5hbWVcIik7XG4gICAgICBwbHVnaW5zW3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcbiAgICAgIGV4dGVuc2lvbnNbcGx1Z2luLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGpzb24uZXh0ZW5zaW9uc1VzZWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5leHRlbnNpb25zVXNlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBleHRlbnNpb25OYW1lID0ganNvbi5leHRlbnNpb25zVXNlZFtpXTtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uc1JlcXVpcmVkID0ganNvbi5leHRlbnNpb25zUmVxdWlyZWQgfHwgW107XG4gICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uTmFtZSkge1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uKGpzb24sIHRoaXMuZHJhY29Mb2FkZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT046XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKGV4dGVuc2lvbk5hbWUpID49IDAgJiYgcGx1Z2luc1tleHRlbnNpb25OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuR0xURkxvYWRlcjogVW5rbm93biBleHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXJzZXIuc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBwYXJzZXIuc2V0UGx1Z2lucyhwbHVnaW5zKTtcbiAgICBwYXJzZXIucGFyc2Uob25Mb2FkLCBvbkVycm9yKTtcbiAgfVxuICBwYXJzZUFzeW5jKGRhdGEsIHBhdGgpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc2NvcGUucGFyc2UoZGF0YSwgcGF0aCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gR0xURlJlZ2lzdHJ5KCkge1xuICBsZXQgb2JqZWN0cyA9IHt9O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0c1trZXldO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbihrZXksIG9iamVjdCkge1xuICAgICAgb2JqZWN0c1trZXldID0gb2JqZWN0O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3RzW2tleV07XG4gICAgfSxcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgb2JqZWN0cyA9IHt9O1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEVYVEVOU0lPTlMgPSB7XG4gIEtIUl9CSU5BUllfR0xURjogXCJLSFJfYmluYXJ5X2dsVEZcIixcbiAgS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046IFwiS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb25cIixcbiAgS0hSX0xJR0hUU19QVU5DVFVBTDogXCJLSFJfbGlnaHRzX3B1bmN0dWFsXCIsXG4gIEtIUl9NQVRFUklBTFNfQ0xFQVJDT0FUOiBcIktIUl9tYXRlcmlhbHNfY2xlYXJjb2F0XCIsXG4gIEtIUl9NQVRFUklBTFNfRElTUEVSU0lPTjogXCJLSFJfbWF0ZXJpYWxzX2Rpc3BlcnNpb25cIixcbiAgS0hSX01BVEVSSUFMU19JT1I6IFwiS0hSX21hdGVyaWFsc19pb3JcIixcbiAgS0hSX01BVEVSSUFMU19TSEVFTjogXCJLSFJfbWF0ZXJpYWxzX3NoZWVuXCIsXG4gIEtIUl9NQVRFUklBTFNfU1BFQ1VMQVI6IFwiS0hSX21hdGVyaWFsc19zcGVjdWxhclwiLFxuICBLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjogXCJLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvblwiLFxuICBLSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFOiBcIktIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2VcIixcbiAgS0hSX01BVEVSSUFMU19BTklTT1RST1BZOiBcIktIUl9tYXRlcmlhbHNfYW5pc290cm9weVwiLFxuICBLSFJfTUFURVJJQUxTX1VOTElUOiBcIktIUl9tYXRlcmlhbHNfdW5saXRcIixcbiAgS0hSX01BVEVSSUFMU19WT0xVTUU6IFwiS0hSX21hdGVyaWFsc192b2x1bWVcIixcbiAgS0hSX1RFWFRVUkVfQkFTSVNVOiBcIktIUl90ZXh0dXJlX2Jhc2lzdVwiLFxuICBLSFJfVEVYVFVSRV9UUkFOU0ZPUk06IFwiS0hSX3RleHR1cmVfdHJhbnNmb3JtXCIsXG4gIEtIUl9NRVNIX1FVQU5USVpBVElPTjogXCJLSFJfbWVzaF9xdWFudGl6YXRpb25cIixcbiAgS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSDogXCJLSFJfbWF0ZXJpYWxzX2VtaXNzaXZlX3N0cmVuZ3RoXCIsXG4gIEVYVF9NQVRFUklBTFNfQlVNUDogXCJFWFRfbWF0ZXJpYWxzX2J1bXBcIixcbiAgRVhUX1RFWFRVUkVfV0VCUDogXCJFWFRfdGV4dHVyZV93ZWJwXCIsXG4gIEVYVF9URVhUVVJFX0FWSUY6IFwiRVhUX3RleHR1cmVfYXZpZlwiLFxuICBFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjogXCJFWFRfbWVzaG9wdF9jb21wcmVzc2lvblwiLFxuICBFWFRfTUVTSF9HUFVfSU5TVEFOQ0lORzogXCJFWFRfbWVzaF9ncHVfaW5zdGFuY2luZ1wiXG59O1xuY2xhc3MgR0xURkxpZ2h0c0V4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTDtcbiAgICB0aGlzLmNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgfVxuICBfbWFya0RlZnMoKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3Qgbm9kZURlZnMgPSB0aGlzLnBhcnNlci5qc29uLm5vZGVzIHx8IFtdO1xuICAgIGZvciAobGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlRGVmID0gbm9kZURlZnNbbm9kZUluZGV4XTtcbiAgICAgIGlmIChub2RlRGVmLmV4dGVuc2lvbnMgJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0gJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQgIT09IHZvaWQgMCkge1xuICAgICAgICBwYXJzZXIuX2FkZE5vZGVSZWYodGhpcy5jYWNoZSwgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfbG9hZExpZ2h0KGxpZ2h0SW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBjYWNoZUtleSA9IFwibGlnaHQ6XCIgKyBsaWdodEluZGV4O1xuICAgIGxldCBkZXBlbmRlbmN5ID0gcGFyc2VyLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKGRlcGVuZGVuY3kpXG4gICAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodERlZnMgPSBleHRlbnNpb25zLmxpZ2h0cyB8fCBbXTtcbiAgICBjb25zdCBsaWdodERlZiA9IGxpZ2h0RGVmc1tsaWdodEluZGV4XTtcbiAgICBsZXQgbGlnaHROb2RlO1xuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKDE2Nzc3MjE1KTtcbiAgICBpZiAobGlnaHREZWYuY29sb3IgIT09IHZvaWQgMClcbiAgICAgIGNvbG9yLnNldFJHQihsaWdodERlZi5jb2xvclswXSwgbGlnaHREZWYuY29sb3JbMV0sIGxpZ2h0RGVmLmNvbG9yWzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgY29uc3QgcmFuZ2UgPSBsaWdodERlZi5yYW5nZSAhPT0gdm9pZCAwID8gbGlnaHREZWYucmFuZ2UgOiAwO1xuICAgIHN3aXRjaCAobGlnaHREZWYudHlwZSkge1xuICAgICAgY2FzZSBcImRpcmVjdGlvbmFsXCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLnRhcmdldC5wb3NpdGlvbi5zZXQoMCwgMCwgLTEpO1xuICAgICAgICBsaWdodE5vZGUuYWRkKGxpZ2h0Tm9kZS50YXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICBsaWdodE5vZGUgPSBuZXcgUG9pbnRMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzcG90XCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBTcG90TGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcbiAgICAgICAgbGlnaHREZWYuc3BvdCA9IGxpZ2h0RGVmLnNwb3QgfHwge307XG4gICAgICAgIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlICE9PSB2b2lkIDAgPyBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlIDogMDtcbiAgICAgICAgbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgOiBNYXRoLlBJIC8gNDtcbiAgICAgICAgbGlnaHROb2RlLmFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcbiAgICAgICAgbGlnaHROb2RlLnBlbnVtYnJhID0gMSAtIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgLyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuICAgICAgICBsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAtMSk7XG4gICAgICAgIGxpZ2h0Tm9kZS5hZGQobGlnaHROb2RlLnRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5leHBlY3RlZCBsaWdodCB0eXBlOiBcIiArIGxpZ2h0RGVmLnR5cGUpO1xuICAgIH1cbiAgICBsaWdodE5vZGUucG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIGxpZ2h0Tm9kZS5kZWNheSA9IDI7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShsaWdodE5vZGUsIGxpZ2h0RGVmKTtcbiAgICBpZiAobGlnaHREZWYuaW50ZW5zaXR5ICE9PSB2b2lkIDApXG4gICAgICBsaWdodE5vZGUuaW50ZW5zaXR5ID0gbGlnaHREZWYuaW50ZW5zaXR5O1xuICAgIGxpZ2h0Tm9kZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobGlnaHREZWYubmFtZSB8fCBcImxpZ2h0X1wiICsgbGlnaHRJbmRleCk7XG4gICAgZGVwZW5kZW5jeSA9IFByb21pc2UucmVzb2x2ZShsaWdodE5vZGUpO1xuICAgIHBhcnNlci5jYWNoZS5hZGQoY2FjaGVLZXksIGRlcGVuZGVuY3kpO1xuICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICB9XG4gIGdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpIHtcbiAgICBpZiAodHlwZSAhPT0gXCJsaWdodFwiKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQoaW5kZXgpO1xuICB9XG4gIGNyZWF0ZU5vZGVBdHRhY2htZW50KG5vZGVJbmRleCkge1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBsaWdodERlZiA9IG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodEluZGV4ID0gbGlnaHREZWYubGlnaHQ7XG4gICAgaWYgKGxpZ2h0SW5kZXggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQobGlnaHRJbmRleCkudGhlbihmdW5jdGlvbihsaWdodCkge1xuICAgICAgcmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZihzZWxmMi5jYWNoZSwgbGlnaHRJbmRleCwgbGlnaHQpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKCkge1xuICAgIHJldHVybiBNZXNoQmFzaWNNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRQYXJhbXMobWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIpIHtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDE7XG4gICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcztcbiAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcikpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yLnNldFJHQihhcnJheVswXSwgYXJyYXlbMV0sIGFycmF5WzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVszXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0VNSVNTSVZFX1NUUkVOR1RIO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgZW1pc3NpdmVTdHJlbmd0aCA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5lbWlzc2l2ZVN0cmVuZ3RoO1xuICAgIGlmIChlbWlzc2l2ZVN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlSW50ZW5zaXR5ID0gZW1pc3NpdmVTdHJlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0NMRUFSQ09BVDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdEZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXQgPSBleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdE1hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdFJvdWdobmVzc01hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdE5vcm1hbE1hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSkpO1xuICAgICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMihzY2FsZSwgc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNEaXNwZXJzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0RJU1BFUlNJT047XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5kaXNwZXJzaW9uID0gZXh0ZW5zaW9uLmRpc3BlcnNpb24gIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5kaXNwZXJzaW9uIDogMDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19JUklERVNDRU5DRTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiaXJpZGVzY2VuY2VNYXBcIiwgZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlSW9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlSU9SID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlSW9yO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID0gWzEwMCwgNDAwXTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVswXSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMV0gPSBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwXCIsIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TSEVFTjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCk7XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Sb3VnaG5lc3MgPSAwO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuID0gMTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlbkNvbG9yRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGNvbG9yRmFjdG9yID0gZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3I7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbkNvbG9yLnNldFJHQihjb2xvckZhY3RvclswXSwgY29sb3JGYWN0b3JbMV0sIGNvbG9yRmFjdG9yWzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Sb3VnaG5lc3MgPSBleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Db2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNoZWVuQ29sb3JNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic2hlZW5Sb3VnaG5lc3NNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zbWlzc2lvbiA9IGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwidHJhbnNtaXNzaW9uTWFwXCIsIGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19WT0xVTUU7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMudGhpY2tuZXNzID0gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciA6IDA7XG4gICAgaWYgKGV4dGVuc2lvbi50aGlja25lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJ0aGlja25lc3NNYXBcIiwgZXh0ZW5zaW9uLnRoaWNrbmVzc1RleHR1cmUpKTtcbiAgICB9XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGV4dGVuc2lvbi5hdHRlbnVhdGlvbkRpc3RhbmNlIHx8IEluZmluaXR5O1xuICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uYXR0ZW51YXRpb25Db2xvciB8fCBbMSwgMSwgMV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25Db2xvciA9IG5ldyBDb2xvcigpLnNldFJHQihcbiAgICAgIGNvbG9yQXJyYXlbMF0sXG4gICAgICBjb2xvckFycmF5WzFdLFxuICAgICAgY29sb3JBcnJheVsyXSxcbiAgICAgIExpbmVhclNSR0JDb2xvclNwYWNlXG4gICAgKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfSU9SO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuaW9yID0gZXh0ZW5zaW9uLmlvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLmlvciA6IDEuNTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TUEVDVUxBUjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhckludGVuc2l0eSA9IGV4dGVuc2lvbi5zcGVjdWxhckZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yIDogMTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic3BlY3VsYXJJbnRlbnNpdHlNYXBcIiwgZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSkpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvckFycmF5ID0gZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JGYWN0b3IgfHwgWzEsIDEsIDFdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyQ29sb3IgPSBuZXcgQ29sb3IoKS5zZXRSR0IoY29sb3JBcnJheVswXSwgY29sb3JBcnJheVsxXSwgY29sb3JBcnJheVsyXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgIGlmIChleHRlbnNpb24uc3BlY3VsYXJDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzcGVjdWxhckNvbG9yTWFwXCIsIGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yVGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNCdW1wRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUFURVJJQUxTX0JVTVA7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuYnVtcFNjYWxlID0gZXh0ZW5zaW9uLmJ1bXBGYWN0b3IgIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5idW1wRmFjdG9yIDogMTtcbiAgICBpZiAoZXh0ZW5zaW9uLmJ1bXBUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJidW1wTWFwXCIsIGV4dGVuc2lvbi5idW1wVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNBbmlzb3Ryb3B5RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0FOSVNPVFJPUFk7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5U3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuYW5pc290cm9weSA9IGV4dGVuc2lvbi5hbmlzb3Ryb3B5U3RyZW5ndGg7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmFuaXNvdHJvcHlSb3RhdGlvbiA9IGV4dGVuc2lvbi5hbmlzb3Ryb3B5Um90YXRpb247XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImFuaXNvdHJvcHlNYXBcIiwgZXh0ZW5zaW9uLmFuaXNvdHJvcHlUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX0JBU0lTVTtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBpZiAoIXRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhdGV4dHVyZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBjb25zdCBsb2FkZXIgPSBwYXJzZXIub3B0aW9ucy5rdHgyTG9hZGVyO1xuICAgIGlmICghbG9hZGVyKSB7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZih0aGlzLm5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogc2V0S1RYMkxvYWRlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBLVFgyIHRleHR1cmVzXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX1RFWFRVUkVfV0VCUDtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gbnVsbDtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgY29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbZXh0ZW5zaW9uLnNvdXJjZV07XG4gICAgbGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2UudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2VyLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZS51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKGZ1bmN0aW9uKGlzU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFdlYlAgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUodGV4dHVyZUluZGV4KTtcbiAgICB9KTtcbiAgfVxuICBkZXRlY3RTdXBwb3J0KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5pc1N1cHBvcnRlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaUlBQUFCWFJVSlFWbEE0SUJZQUFBQXdBUUNkQVNvQkFBRUFEc0QrSmFRQUEzQUFBQUFBXCI7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlKGltYWdlLmhlaWdodCA9PT0gMSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQ7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlQVZJRkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX1RFWFRVUkVfQVZJRjtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gbnVsbDtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgY29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbZXh0ZW5zaW9uLnNvdXJjZV07XG4gICAgbGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2UudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2VyLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZS51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKGZ1bmN0aW9uKGlzU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEFWSUYgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUodGV4dHVyZUluZGV4KTtcbiAgICB9KTtcbiAgfVxuICBkZXRlY3RTdXBwb3J0KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5pc1N1cHBvcnRlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL2F2aWY7YmFzZTY0LEFBQUFJR1owZVhCaGRtbG1BQUFBQUdGMmFXWnRhV1l4YldsaFprMUJNVUlBQUFEeWJXVjBZUUFBQUFBQUFBQW9hR1JzY2dBQUFBQUFBQUFBY0dsamRBQUFBQUFBQUFBQUFBQUFBR3hwWW1GMmFXWUFBQUFBRG5CcGRHMEFBQUFBQUFFQUFBQWVhV3h2WXdBQUFBQkVBQUFCQUFFQUFBQUJBQUFCR2dBQUFCY0FBQUFvYVdsdVpnQUFBQUFBQVFBQUFCcHBibVpsQWdBQUFBQUJBQUJoZGpBeFEyOXNiM0lBQUFBQWFtbHdjbkFBQUFCTGFYQmpid0FBQUJScGMzQmxBQUFBQUFBQUFBRUFBQUFCQUFBQUVIQnBlR2tBQUFBQUF3Z0lDQUFBQUF4aGRqRkRnUUFNQUFBQUFCTmpiMnh5Ym1Oc2VBQUNBQUlBQm9BQUFBQVhhWEJ0WVFBQUFBQUFBQUFCQUFFRUFRS0RCQUFBQUI5dFpHRjBFZ0FLQ0JnQUJvZ1FFRFFnTWdrUUFBQUFCOGRTTGZJPVwiO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShpbWFnZS5oZWlnaHQgPT09IDEpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzU3VwcG9ydGVkO1xuICB9XG59XG5jbGFzcyBHTFRGTWVzaG9wdENvbXByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSE9QVF9DT01QUkVTU0lPTjtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBsb2FkQnVmZmVyVmlldyhpbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBqc29uLmJ1ZmZlclZpZXdzW2luZGV4XTtcbiAgICBpZiAoYnVmZmVyVmlldy5leHRlbnNpb25zICYmIGJ1ZmZlclZpZXcuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICBjb25zdCBleHRlbnNpb25EZWYgPSBidWZmZXJWaWV3LmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJcIiwgZXh0ZW5zaW9uRGVmLmJ1ZmZlcik7XG4gICAgICBjb25zdCBkZWNvZGVyID0gdGhpcy5wYXJzZXIub3B0aW9ucy5tZXNob3B0RGVjb2RlcjtcbiAgICAgIGlmICghZGVjb2RlciB8fCAhZGVjb2Rlci5zdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YodGhpcy5uYW1lKSA+PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogc2V0TWVzaG9wdERlY29kZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgY29tcHJlc3NlZCBmaWxlc1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlci50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gZXh0ZW5zaW9uRGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGV4dGVuc2lvbkRlZi5ieXRlTGVuZ3RoIHx8IDA7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gZXh0ZW5zaW9uRGVmLmNvdW50O1xuICAgICAgICBjb25zdCBzdHJpZGUgPSBleHRlbnNpb25EZWYuYnl0ZVN0cmlkZTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkocmVzLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgaWYgKGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jKGNvdW50LCBzdHJpZGUsIHNvdXJjZSwgZXh0ZW5zaW9uRGVmLm1vZGUsIGV4dGVuc2lvbkRlZi5maWx0ZXIpLnRoZW4oZnVuY3Rpb24ocmVzMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlczIuYnVmZmVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVyLnJlYWR5LnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoY291bnQgKiBzdHJpZGUpO1xuICAgICAgICAgICAgZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyKFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLFxuICAgICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbkRlZi5tb2RlLFxuICAgICAgICAgICAgICBleHRlbnNpb25EZWYuZmlsdGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR0xURk1lc2hHcHVJbnN0YW5jaW5nIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSF9HUFVfSU5TVEFOQ0lORztcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBjcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5wYXJzZXIuanNvbjtcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmICghbm9kZURlZi5leHRlbnNpb25zIHx8ICFub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCBub2RlRGVmLm1lc2ggPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1lc2hEZWYgPSBqc29uLm1lc2hlc1tub2RlRGVmLm1lc2hdO1xuICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIG1lc2hEZWYucHJpbWl0aXZlcykge1xuICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVTICYmIHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgJiYgcHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gJiYgcHJpbWl0aXZlLm1vZGUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uRGVmID0gbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgY29uc3QgYXR0cmlidXRlc0RlZiA9IGV4dGVuc2lvbkRlZi5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlc0RlZikge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgYXR0cmlidXRlc0RlZltrZXldKS50aGVuKChhY2Nlc3NvcikgPT4ge1xuICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGFjY2Vzc29yO1xuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocGVuZGluZy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGVuZGluZy5wdXNoKHRoaXMucGFyc2VyLmNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICBjb25zdCBub2RlT2JqZWN0ID0gcmVzdWx0cy5wb3AoKTtcbiAgICAgIGNvbnN0IG1lc2hlcyA9IG5vZGVPYmplY3QuaXNHcm91cCA/IG5vZGVPYmplY3QuY2hpbGRyZW4gOiBbbm9kZU9iamVjdF07XG4gICAgICBjb25zdCBjb3VudCA9IHJlc3VsdHNbMF0uY291bnQ7XG4gICAgICBjb25zdCBpbnN0YW5jZWRNZXNoZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbWVzaCBvZiBtZXNoZXMpIHtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICBjb25zdCBxID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgICAgICBjb25zdCBpbnN0YW5jZWRNZXNoID0gbmV3IEluc3RhbmNlZE1lc2gobWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRlcmlhbCwgY291bnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5UUkFOU0xBVElPTikge1xuICAgICAgICAgICAgcC5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuVFJBTlNMQVRJT04sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5ST1RBVElPTikge1xuICAgICAgICAgICAgcS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuUk9UQVRJT04sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5TQ0FMRSkge1xuICAgICAgICAgICAgcy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuU0NBTEUsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KGksIG0uY29tcG9zZShwLCBxLCBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJfQ09MT1JfMFwiKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgIGluc3RhbmNlZE1lc2guaW5zdGFuY2VDb2xvciA9IG5ldyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoYXR0ci5hcnJheSwgYXR0ci5pdGVtU2l6ZSwgYXR0ci5ub3JtYWxpemVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWUgIT09IFwiVFJBTlNMQVRJT05cIiAmJiBhdHRyaWJ1dGVOYW1lICE9PSBcIlJPVEFUSU9OXCIgJiYgYXR0cmlidXRlTmFtZSAhPT0gXCJTQ0FMRVwiKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbChpbnN0YW5jZWRNZXNoLCBtZXNoKTtcbiAgICAgICAgdGhpcy5wYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbChpbnN0YW5jZWRNZXNoKTtcbiAgICAgICAgaW5zdGFuY2VkTWVzaGVzLnB1c2goaW5zdGFuY2VkTWVzaCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZU9iamVjdC5pc0dyb3VwKSB7XG4gICAgICAgIG5vZGVPYmplY3QuY2xlYXIoKTtcbiAgICAgICAgbm9kZU9iamVjdC5hZGQoLi4uaW5zdGFuY2VkTWVzaGVzKTtcbiAgICAgICAgcmV0dXJuIG5vZGVPYmplY3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2VkTWVzaGVzWzBdO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyA9IFwiZ2xURlwiO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIID0gMTI7XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTID0geyBKU09OOiAxMzEzODIxNTE0LCBCSU46IDUxMzA1NjIgfTtcbmNsYXNzIEdMVEZCaW5hcnlFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEY7XG4gICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgIGNvbnN0IGhlYWRlclZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YSwgMCwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIKTtcbiAgICB0aGlzLmhlYWRlciA9IHtcbiAgICAgIG1hZ2ljOiBkZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEuc2xpY2UoMCwgNCkpKSxcbiAgICAgIHZlcnNpb246IGhlYWRlclZpZXcuZ2V0VWludDMyKDQsIHRydWUpLFxuICAgICAgbGVuZ3RoOiBoZWFkZXJWaWV3LmdldFVpbnQzMig4LCB0cnVlKVxuICAgIH07XG4gICAgaWYgKHRoaXMuaGVhZGVyLm1hZ2ljICE9PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgZ2xURi1CaW5hcnkgaGVhZGVyLlwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGVhZGVyLnZlcnNpb24gPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBMZWdhY3kgYmluYXJ5IGZpbGUgZGV0ZWN0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjaHVua0NvbnRlbnRzTGVuZ3RoID0gdGhpcy5oZWFkZXIubGVuZ3RoIC0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIO1xuICAgIGNvbnN0IGNodW5rVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEgpO1xuICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICB3aGlsZSAoY2h1bmtJbmRleCA8IGNodW5rQ29udGVudHNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gY2h1bmtWaWV3LmdldFVpbnQzMihjaHVua0luZGV4LCB0cnVlKTtcbiAgICAgIGNodW5rSW5kZXggKz0gNDtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rVmlldy5nZXRVaW50MzIoY2h1bmtJbmRleCwgdHJ1ZSk7XG4gICAgICBjaHVua0luZGV4ICs9IDQ7XG4gICAgICBpZiAoY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkpTT04pIHtcbiAgICAgICAgY29uc3QgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleCwgY2h1bmtMZW5ndGgpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBkZWNvZGVUZXh0KGNvbnRlbnRBcnJheSk7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5CSU4pIHtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXg7XG4gICAgICAgIHRoaXMuYm9keSA9IGRhdGEuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGNodW5rTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNodW5rSW5kZXggKz0gY2h1bmtMZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEpTT04gY29udGVudCBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoanNvbiwgZHJhY29Mb2FkZXIpIHtcbiAgICBpZiAoIWRyYWNvTG9hZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBObyBEUkFDT0xvYWRlciBpbnN0YW5jZSBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT047XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gZHJhY29Mb2FkZXI7XG4gICAgdGhpcy5kcmFjb0xvYWRlci5wcmVsb2FkKCk7XG4gIH1cbiAgZGVjb2RlUHJpbWl0aXZlKHByaW1pdGl2ZSwgcGFyc2VyKSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBkcmFjb0xvYWRlciA9IHRoaXMuZHJhY29Mb2FkZXI7XG4gICAgY29uc3QgYnVmZmVyVmlld0luZGV4ID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5idWZmZXJWaWV3O1xuICAgIGNvbnN0IGdsdGZBdHRyaWJ1dGVNYXAgPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwID0ge307XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZU1hcCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnbHRmQXR0cmlidXRlTWFwKSB7XG4gICAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2F0dHJpYnV0ZU5hbWVdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRocmVlQXR0cmlidXRlTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBnbHRmQXR0cmlidXRlTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gcHJpbWl0aXZlLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbYXR0cmlidXRlTmFtZV0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGdsdGZBdHRyaWJ1dGVNYXBbYXR0cmlidXRlTmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NvckRlZiA9IGpzb24uYWNjZXNzb3JzW3ByaW1pdGl2ZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50VHlwZSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgYXR0cmlidXRlVHlwZU1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gY29tcG9uZW50VHlwZS5uYW1lO1xuICAgICAgICBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGJ1ZmZlclZpZXdJbmRleCkudGhlbihmdW5jdGlvbihidWZmZXJWaWV3KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRyYWNvTG9hZGVyLmRlY29kZURyYWNvRmlsZShcbiAgICAgICAgICBidWZmZXJWaWV3LFxuICAgICAgICAgIGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gYXR0cmlidXRlTm9ybWFsaXplZE1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGdlb21ldHJ5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRocmVlQXR0cmlidXRlTWFwLFxuICAgICAgICAgIGF0dHJpYnV0ZVR5cGVNYXAsXG4gICAgICAgICAgTGluZWFyU1JHQkNvbG9yU3BhY2UsXG4gICAgICAgICAgcmVqZWN0XG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTtcbiAgfVxuICBleHRlbmRUZXh0dXJlKHRleHR1cmUsIHRyYW5zZm9ybSkge1xuICAgIGlmICgodHJhbnNmb3JtLnRleENvb3JkID09PSB2b2lkIDAgfHwgdHJhbnNmb3JtLnRleENvb3JkID09PSB0ZXh0dXJlLmNoYW5uZWwpICYmIHRyYW5zZm9ybS5vZmZzZXQgPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0ucm90YXRpb24gPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0uc2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG4gICAgaWYgKHRyYW5zZm9ybS50ZXhDb29yZCAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLmNoYW5uZWwgPSB0cmFuc2Zvcm0udGV4Q29vcmQ7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ub2Zmc2V0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSh0cmFuc2Zvcm0ub2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5yb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLnJvdGF0aW9uID0gdHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUucmVwZWF0LmZyb21BcnJheSh0cmFuc2Zvcm0uc2NhbGUpO1xuICAgIH1cbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxufVxuY2xhc3MgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjtcbiAgfVxufVxuY2xhc3MgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcbiAgfVxuICBjb3B5U2FtcGxlVmFsdWVfKGluZGV4KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsIHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLCB2YWx1ZVNpemUgPSB0aGlzLnZhbHVlU2l6ZSwgb2Zmc2V0ID0gaW5kZXggKiB2YWx1ZVNpemUgKiAzICsgdmFsdWVTaXplO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSB2YWx1ZVNpemU7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gdmFsdWVzW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXI7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXM7XG4gICAgY29uc3Qgc3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG4gICAgY29uc3Qgc3RyaWRlMiA9IHN0cmlkZSAqIDI7XG4gICAgY29uc3Qgc3RyaWRlMyA9IHN0cmlkZSAqIDM7XG4gICAgY29uc3QgdGQgPSB0MSAtIHQwO1xuICAgIGNvbnN0IHAgPSAodCAtIHQwKSAvIHRkO1xuICAgIGNvbnN0IHBwID0gcCAqIHA7XG4gICAgY29uc3QgcHBwID0gcHAgKiBwO1xuICAgIGNvbnN0IG9mZnNldDEgPSBpMSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgb2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUzO1xuICAgIGNvbnN0IHMyID0gLTIgKiBwcHAgKyAzICogcHA7XG4gICAgY29uc3QgczMgPSBwcHAgLSBwcDtcbiAgICBjb25zdCBzMCA9IDEgLSBzMjtcbiAgICBjb25zdCBzMSA9IHMzIC0gcHAgKyBwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7IGkrKykge1xuICAgICAgY29uc3QgcDAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGUyXSAqIHRkO1xuICAgICAgY29uc3QgcDEgPSB2YWx1ZXNbb2Zmc2V0MSArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTEgPSB2YWx1ZXNbb2Zmc2V0MSArIGldICogdGQ7XG4gICAgICByZXN1bHRbaV0gPSBzMCAqIHAwICsgczEgKiBtMCArIHMyICogcDEgKyBzMyAqIG0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBfcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5jbGFzcyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgZXh0ZW5kcyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCB7XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpO1xuICAgIF9xLmZyb21BcnJheShyZXN1bHQpLm5vcm1hbGl6ZSgpLnRvQXJyYXkocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBXRUJHTF9DT05TVEFOVFMgPSB7XG4gIEZMT0FUOiA1MTI2LFxuICAvL0ZMT0FUX01BVDI6IDM1Njc0LFxuICBGTE9BVF9NQVQzOiAzNTY3NSxcbiAgRkxPQVRfTUFUNDogMzU2NzYsXG4gIEZMT0FUX1ZFQzI6IDM1NjY0LFxuICBGTE9BVF9WRUMzOiAzNTY2NSxcbiAgRkxPQVRfVkVDNDogMzU2NjYsXG4gIExJTkVBUjogOTcyOSxcbiAgUkVQRUFUOiAxMDQ5NyxcbiAgU0FNUExFUl8yRDogMzU2NzgsXG4gIFBPSU5UUzogMCxcbiAgTElORVM6IDEsXG4gIExJTkVfTE9PUDogMixcbiAgTElORV9TVFJJUDogMyxcbiAgVFJJQU5HTEVTOiA0LFxuICBUUklBTkdMRV9TVFJJUDogNSxcbiAgVFJJQU5HTEVfRkFOOiA2LFxuICBVTlNJR05FRF9CWVRFOiA1MTIxLFxuICBVTlNJR05FRF9TSE9SVDogNTEyM1xufTtcbmNvbnN0IFdFQkdMX0NPTVBPTkVOVF9UWVBFUyA9IHtcbiAgNTEyMDogSW50OEFycmF5LFxuICA1MTIxOiBVaW50OEFycmF5LFxuICA1MTIyOiBJbnQxNkFycmF5LFxuICA1MTIzOiBVaW50MTZBcnJheSxcbiAgNTEyNTogVWludDMyQXJyYXksXG4gIDUxMjY6IEZsb2F0MzJBcnJheVxufTtcbmNvbnN0IFdFQkdMX0ZJTFRFUlMgPSB7XG4gIDk3Mjg6IE5lYXJlc3RGaWx0ZXIsXG4gIDk3Mjk6IExpbmVhckZpbHRlcixcbiAgOTk4NDogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODU6IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODY6IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG4gIDk5ODc6IExpbmVhck1pcG1hcExpbmVhckZpbHRlclxufTtcbmNvbnN0IFdFQkdMX1dSQVBQSU5HUyA9IHtcbiAgMzMwNzE6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gIDMzNjQ4OiBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLFxuICAxMDQ5NzogUmVwZWF0V3JhcHBpbmdcbn07XG5jb25zdCBXRUJHTF9UWVBFX1NJWkVTID0ge1xuICBTQ0FMQVI6IDEsXG4gIFZFQzI6IDIsXG4gIFZFQzM6IDMsXG4gIFZFQzQ6IDQsXG4gIE1BVDI6IDQsXG4gIE1BVDM6IDksXG4gIE1BVDQ6IDE2XG59O1xuY29uc3QgQVRUUklCVVRFUyA9IHtcbiAgUE9TSVRJT046IFwicG9zaXRpb25cIixcbiAgTk9STUFMOiBcIm5vcm1hbFwiLFxuICBUQU5HRU5UOiBcInRhbmdlbnRcIixcbiAgLy8gdXYgPT4gdXYxLCA0IHV2IGNoYW5uZWxzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNTk0M1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjU3ODhcbiAgLi4udmVyc2lvbiA+PSAxNTIgPyB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYxXCIsXG4gICAgVEVYQ09PUkRfMjogXCJ1djJcIixcbiAgICBURVhDT09SRF8zOiBcInV2M1wiXG4gIH0gOiB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYyXCJcbiAgfSxcbiAgQ09MT1JfMDogXCJjb2xvclwiLFxuICBXRUlHSFRTXzA6IFwic2tpbldlaWdodFwiLFxuICBKT0lOVFNfMDogXCJza2luSW5kZXhcIlxufTtcbmNvbnN0IFBBVEhfUFJPUEVSVElFUyA9IHtcbiAgc2NhbGU6IFwic2NhbGVcIixcbiAgdHJhbnNsYXRpb246IFwicG9zaXRpb25cIixcbiAgcm90YXRpb246IFwicXVhdGVybmlvblwiLFxuICB3ZWlnaHRzOiBcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiXG59O1xuY29uc3QgSU5URVJQT0xBVElPTiA9IHtcbiAgQ1VCSUNTUExJTkU6IHZvaWQgMCxcbiAgLy8gV2UgdXNlIGEgY3VzdG9tIGludGVycG9sYW50IChHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGF0aW9uKSBmb3IgQ1VCSUNTUExJTkUgdHJhY2tzLiBFYWNoXG4gIC8vIGtleWZyYW1lIHRyYWNrIHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGRlZmF1bHQgaW50ZXJwb2xhdGlvbiB0eXBlLCB0aGVuIG1vZGlmaWVkLlxuICBMSU5FQVI6IEludGVycG9sYXRlTGluZWFyLFxuICBTVEVQOiBJbnRlcnBvbGF0ZURpc2NyZXRlXG59O1xuY29uc3QgQUxQSEFfTU9ERVMgPSB7XG4gIE9QQVFVRTogXCJPUEFRVUVcIixcbiAgTUFTSzogXCJNQVNLXCIsXG4gIEJMRU5EOiBcIkJMRU5EXCJcbn07XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwoY2FjaGUpIHtcbiAgaWYgKGNhY2hlW1wiRGVmYXVsdE1hdGVyaWFsXCJdID09PSB2b2lkIDApIHtcbiAgICBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXSA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogMTY3NzcyMTUsXG4gICAgICBlbWlzc2l2ZTogMCxcbiAgICAgIG1ldGFsbmVzczogMSxcbiAgICAgIHJvdWdobmVzczogMSxcbiAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogdHJ1ZSxcbiAgICAgIHNpZGU6IEZyb250U2lkZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXTtcbn1cbmZ1bmN0aW9uIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShrbm93bkV4dGVuc2lvbnMsIG9iamVjdCwgb2JqZWN0RGVmKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBvYmplY3REZWYuZXh0ZW5zaW9ucykge1xuICAgIGlmIChrbm93bkV4dGVuc2lvbnNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zID0gb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zIHx8IHt9O1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zW25hbWVdID0gb2JqZWN0RGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG9iamVjdCwgZ2x0ZkRlZikge1xuICBpZiAoZ2x0ZkRlZi5leHRyYXMgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgZ2x0ZkRlZi5leHRyYXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ob2JqZWN0LnVzZXJEYXRhLCBnbHRmRGVmLmV4dHJhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IElnbm9yaW5nIHByaW1pdGl2ZSB0eXBlIC5leHRyYXMsIFwiICsgZ2x0ZkRlZi5leHRyYXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkTW9ycGhUYXJnZXRzKGdlb21ldHJ5LCB0YXJnZXRzLCBwYXJzZXIpIHtcbiAgbGV0IGhhc01vcnBoUG9zaXRpb24gPSBmYWxzZTtcbiAgbGV0IGhhc01vcnBoTm9ybWFsID0gZmFsc2U7XG4gIGxldCBoYXNNb3JwaENvbG9yID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgaWYgKHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwKVxuICAgICAgaGFzTW9ycGhQb3NpdGlvbiA9IHRydWU7XG4gICAgaWYgKHRhcmdldC5OT1JNQUwgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoTm9ybWFsID0gdHJ1ZTtcbiAgICBpZiAodGFyZ2V0LkNPTE9SXzAgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoQ29sb3IgPSB0cnVlO1xuICAgIGlmIChoYXNNb3JwaFBvc2l0aW9uICYmIGhhc01vcnBoTm9ybWFsICYmIGhhc01vcnBoQ29sb3IpXG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoIWhhc01vcnBoUG9zaXRpb24gJiYgIWhhc01vcnBoTm9ybWFsICYmICFoYXNNb3JwaENvbG9yKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZ2VvbWV0cnkpO1xuICBjb25zdCBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMgPSBbXTtcbiAgY29uc3QgcGVuZGluZ05vcm1hbEFjY2Vzc29ycyA9IFtdO1xuICBjb25zdCBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbikge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0LlBPU0lUSU9OICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5QT1NJVElPTikgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoTm9ybWFsKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuTk9STUFMICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5OT1JNQUwpIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG4gICAgICBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5DT0xPUl8wICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5DT0xPUl8wKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3I7XG4gICAgICBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMucHVzaChwZW5kaW5nQWNjZXNzb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIFByb21pc2UuYWxsKHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ05vcm1hbEFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ0NvbG9yQWNjZXNzb3JzKVxuICBdKS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29ycykge1xuICAgIGNvbnN0IG1vcnBoUG9zaXRpb25zID0gYWNjZXNzb3JzWzBdO1xuICAgIGNvbnN0IG1vcnBoTm9ybWFscyA9IGFjY2Vzc29yc1sxXTtcbiAgICBjb25zdCBtb3JwaENvbG9ycyA9IGFjY2Vzc29yc1syXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbilcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiA9IG1vcnBoUG9zaXRpb25zO1xuICAgIGlmIChoYXNNb3JwaE5vcm1hbClcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgPSBtb3JwaE5vcm1hbHM7XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgPSBtb3JwaENvbG9ycztcbiAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vcnBoVGFyZ2V0cyhtZXNoLCBtZXNoRGVmKSB7XG4gIG1lc2gudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG4gIGlmIChtZXNoRGVmLndlaWdodHMgIT09IHZvaWQgMCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9IG1lc2hEZWYud2VpZ2h0c1tpXTtcbiAgICB9XG4gIH1cbiAgaWYgKG1lc2hEZWYuZXh0cmFzICYmIEFycmF5LmlzQXJyYXkobWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXMpKSB7XG4gICAgY29uc3QgdGFyZ2V0TmFtZXMgPSBtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcztcbiAgICBpZiAobWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoID09PSB0YXJnZXROYW1lcy5sZW5ndGgpIHtcbiAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3RhcmdldE5hbWVzW2ldXSA9IGk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgZXh0cmFzLnRhcmdldE5hbWVzIGxlbmd0aC4gSWdub3JpbmcgbmFtZXMuXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlS2V5KHByaW1pdGl2ZURlZikge1xuICBsZXQgZ2VvbWV0cnlLZXk7XG4gIGNvbnN0IGRyYWNvRXh0ZW5zaW9uID0gcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl07XG4gIGlmIChkcmFjb0V4dGVuc2lvbikge1xuICAgIGdlb21ldHJ5S2V5ID0gXCJkcmFjbzpcIiArIGRyYWNvRXh0ZW5zaW9uLmJ1ZmZlclZpZXcgKyBcIjpcIiArIGRyYWNvRXh0ZW5zaW9uLmluZGljZXMgKyBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoZHJhY29FeHRlbnNpb24uYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgZ2VvbWV0cnlLZXkgPSBwcmltaXRpdmVEZWYuaW5kaWNlcyArIFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShwcmltaXRpdmVEZWYuYXR0cmlidXRlcykgKyBcIjpcIiArIHByaW1pdGl2ZURlZi5tb2RlO1xuICB9XG4gIGlmIChwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdm9pZCAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlRGVmLnRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgZ2VvbWV0cnlLZXkgKz0gXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KHByaW1pdGl2ZURlZi50YXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlb21ldHJ5S2V5O1xufVxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlc0tleShhdHRyaWJ1dGVzKSB7XG4gIGxldCBhdHRyaWJ1dGVzS2V5ID0gXCJcIjtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnNvcnQoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgYXR0cmlidXRlc0tleSArPSBrZXlzW2ldICsgXCI6XCIgKyBhdHRyaWJ1dGVzW2tleXNbaV1dICsgXCI7XCI7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXNLZXk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoY29uc3RydWN0b3IpIHtcbiAgc3dpdGNoIChjb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAxMjc7XG4gICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAyNTU7XG4gICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAzMjc2NztcbiAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyA2NTUzNTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgbm9ybWFsaXplZCBhY2Nlc3NvciBjb21wb25lbnQgdHlwZS5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEltYWdlVVJJTWltZVR5cGUodXJpKSB7XG4gIGlmICh1cmkuc2VhcmNoKC9cXC5qcGU/ZygkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC9qcGVnLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2UvanBlZ1wiO1xuICBpZiAodXJpLnNlYXJjaCgvXFwud2VicCgkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC93ZWJwLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2Uvd2VicFwiO1xuICByZXR1cm4gXCJpbWFnZS9wbmdcIjtcbn1cbmNvbnN0IF9pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5jbGFzcyBHTFRGUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoanNvbiA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmpzb24gPSBqc29uO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jYWNoZSA9IG5ldyBHTFRGUmVnaXN0cnkoKTtcbiAgICB0aGlzLmFzc29jaWF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmltaXRpdmVDYWNoZSA9IHt9O1xuICAgIHRoaXMubm9kZUNhY2hlID0ge307XG4gICAgdGhpcy5tZXNoQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMuY2FtZXJhQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMubGlnaHRDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gICAgdGhpcy5zb3VyY2VDYWNoZSA9IHt9O1xuICAgIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gICAgdGhpcy5ub2RlTmFtZXNVc2VkID0ge307XG4gICAgbGV0IGlzU2FmYXJpID0gZmFsc2U7XG4gICAgbGV0IGlzRmlyZWZveCA9IGZhbHNlO1xuICAgIGxldCBmaXJlZm94VmVyc2lvbiA9IC0xO1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IHRydWU7XG4gICAgICBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID4gLTE7XG4gICAgICBmaXJlZm94VmVyc2lvbiA9IGlzRmlyZWZveCA/IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8oWzAtOV0rKVxcLi8pWzFdIDogLTE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNTYWZhcmkgfHwgaXNGaXJlZm94ICYmIGZpcmVmb3hWZXJzaW9uIDwgOTgpIHtcbiAgICAgIHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IEltYWdlQml0bWFwTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgdGhpcy50ZXh0dXJlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXIpO1xuICAgIHRoaXMuZmlsZUxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB0aGlzLmZpbGVMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gXCJ1c2UtY3JlZGVudGlhbHNcIikge1xuICAgICAgdGhpcy5maWxlTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0cnVlKTtcbiAgICB9XG4gIH1cbiAgc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgfVxuICBzZXRQbHVnaW5zKHBsdWdpbnMpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSBwbHVnaW5zO1xuICB9XG4gIHBhcnNlKG9uTG9hZCwgb25FcnJvcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIHRoaXMuY2FjaGUucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5ub2RlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0Ll9tYXJrRGVmcyAmJiBleHQuX21hcmtEZWZzKCk7XG4gICAgfSk7XG4gICAgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgIHJldHVybiBleHQuYmVmb3JlUm9vdCAmJiBleHQuYmVmb3JlUm9vdCgpO1xuICAgICAgfSlcbiAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwic2NlbmVcIiksXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJhbmltYXRpb25cIiksXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJjYW1lcmFcIilcbiAgICAgIF0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNjZW5lOiBkZXBlbmRlbmNpZXNbMF1banNvbi5zY2VuZSB8fCAwXSxcbiAgICAgICAgc2NlbmVzOiBkZXBlbmRlbmNpZXNbMF0sXG4gICAgICAgIGFuaW1hdGlvbnM6IGRlcGVuZGVuY2llc1sxXSxcbiAgICAgICAgY2FtZXJhczogZGVwZW5kZW5jaWVzWzJdLFxuICAgICAgICBhc3NldDoganNvbi5hc3NldCxcbiAgICAgICAgcGFyc2VyLFxuICAgICAgICB1c2VyRGF0YToge31cbiAgICAgIH07XG4gICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgcmVzdWx0LCBqc29uKTtcbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEocmVzdWx0LCBqc29uKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgcGFyc2VyLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGV4dC5hZnRlclJvb3QgJiYgZXh0LmFmdGVyUm9vdChyZXN1bHQpO1xuICAgICAgICB9KVxuICAgICAgKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNjZW5lIG9mIHJlc3VsdC5zY2VuZXMpIHtcbiAgICAgICAgICBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgICB9XG4gICAgICAgIG9uTG9hZChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSkuY2F0Y2gob25FcnJvcik7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIHRoZSBzcGVjaWFsIG5vZGVzL21lc2hlcyBpbiBqc29uIGZvciBlZmZpY2llbnQgcGFyc2UuXG4gICAqL1xuICBfbWFya0RlZnMoKSB7XG4gICAgY29uc3Qgbm9kZURlZnMgPSB0aGlzLmpzb24ubm9kZXMgfHwgW107XG4gICAgY29uc3Qgc2tpbkRlZnMgPSB0aGlzLmpzb24uc2tpbnMgfHwgW107XG4gICAgY29uc3QgbWVzaERlZnMgPSB0aGlzLmpzb24ubWVzaGVzIHx8IFtdO1xuICAgIGZvciAobGV0IHNraW5JbmRleCA9IDAsIHNraW5MZW5ndGggPSBza2luRGVmcy5sZW5ndGg7IHNraW5JbmRleCA8IHNraW5MZW5ndGg7IHNraW5JbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2ludHMgPSBza2luRGVmc1tza2luSW5kZXhdLmpvaW50cztcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG5vZGVEZWZzW2pvaW50c1tpXV0uaXNCb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4KyspIHtcbiAgICAgIGNvbnN0IG5vZGVEZWYgPSBub2RlRGVmc1tub2RlSW5kZXhdO1xuICAgICAgaWYgKG5vZGVEZWYubWVzaCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZE5vZGVSZWYodGhpcy5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCk7XG4gICAgICAgIGlmIChub2RlRGVmLnNraW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG1lc2hEZWZzW25vZGVEZWYubWVzaF0uaXNTa2lubmVkTWVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlRGVmLmNhbWVyYSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZE5vZGVSZWYodGhpcy5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ291bnRzIHJlZmVyZW5jZXMgdG8gc2hhcmVkIG5vZGUgLyBPYmplY3QzRCByZXNvdXJjZXMuIFRoZXNlIHJlc291cmNlc1xuICAgKiBjYW4gYmUgcmV1c2VkLCBvciBcImluc3RhbnRpYXRlZFwiLCBhdCBtdWx0aXBsZSBub2RlcyBpbiB0aGUgc2NlbmVcbiAgICogaGllcmFyY2h5LiBNZXNoLCBDYW1lcmEsIGFuZCBMaWdodCBpbnN0YW5jZXMgYXJlIGluc3RhbnRpYXRlZCBhbmQgbXVzdFxuICAgKiBiZSBtYXJrZWQuIE5vbi1zY2VuZWdyYXBoIHJlc291cmNlcyAobGlrZSBNYXRlcmlhbHMsIEdlb21ldHJpZXMsIGFuZFxuICAgKiBUZXh0dXJlcykgY2FuIGJlIHJldXNlZCBkaXJlY3RseSBhbmQgYXJlIG5vdCBtYXJrZWQgaGVyZS5cbiAgICpcbiAgICogRXhhbXBsZTogQ2VzaXVtTWlsa1RydWNrIHNhbXBsZSBtb2RlbCByZXVzZXMgXCJXaGVlbFwiIG1lc2hlcy5cbiAgICovXG4gIF9hZGROb2RlUmVmKGNhY2hlLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChjYWNoZS5yZWZzW2luZGV4XSA9PT0gdm9pZCAwKSB7XG4gICAgICBjYWNoZS5yZWZzW2luZGV4XSA9IGNhY2hlLnVzZXNbaW5kZXhdID0gMDtcbiAgICB9XG4gICAgY2FjaGUucmVmc1tpbmRleF0rKztcbiAgfVxuICAvKiogUmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIHNoYXJlZCByZXNvdXJjZSwgY2xvbmluZyBpdCBpZiBuZWNlc3NhcnkuICovXG4gIF9nZXROb2RlUmVmKGNhY2hlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgaWYgKGNhY2hlLnJlZnNbaW5kZXhdIDw9IDEpXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIGNvbnN0IHJlZiA9IG9iamVjdC5jbG9uZSgpO1xuICAgIGNvbnN0IHVwZGF0ZU1hcHBpbmdzID0gKG9yaWdpbmFsLCBjbG9uZSkgPT4ge1xuICAgICAgY29uc3QgbWFwcGluZ3MgPSB0aGlzLmFzc29jaWF0aW9ucy5nZXQob3JpZ2luYWwpO1xuICAgICAgaWYgKG1hcHBpbmdzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGNsb25lLCBtYXBwaW5ncyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtpLCBjaGlsZF0gb2Ygb3JpZ2luYWwuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgIHVwZGF0ZU1hcHBpbmdzKGNoaWxkLCBjbG9uZS5jaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGVNYXBwaW5ncyhvYmplY3QsIHJlZik7XG4gICAgcmVmLm5hbWUgKz0gXCJfaW5zdGFuY2VfXCIgKyBjYWNoZS51c2VzW2luZGV4XSsrO1xuICAgIHJldHVybiByZWY7XG4gIH1cbiAgX2ludm9rZU9uZShmdW5jKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5wbHVnaW5zKTtcbiAgICBleHRlbnNpb25zLnB1c2godGhpcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmdW5jKGV4dGVuc2lvbnNbaV0pO1xuICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX2ludm9rZUFsbChmdW5jKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5wbHVnaW5zKTtcbiAgICBleHRlbnNpb25zLnVuc2hpZnQodGhpcyk7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZnVuYyhleHRlbnNpb25zW2ldKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHBlbmRpbmcucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgdGhlIHNwZWNpZmllZCBkZXBlbmRlbmN5IGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEfE1hdGVyaWFsfFRIUkVFLlRleHR1cmV8QW5pbWF0aW9uQ2xpcHxBcnJheUJ1ZmZlcnxPYmplY3Q+fVxuICAgKi9cbiAgZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gdHlwZSArIFwiOlwiICsgaW5kZXg7XG4gICAgbGV0IGRlcGVuZGVuY3kgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFkZXBlbmRlbmN5KSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInNjZW5lXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNjZW5lKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5vZGVcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTm9kZSAmJiBleHQubG9hZE5vZGUoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzaFwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRNZXNoICYmIGV4dC5sb2FkTWVzaChpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhY2Nlc3NvclwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRBY2Nlc3NvcihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidWZmZXJWaWV3XCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZEJ1ZmZlclZpZXcgJiYgZXh0LmxvYWRCdWZmZXJWaWV3KGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ1ZmZlclwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRCdWZmZXIoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWF0ZXJpYWxcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTWF0ZXJpYWwgJiYgZXh0LmxvYWRNYXRlcmlhbChpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0dXJlXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZFRleHR1cmUgJiYgZXh0LmxvYWRUZXh0dXJlKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNraW5cIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2tpbihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhbmltYXRpb25cIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkQW5pbWF0aW9uICYmIGV4dC5sb2FkQW5pbWF0aW9uKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhbWVyYVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRDYW1lcmEoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ICE9IHRoaXMgJiYgZXh0LmdldERlcGVuZGVuY3kgJiYgZXh0LmdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghZGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBkZXBlbmRlbmN5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFsbCBkZXBlbmRlbmNpZXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8T2JqZWN0Pj59XG4gICAqL1xuICBnZXREZXBlbmRlbmNpZXModHlwZSkge1xuICAgIGxldCBkZXBlbmRlbmNpZXMgPSB0aGlzLmNhY2hlLmdldCh0eXBlKTtcbiAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICAgIGNvbnN0IGRlZnMgPSB0aGlzLmpzb25bdHlwZSArICh0eXBlID09PSBcIm1lc2hcIiA/IFwiZXNcIiA6IFwic1wiKV0gfHwgW107XG4gICAgICBkZXBlbmRlbmNpZXMgPSBQcm9taXNlLmFsbChcbiAgICAgICAgZGVmcy5tYXAoZnVuY3Rpb24oZGVmLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgdGhpcy5jYWNoZS5hZGQodHlwZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlckluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgbG9hZEJ1ZmZlcihidWZmZXJJbmRleCkge1xuICAgIGNvbnN0IGJ1ZmZlckRlZiA9IHRoaXMuanNvbi5idWZmZXJzW2J1ZmZlckluZGV4XTtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmZpbGVMb2FkZXI7XG4gICAgaWYgKGJ1ZmZlckRlZi50eXBlICYmIGJ1ZmZlckRlZi50eXBlICE9PSBcImFycmF5YnVmZmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFwiICsgYnVmZmVyRGVmLnR5cGUgKyBcIiBidWZmZXIgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlckRlZi51cmkgPT09IHZvaWQgMCAmJiBidWZmZXJJbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdLmJvZHkpO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGxvYWRlci5sb2FkKExvYWRlclV0aWxzLnJlc29sdmVVUkwoYnVmZmVyRGVmLnVyaSwgb3B0aW9ucy5wYXRoKSwgcmVzb2x2ZSwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVEhSRUUuR0xURkxvYWRlcjogRmFpbGVkIHRvIGxvYWQgYnVmZmVyIFwiJyArIGJ1ZmZlckRlZi51cmkgKyAnXCIuJykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJWaWV3SW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBsb2FkQnVmZmVyVmlldyhidWZmZXJWaWV3SW5kZXgpIHtcbiAgICBjb25zdCBidWZmZXJWaWV3RGVmID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzW2J1ZmZlclZpZXdJbmRleF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclwiLCBidWZmZXJWaWV3RGVmLmJ1ZmZlcikudGhlbihmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBidWZmZXJWaWV3RGVmLmJ5dGVMZW5ndGggfHwgMDtcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBidWZmZXJWaWV3RGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2FjY2Vzc29yc1xuICAgKiBAcGFyYW0ge251bWJlcn0gYWNjZXNzb3JJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJ1ZmZlckF0dHJpYnV0ZXxJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZT59XG4gICAqL1xuICBsb2FkQWNjZXNzb3IoYWNjZXNzb3JJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBhY2Nlc3NvckRlZiA9IHRoaXMuanNvbi5hY2Nlc3NvcnNbYWNjZXNzb3JJbmRleF07XG4gICAgaWYgKGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgPT09IHZvaWQgMCAmJiBhY2Nlc3NvckRlZi5zcGFyc2UgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTW2FjY2Vzc29yRGVmLnR5cGVdO1xuICAgICAgY29uc3QgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZ0J1ZmZlclZpZXdzID0gW107XG4gICAgaWYgKGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKG51bGwpO1xuICAgIH1cbiAgICBpZiAoYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnVmZmVyVmlldykpO1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXcpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmdCdWZmZXJWaWV3cykudGhlbihmdW5jdGlvbihidWZmZXJWaWV3cykge1xuICAgICAgY29uc3QgYnVmZmVyVmlldyA9IGJ1ZmZlclZpZXdzWzBdO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTW2FjY2Vzc29yRGVmLnR5cGVdO1xuICAgICAgY29uc3QgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgIGNvbnN0IGVsZW1lbnRCeXRlcyA9IFR5cGVkQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICBjb25zdCBpdGVtQnl0ZXMgPSBlbGVtZW50Qnl0ZXMgKiBpdGVtU2l6ZTtcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBhY2Nlc3NvckRlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBieXRlU3RyaWRlID0gYWNjZXNzb3JEZWYuYnVmZmVyVmlldyAhPT0gdm9pZCAwID8ganNvbi5idWZmZXJWaWV3c1thY2Nlc3NvckRlZi5idWZmZXJWaWV3XS5ieXRlU3RyaWRlIDogdm9pZCAwO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgICBsZXQgYXJyYXksIGJ1ZmZlckF0dHJpYnV0ZTtcbiAgICAgIGlmIChieXRlU3RyaWRlICYmIGJ5dGVTdHJpZGUgIT09IGl0ZW1CeXRlcykge1xuICAgICAgICBjb25zdCBpYlNsaWNlID0gTWF0aC5mbG9vcihieXRlT2Zmc2V0IC8gYnl0ZVN0cmlkZSk7XG4gICAgICAgIGNvbnN0IGliQ2FjaGVLZXkgPSBcIkludGVybGVhdmVkQnVmZmVyOlwiICsgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyArIFwiOlwiICsgYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZSArIFwiOlwiICsgaWJTbGljZSArIFwiOlwiICsgYWNjZXNzb3JEZWYuY291bnQ7XG4gICAgICAgIGxldCBpYiA9IHBhcnNlci5jYWNoZS5nZXQoaWJDYWNoZUtleSk7XG4gICAgICAgIGlmICghaWIpIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXcsIGliU2xpY2UgKiBieXRlU3RyaWRlLCBhY2Nlc3NvckRlZi5jb3VudCAqIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMpO1xuICAgICAgICAgIGliID0gbmV3IEludGVybGVhdmVkQnVmZmVyKGFycmF5LCBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzKTtcbiAgICAgICAgICBwYXJzZXIuY2FjaGUuYWRkKGliQ2FjaGVLZXksIGliKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgICAgaWIsXG4gICAgICAgICAgaXRlbVNpemUsXG4gICAgICAgICAgYnl0ZU9mZnNldCAlIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMsXG4gICAgICAgICAgbm9ybWFsaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJ1ZmZlclZpZXcgPT09IG51bGwpIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlldywgYnl0ZU9mZnNldCwgYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1TaXplSW5kaWNlcyA9IFdFQkdMX1RZUEVfU0laRVMuU0NBTEFSO1xuICAgICAgICBjb25zdCBUeXBlZEFycmF5SW5kaWNlcyA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldEluZGljZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXRWYWx1ZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3Qgc3BhcnNlSW5kaWNlcyA9IG5ldyBUeXBlZEFycmF5SW5kaWNlcyhcbiAgICAgICAgICBidWZmZXJWaWV3c1sxXSxcbiAgICAgICAgICBieXRlT2Zmc2V0SW5kaWNlcyxcbiAgICAgICAgICBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc3BhcnNlVmFsdWVzID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlld3NbMl0sIGJ5dGVPZmZzZXRWYWx1ZXMsIGFjY2Vzc29yRGVmLnNwYXJzZS5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgaWYgKGJ1ZmZlclZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLmFycmF5LnNsaWNlKCksXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUsXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc3BhcnNlSW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBzcGFyc2VJbmRpY2VzW2ldO1xuICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRYKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDIpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WShpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDFdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gMylcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRaKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgMl0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSA0KVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFcoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAzXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBpdGVtU2l6ZSBpbiBzcGFyc2UgQnVmZmVyQXR0cmlidXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlckF0dHJpYnV0ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3RleHR1cmVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0dXJlSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5UZXh0dXJlfG51bGw+fVxuICAgKi9cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgY29uc3Qgc291cmNlSW5kZXggPSB0ZXh0dXJlRGVmLnNvdXJjZTtcbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgbGV0IGxvYWRlciA9IHRoaXMudGV4dHVyZUxvYWRlcjtcbiAgICBpZiAoc291cmNlRGVmLnVyaSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IG9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZURlZi51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBzb3VyY2VJbmRleCwgbG9hZGVyKTtcbiAgfVxuICBsb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgc291cmNlSW5kZXgsIGxvYWRlcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGNvbnN0IHNvdXJjZURlZiA9IGpzb24uaW1hZ2VzW3NvdXJjZUluZGV4XTtcbiAgICBjb25zdCBjYWNoZUtleSA9IChzb3VyY2VEZWYudXJpIHx8IHNvdXJjZURlZi5idWZmZXJWaWV3KSArIFwiOlwiICsgdGV4dHVyZURlZi5zYW1wbGVyO1xuICAgIGlmICh0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmxvYWRJbWFnZVNvdXJjZShzb3VyY2VJbmRleCwgbG9hZGVyKS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHRleHR1cmUubmFtZSA9IHRleHR1cmVEZWYubmFtZSB8fCBzb3VyY2VEZWYubmFtZSB8fCBcIlwiO1xuICAgICAgaWYgKHRleHR1cmUubmFtZSA9PT0gXCJcIiAmJiB0eXBlb2Ygc291cmNlRGVmLnVyaSA9PT0gXCJzdHJpbmdcIiAmJiBzb3VyY2VEZWYudXJpLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL1wiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGV4dHVyZS5uYW1lID0gc291cmNlRGVmLnVyaTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNhbXBsZXJzID0ganNvbi5zYW1wbGVycyB8fCB7fTtcbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1t0ZXh0dXJlRGVmLnNhbXBsZXJdIHx8IHt9O1xuICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBXRUJHTF9GSUxURVJTW3NhbXBsZXIubWFnRmlsdGVyXSB8fCBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbc2FtcGxlci5taW5GaWx0ZXJdIHx8IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUud3JhcFMgPSBXRUJHTF9XUkFQUElOR1Nbc2FtcGxlci53cmFwU10gfHwgUmVwZWF0V3JhcHBpbmc7XG4gICAgICB0ZXh0dXJlLndyYXBUID0gV0VCR0xfV1JBUFBJTkdTW3NhbXBsZXIud3JhcFRdIHx8IFJlcGVhdFdyYXBwaW5nO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQodGV4dHVyZSwgeyB0ZXh0dXJlczogdGV4dHVyZUluZGV4IH0pO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGxvYWRJbWFnZVNvdXJjZShzb3VyY2VJbmRleCwgbG9hZGVyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuc291cmNlQ2FjaGVbc291cmNlSW5kZXhdICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XS50aGVuKCh0ZXh0dXJlKSA9PiB0ZXh0dXJlLmNsb25lKCkpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgY29uc3QgVVJMID0gc2VsZi5VUkwgfHwgc2VsZi53ZWJraXRVUkw7XG4gICAgbGV0IHNvdXJjZVVSSSA9IHNvdXJjZURlZi51cmkgfHwgXCJcIjtcbiAgICBsZXQgaXNPYmplY3RVUkwgPSBmYWxzZTtcbiAgICBpZiAoc291cmNlRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgc291cmNlVVJJID0gcGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIHNvdXJjZURlZi5idWZmZXJWaWV3KS50aGVuKGZ1bmN0aW9uKGJ1ZmZlclZpZXcpIHtcbiAgICAgICAgaXNPYmplY3RVUkwgPSB0cnVlO1xuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlclZpZXddLCB7IHR5cGU6IHNvdXJjZURlZi5taW1lVHlwZSB9KTtcbiAgICAgICAgc291cmNlVVJJID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVVSSTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc291cmNlRGVmLnVyaSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBJbWFnZSBcIiArIHNvdXJjZUluZGV4ICsgXCIgaXMgbWlzc2luZyBVUkkgYW5kIGJ1ZmZlclZpZXdcIik7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoc291cmNlVVJJKS50aGVuKGZ1bmN0aW9uKHNvdXJjZVVSSTIpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGV0IG9uTG9hZCA9IHJlc29sdmU7XG4gICAgICAgIGlmIChsb2FkZXIuaXNJbWFnZUJpdG1hcExvYWRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9uTG9hZCA9IGZ1bmN0aW9uKGltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoaW1hZ2VCaXRtYXApO1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKHRleHR1cmUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyLmxvYWQoTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChzb3VyY2VVUkkyLCBvcHRpb25zLnBhdGgpLCBvbkxvYWQsIHZvaWQgMCwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgaWYgKGlzT2JqZWN0VVJMID09PSB0cnVlKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc291cmNlVVJJKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEodGV4dHVyZSwgc291cmNlRGVmKTtcbiAgICAgIHRleHR1cmUudXNlckRhdGEubWltZVR5cGUgPSBzb3VyY2VEZWYubWltZVR5cGUgfHwgZ2V0SW1hZ2VVUklNaW1lVHlwZShzb3VyY2VEZWYudXJpKTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogQ291bGRuJ3QgbG9hZCB0ZXh0dXJlXCIsIHNvdXJjZVVSSSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgICB0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGFzc2lnbnMgYSB0ZXh0dXJlIHRvIHRoZSBnaXZlbiBtYXRlcmlhbCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWxQYXJhbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcERlZlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRleHR1cmU+fVxuICAgKi9cbiAgYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgbWFwTmFtZSwgbWFwRGVmLCBjb2xvclNwYWNlKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KFwidGV4dHVyZVwiLCBtYXBEZWYuaW5kZXgpLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgaWYgKCF0ZXh0dXJlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChtYXBEZWYudGV4Q29vcmQgIT09IHZvaWQgMCAmJiBtYXBEZWYudGV4Q29vcmQgPiAwKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG4gICAgICAgIHRleHR1cmUuY2hhbm5lbCA9IG1hcERlZi50ZXhDb29yZDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZXIuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0pIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gbWFwRGVmLmV4dGVuc2lvbnMgIT09IHZvaWQgMCA/IG1hcERlZi5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgIGNvbnN0IGdsdGZSZWZlcmVuY2UgPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldCh0ZXh0dXJlKTtcbiAgICAgICAgICB0ZXh0dXJlID0gcGFyc2VyLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dLmV4dGVuZFRleHR1cmUodGV4dHVyZSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldCh0ZXh0dXJlLCBnbHRmUmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbG9yU3BhY2UgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbG9yU3BhY2UgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgY29sb3JTcGFjZSA9IGNvbG9yU3BhY2UgPT09IHNSR0JFbmNvZGluZyA/IFNSR0JDb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgICAgIGlmIChcImNvbG9yU3BhY2VcIiBpbiB0ZXh0dXJlKVxuICAgICAgICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IGNvbG9yU3BhY2U7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0ZXh0dXJlLmVuY29kaW5nID0gY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgPyBzUkdCRW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZztcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsUGFyYW1zW21hcE5hbWVdID0gdGV4dHVyZTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBc3NpZ25zIGZpbmFsIG1hdGVyaWFsIHRvIGEgTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLiBUaGUgaW5zdGFuY2VcbiAgICogYWxyZWFkeSBoYXMgYSBtYXRlcmlhbCAoZ2VuZXJhdGVkIGZyb20gdGhlIGdsVEYgbWF0ZXJpYWwgb3B0aW9ucyBhbG9uZSlcbiAgICogYnV0IHJldXNlIG9mIHRoZSBzYW1lIGdsVEYgbWF0ZXJpYWwgbWF5IHJlcXVpcmUgbXVsdGlwbGUgdGhyZWVqcyBtYXRlcmlhbHNcbiAgICogdG8gYWNjb21tb2RhdGUgZGlmZmVyZW50IHByaW1pdGl2ZSB0eXBlcywgZGVmaW5lcywgZXRjLiBOZXcgbWF0ZXJpYWxzIHdpbGxcbiAgICogYmUgY3JlYXRlZCBpZiBuZWNlc3NhcnksIGFuZCByZXVzZWQgZnJvbSBhIGNhY2hlLlxuICAgKiBAcGFyYW0gIHtPYmplY3QzRH0gbWVzaCBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuXG4gICAqL1xuICBhc3NpZ25GaW5hbE1hdGVyaWFsKG1lc2gpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG1lc2guZ2VvbWV0cnk7XG4gICAgbGV0IG1hdGVyaWFsID0gbWVzaC5tYXRlcmlhbDtcbiAgICBjb25zdCB1c2VEZXJpdmF0aXZlVGFuZ2VudHMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQgPT09IHZvaWQgMDtcbiAgICBjb25zdCB1c2VWZXJ0ZXhDb2xvcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICE9PSB2b2lkIDA7XG4gICAgY29uc3QgdXNlRmxhdFNoYWRpbmcgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdm9pZCAwO1xuICAgIGlmIChtZXNoLmlzUG9pbnRzKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IFwiUG9pbnRzTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkO1xuICAgICAgbGV0IHBvaW50c01hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFwb2ludHNNYXRlcmlhbCkge1xuICAgICAgICBwb2ludHNNYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCgpO1xuICAgICAgICBNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKHBvaW50c01hdGVyaWFsLCBtYXRlcmlhbCk7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLmNvbG9yLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgcG9pbnRzTWF0ZXJpYWwpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBwb2ludHNNYXRlcmlhbDtcbiAgICB9IGVsc2UgaWYgKG1lc2guaXNMaW5lKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IFwiTGluZUJhc2ljTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkO1xuICAgICAgbGV0IGxpbmVNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghbGluZU1hdGVyaWFsKSB7XG4gICAgICAgIGxpbmVNYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xuICAgICAgICBNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKGxpbmVNYXRlcmlhbCwgbWF0ZXJpYWwpO1xuICAgICAgICBsaW5lTWF0ZXJpYWwuY29sb3IuY29weShtYXRlcmlhbC5jb2xvcik7XG4gICAgICAgIGxpbmVNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBsaW5lTWF0ZXJpYWwpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBsaW5lTWF0ZXJpYWw7XG4gICAgfVxuICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMgfHwgdXNlVmVydGV4Q29sb3JzIHx8IHVzZUZsYXRTaGFkaW5nKSB7XG4gICAgICBsZXQgY2FjaGVLZXkgPSBcIkNsb25lZE1hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZCArIFwiOlwiO1xuICAgICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJkZXJpdmF0aXZlLXRhbmdlbnRzOlwiO1xuICAgICAgaWYgKHVzZVZlcnRleENvbG9ycylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJ2ZXJ0ZXgtY29sb3JzOlwiO1xuICAgICAgaWYgKHVzZUZsYXRTaGFkaW5nKVxuICAgICAgICBjYWNoZUtleSArPSBcImZsYXQtc2hhZGluZzpcIjtcbiAgICAgIGxldCBjYWNoZWRNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghY2FjaGVkTWF0ZXJpYWwpIHtcbiAgICAgICAgY2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICBpZiAodXNlVmVydGV4Q29sb3JzKVxuICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG4gICAgICAgIGlmICh1c2VGbGF0U2hhZGluZylcbiAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5mbGF0U2hhZGluZyA9IHRydWU7XG4gICAgICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMpIHtcbiAgICAgICAgICBpZiAoY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUpXG4gICAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5ub3JtYWxTY2FsZS55ICo9IC0xO1xuICAgICAgICAgIGlmIChjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZSlcbiAgICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlLnkgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIGNhY2hlZE1hdGVyaWFsKTtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGNhY2hlZE1hdGVyaWFsLCB0aGlzLmFzc29jaWF0aW9ucy5nZXQobWF0ZXJpYWwpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gY2FjaGVkTWF0ZXJpYWw7XG4gICAgfVxuICAgIG1lc2gubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUoKSB7XG4gICAgcmV0dXJuIE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21hdGVyaWFsc1xuICAgKiBAcGFyYW0ge251bWJlcn0gbWF0ZXJpYWxJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1hdGVyaWFsPn1cbiAgICovXG4gIGxvYWRNYXRlcmlhbChtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBqc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBsZXQgbWF0ZXJpYWxUeXBlO1xuICAgIGNvbnN0IG1hdGVyaWFsUGFyYW1zID0ge307XG4gICAgY29uc3QgbWF0ZXJpYWxFeHRlbnNpb25zID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgaWYgKG1hdGVyaWFsRXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVRdKSB7XG4gICAgICBjb25zdCBrbXVFeHRlbnNpb24gPSBleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVF07XG4gICAgICBtYXRlcmlhbFR5cGUgPSBrbXVFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCk7XG4gICAgICBwZW5kaW5nLnB1c2goa211RXh0ZW5zaW9uLmV4dGVuZFBhcmFtcyhtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzIHx8IHt9O1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcikpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yLnNldFJHQihhcnJheVswXSwgYXJyYXlbMV0sIGFycmF5WzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVszXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxQYXJhbXMubWV0YWxuZXNzID0gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgIT09IHZvaWQgMCA/IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yIDogMTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnJvdWdobmVzcyA9IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwID8gbWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yIDogMTtcbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWV0YWxuZXNzTWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwicm91Z2huZXNzTWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxUeXBlID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICByZXR1cm4gZXh0LmdldE1hdGVyaWFsVHlwZSAmJiBleHQuZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMgJiYgZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZG91YmxlU2lkZWQgPT09IHRydWUpIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnNpZGUgPSBEb3VibGVTaWRlO1xuICAgIH1cbiAgICBjb25zdCBhbHBoYU1vZGUgPSBtYXRlcmlhbERlZi5hbHBoYU1vZGUgfHwgQUxQSEFfTU9ERVMuT1BBUVVFO1xuICAgIGlmIChhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLkJMRU5EKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgICBpZiAoYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5NQVNLKSB7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmFscGhhVGVzdCA9IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmICE9PSB2b2lkIDAgPyBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiA6IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibm9ybWFsTWFwXCIsIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUpKTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUuc2V0KHNjYWxlLCBzY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImFvTWFwXCIsIG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUpKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuYW9NYXBJbnRlbnNpdHkgPSBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3IgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBjb25zdCBlbWlzc2l2ZUZhY3RvciA9IG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoKS5zZXRSR0IoXG4gICAgICAgIGVtaXNzaXZlRmFjdG9yWzBdLFxuICAgICAgICBlbWlzc2l2ZUZhY3RvclsxXSxcbiAgICAgICAgZW1pc3NpdmVGYWN0b3JbMl0sXG4gICAgICAgIExpbmVhclNSR0JDb2xvclNwYWNlXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImVtaXNzaXZlTWFwXCIsIG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBtYXRlcmlhbFR5cGUobWF0ZXJpYWxQYXJhbXMpO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLm5hbWUpXG4gICAgICAgIG1hdGVyaWFsLm5hbWUgPSBtYXRlcmlhbERlZi5uYW1lO1xuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShtYXRlcmlhbCwgbWF0ZXJpYWxEZWYpO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobWF0ZXJpYWwsIHsgbWF0ZXJpYWxzOiBtYXRlcmlhbEluZGV4IH0pO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYpO1xuICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuICAgIH0pO1xuICB9XG4gIC8qKiBXaGVuIE9iamVjdDNEIGluc3RhbmNlcyBhcmUgdGFyZ2V0ZWQgYnkgYW5pbWF0aW9uLCB0aGV5IG5lZWQgdW5pcXVlIG5hbWVzLiAqL1xuICBjcmVhdGVVbmlxdWVOYW1lKG9yaWdpbmFsTmFtZSkge1xuICAgIGNvbnN0IHNhbml0aXplZE5hbWUgPSBQcm9wZXJ0eUJpbmRpbmcuc2FuaXRpemVOb2RlTmFtZShvcmlnaW5hbE5hbWUgfHwgXCJcIik7XG4gICAgaWYgKHNhbml0aXplZE5hbWUgaW4gdGhpcy5ub2RlTmFtZXNVc2VkKSB7XG4gICAgICByZXR1cm4gc2FuaXRpemVkTmFtZSArIFwiX1wiICsgKyt0aGlzLm5vZGVOYW1lc1VzZWRbc2FuaXRpemVkTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZU5hbWVzVXNlZFtzYW5pdGl6ZWROYW1lXSA9IDA7XG4gICAgICByZXR1cm4gc2FuaXRpemVkTmFtZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjZ2VvbWV0cnlcbiAgICpcbiAgICogQ3JlYXRlcyBCdWZmZXJHZW9tZXRyaWVzIGZyb20gcHJpbWl0aXZlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxHTFRGLlByaW1pdGl2ZT59IHByaW1pdGl2ZXNcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxCdWZmZXJHZW9tZXRyeT4+fVxuICAgKi9cbiAgbG9hZEdlb21ldHJpZXMocHJpbWl0aXZlcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMucHJpbWl0aXZlQ2FjaGU7XG4gICAgZnVuY3Rpb24gY3JlYXRlRHJhY29QcmltaXRpdmUocHJpbWl0aXZlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXS5kZWNvZGVQcmltaXRpdmUocHJpbWl0aXZlLCBwYXJzZXIpLnRoZW4oZnVuY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICAgICAgcmV0dXJuIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoZ2VvbWV0cnksIHByaW1pdGl2ZSwgcGFyc2VyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzW2ldO1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVQcmltaXRpdmVLZXkocHJpbWl0aXZlKTtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKGNhY2hlZC5wcm9taXNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBnZW9tZXRyeVByb21pc2U7XG4gICAgICAgIGlmIChwcmltaXRpdmUuZXh0ZW5zaW9ucyAmJiBwcmltaXRpdmUuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXSkge1xuICAgICAgICAgIGdlb21ldHJ5UHJvbWlzZSA9IGNyZWF0ZURyYWNvUHJpbWl0aXZlKHByaW1pdGl2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VvbWV0cnlQcm9taXNlID0gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyhuZXcgQnVmZmVyR2VvbWV0cnkoKSwgcHJpbWl0aXZlLCBwYXJzZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHsgcHJpbWl0aXZlLCBwcm9taXNlOiBnZW9tZXRyeVByb21pc2UgfTtcbiAgICAgICAgcGVuZGluZy5wdXNoKGdlb21ldHJ5UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtZXNoZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1lc2hJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwfE1lc2h8U2tpbm5lZE1lc2g+fVxuICAgKi9cbiAgbG9hZE1lc2gobWVzaEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgbWVzaERlZiA9IGpzb24ubWVzaGVzW21lc2hJbmRleF07XG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IG1lc2hEZWYucHJpbWl0aXZlcztcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IHByaW1pdGl2ZXNbaV0ubWF0ZXJpYWwgPT09IHZvaWQgMCA/IGNyZWF0ZURlZmF1bHRNYXRlcmlhbCh0aGlzLmNhY2hlKSA6IHRoaXMuZ2V0RGVwZW5kZW5jeShcIm1hdGVyaWFsXCIsIHByaW1pdGl2ZXNbaV0ubWF0ZXJpYWwpO1xuICAgICAgcGVuZGluZy5wdXNoKG1hdGVyaWFsKTtcbiAgICB9XG4gICAgcGVuZGluZy5wdXNoKHBhcnNlci5sb2FkR2VvbWV0cmllcyhwcmltaXRpdmVzKSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3QgbWF0ZXJpYWxzID0gcmVzdWx0cy5zbGljZSgwLCByZXN1bHRzLmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3QgZ2VvbWV0cmllcyA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IG1lc2hlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1tpXTtcbiAgICAgICAgbGV0IG1lc2g7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbWF0ZXJpYWxzW2ldO1xuICAgICAgICBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRVMgfHwgcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCB8fCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiB8fCBwcmltaXRpdmUubW9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbWVzaCA9IG1lc2hEZWYuaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSA/IG5ldyBTa2lubmVkTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpIDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICBpZiAobWVzaC5pc1NraW5uZWRNZXNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBtZXNoLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZShtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZVN0cmlwRHJhd01vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4pIHtcbiAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlRmFuRHJhd01vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVTKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lU2VnbWVudHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfU1RSSVApIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfTE9PUCkge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZUxvb3AoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlBPSU5UUykge1xuICAgICAgICAgIG1lc2ggPSBuZXcgUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogUHJpbWl0aXZlIG1vZGUgdW5zdXBwb3J0ZWQ6IFwiICsgcHJpbWl0aXZlLm1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhtZXNoLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVwZGF0ZU1vcnBoVGFyZ2V0cyhtZXNoLCBtZXNoRGVmKTtcbiAgICAgICAgfVxuICAgICAgICBtZXNoLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShtZXNoRGVmLm5hbWUgfHwgXCJtZXNoX1wiICsgbWVzaEluZGV4KTtcbiAgICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShtZXNoLCBtZXNoRGVmKTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5leHRlbnNpb25zKVxuICAgICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtZXNoLCBwcmltaXRpdmUpO1xuICAgICAgICBwYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbChtZXNoKTtcbiAgICAgICAgbWVzaGVzLnB1c2gobWVzaCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChtZXNoZXNbaV0sIHtcbiAgICAgICAgICBtZXNoZXM6IG1lc2hJbmRleCxcbiAgICAgICAgICBwcmltaXRpdmVzOiBpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1lc2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKG1lc2hEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWVzaGVzWzBdLCBtZXNoRGVmKTtcbiAgICAgICAgcmV0dXJuIG1lc2hlc1swXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKCk7XG4gICAgICBpZiAobWVzaERlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgZ3JvdXAsIG1lc2hEZWYpO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoZ3JvdXAsIHsgbWVzaGVzOiBtZXNoSW5kZXggfSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cC5hZGQobWVzaGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2NhbWVyYXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNhbWVyYUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuQ2FtZXJhPn1cbiAgICovXG4gIGxvYWRDYW1lcmEoY2FtZXJhSW5kZXgpIHtcbiAgICBsZXQgY2FtZXJhO1xuICAgIGNvbnN0IGNhbWVyYURlZiA9IHRoaXMuanNvbi5jYW1lcmFzW2NhbWVyYUluZGV4XTtcbiAgICBjb25zdCBwYXJhbXMgPSBjYW1lcmFEZWZbY2FtZXJhRGVmLnR5cGVdO1xuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIGNhbWVyYSBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhbWVyYURlZi50eXBlID09PSBcInBlcnNwZWN0aXZlXCIpIHtcbiAgICAgIGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShcbiAgICAgICAgTWF0aFV0aWxzLnJhZFRvRGVnKHBhcmFtcy55Zm92KSxcbiAgICAgICAgcGFyYW1zLmFzcGVjdFJhdGlvIHx8IDEsXG4gICAgICAgIHBhcmFtcy56bmVhciB8fCAxLFxuICAgICAgICBwYXJhbXMuemZhciB8fCAyZTZcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjYW1lcmFEZWYudHlwZSA9PT0gXCJvcnRob2dyYXBoaWNcIikge1xuICAgICAgY2FtZXJhID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSgtcGFyYW1zLnhtYWcsIHBhcmFtcy54bWFnLCBwYXJhbXMueW1hZywgLXBhcmFtcy55bWFnLCBwYXJhbXMuem5lYXIsIHBhcmFtcy56ZmFyKTtcbiAgICB9XG4gICAgaWYgKGNhbWVyYURlZi5uYW1lKVxuICAgICAgY2FtZXJhLm5hbWUgPSB0aGlzLmNyZWF0ZVVuaXF1ZU5hbWUoY2FtZXJhRGVmLm5hbWUpO1xuICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoY2FtZXJhLCBjYW1lcmFEZWYpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NraW5zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBza2luSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxTa2VsZXRvbj59XG4gICAqL1xuICBsb2FkU2tpbihza2luSW5kZXgpIHtcbiAgICBjb25zdCBza2luRGVmID0gdGhpcy5qc29uLnNraW5zW3NraW5JbmRleF07XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHNraW5EZWYuam9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHBlbmRpbmcucHVzaCh0aGlzLl9sb2FkTm9kZVNoYWxsb3coc2tpbkRlZi5qb2ludHNbaV0pKTtcbiAgICB9XG4gICAgaWYgKHNraW5EZWYuaW52ZXJzZUJpbmRNYXRyaWNlcyAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmcucHVzaChudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3QgaW52ZXJzZUJpbmRNYXRyaWNlcyA9IHJlc3VsdHMucG9wKCk7XG4gICAgICBjb25zdCBqb2ludE5vZGVzID0gcmVzdWx0cztcbiAgICAgIGNvbnN0IGJvbmVzID0gW107XG4gICAgICBjb25zdCBib25lSW52ZXJzZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGpvaW50Tm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBqb2ludE5vZGUgPSBqb2ludE5vZGVzW2ldO1xuICAgICAgICBpZiAoam9pbnROb2RlKSB7XG4gICAgICAgICAgYm9uZXMucHVzaChqb2ludE5vZGUpO1xuICAgICAgICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgICAgaWYgKGludmVyc2VCaW5kTWF0cmljZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1hdC5mcm9tQXJyYXkoaW52ZXJzZUJpbmRNYXRyaWNlcy5hcnJheSwgaSAqIDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9uZUludmVyc2VzLnB1c2gobWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkdMVEZMb2FkZXI6IEpvaW50IFwiJXNcIiBjb3VsZCBub3QgYmUgZm91bmQuJywgc2tpbkRlZi5qb2ludHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFNrZWxldG9uKGJvbmVzLCBib25lSW52ZXJzZXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjYW5pbWF0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gYW5pbWF0aW9uSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBbmltYXRpb25DbGlwPn1cbiAgICovXG4gIGxvYWRBbmltYXRpb24oYW5pbWF0aW9uSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRGVmID0ganNvbi5hbmltYXRpb25zW2FuaW1hdGlvbkluZGV4XTtcbiAgICBjb25zdCBhbmltYXRpb25OYW1lID0gYW5pbWF0aW9uRGVmLm5hbWUgPyBhbmltYXRpb25EZWYubmFtZSA6IFwiYW5pbWF0aW9uX1wiICsgYW5pbWF0aW9uSW5kZXg7XG4gICAgY29uc3QgcGVuZGluZ05vZGVzID0gW107XG4gICAgY29uc3QgcGVuZGluZ0lucHV0QWNjZXNzb3JzID0gW107XG4gICAgY29uc3QgcGVuZGluZ091dHB1dEFjY2Vzc29ycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdTYW1wbGVycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdUYXJnZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHNbaV07XG4gICAgICBjb25zdCBzYW1wbGVyID0gYW5pbWF0aW9uRGVmLnNhbXBsZXJzW2NoYW5uZWwuc2FtcGxlcl07XG4gICAgICBjb25zdCB0YXJnZXQgPSBjaGFubmVsLnRhcmdldDtcbiAgICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQubm9kZTtcbiAgICAgIGNvbnN0IGlucHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHZvaWQgMCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzW3NhbXBsZXIuaW5wdXRdIDogc2FtcGxlci5pbnB1dDtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB2b2lkIDAgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1tzYW1wbGVyLm91dHB1dF0gOiBzYW1wbGVyLm91dHB1dDtcbiAgICAgIGlmICh0YXJnZXQubm9kZSA9PT0gdm9pZCAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHBlbmRpbmdOb2Rlcy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgbmFtZSkpO1xuICAgICAgcGVuZGluZ0lucHV0QWNjZXNzb3JzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgaW5wdXQpKTtcbiAgICAgIHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBvdXRwdXQpKTtcbiAgICAgIHBlbmRpbmdTYW1wbGVycy5wdXNoKHNhbXBsZXIpO1xuICAgICAgcGVuZGluZ1RhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ05vZGVzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdJbnB1dEFjY2Vzc29ycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nT3V0cHV0QWNjZXNzb3JzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdTYW1wbGVycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nVGFyZ2V0cylcbiAgICBdKS50aGVuKGZ1bmN0aW9uKGRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3Qgbm9kZXMgPSBkZXBlbmRlbmNpZXNbMF07XG4gICAgICBjb25zdCBpbnB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1sxXTtcbiAgICAgIGNvbnN0IG91dHB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1syXTtcbiAgICAgIGNvbnN0IHNhbXBsZXJzID0gZGVwZW5kZW5jaWVzWzNdO1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IGRlcGVuZGVuY2llc1s0XTtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGNvbnN0IGlucHV0QWNjZXNzb3IgPSBpbnB1dEFjY2Vzc29yc1tpXTtcbiAgICAgICAgY29uc3Qgb3V0cHV0QWNjZXNzb3IgPSBvdXRwdXRBY2Nlc3NvcnNbaV07XG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1tpXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKG5vZGUudXBkYXRlTWF0cml4KSB7XG4gICAgICAgICAgbm9kZS51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVkVHJhY2tzID0gcGFyc2VyLl9jcmVhdGVBbmltYXRpb25UcmFja3Mobm9kZSwgaW5wdXRBY2Nlc3Nvciwgb3V0cHV0QWNjZXNzb3IsIHNhbXBsZXIsIHRhcmdldCk7XG4gICAgICAgIGlmIChjcmVhdGVkVHJhY2tzKSB7XG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjcmVhdGVkVHJhY2tzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB0cmFja3MucHVzaChjcmVhdGVkVHJhY2tzW2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcChhbmltYXRpb25OYW1lLCB2b2lkIDAsIHRyYWNrcyk7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgaWYgKG5vZGVEZWYubWVzaCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KFwibWVzaFwiLCBub2RlRGVmLm1lc2gpLnRoZW4oZnVuY3Rpb24obWVzaCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHBhcnNlci5fZ2V0Tm9kZVJlZihwYXJzZXIubWVzaENhY2hlLCBub2RlRGVmLm1lc2gsIG1lc2gpO1xuICAgICAgaWYgKG5vZGVEZWYud2VpZ2h0cyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG5vZGUudHJhdmVyc2UoZnVuY3Rpb24obykge1xuICAgICAgICAgIGlmICghby5pc01lc2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZURlZi53ZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICAgIG8ubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldID0gbm9kZURlZi53ZWlnaHRzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI25vZGVzLWFuZC1oaWVyYXJjaHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vZGVJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEPn1cbiAgICovXG4gIGxvYWROb2RlKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IG5vZGVQZW5kaW5nID0gcGFyc2VyLl9sb2FkTm9kZVNoYWxsb3cobm9kZUluZGV4KTtcbiAgICBjb25zdCBjaGlsZFBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBjaGlsZHJlbkRlZiA9IG5vZGVEZWYuY2hpbGRyZW4gfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gY2hpbGRyZW5EZWYubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY2hpbGRQZW5kaW5nLnB1c2gocGFyc2VyLmdldERlcGVuZGVuY3koXCJub2RlXCIsIGNoaWxkcmVuRGVmW2ldKSk7XG4gICAgfVxuICAgIGNvbnN0IHNrZWxldG9uUGVuZGluZyA9IG5vZGVEZWYuc2tpbiA9PT0gdm9pZCAwID8gUHJvbWlzZS5yZXNvbHZlKG51bGwpIDogcGFyc2VyLmdldERlcGVuZGVuY3koXCJza2luXCIsIG5vZGVEZWYuc2tpbik7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtub2RlUGVuZGluZywgUHJvbWlzZS5hbGwoY2hpbGRQZW5kaW5nKSwgc2tlbGV0b25QZW5kaW5nXSkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBub2RlID0gcmVzdWx0c1swXTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gcmVzdWx0c1sxXTtcbiAgICAgIGNvbnN0IHNrZWxldG9uID0gcmVzdWx0c1syXTtcbiAgICAgIGlmIChza2VsZXRvbiAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG1lc2gpIHtcbiAgICAgICAgICBpZiAoIW1lc2guaXNTa2lubmVkTWVzaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBtZXNoLmJpbmQoc2tlbGV0b24sIF9pZGVudGl0eU1hdHJpeCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBub2RlLmFkZChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuICAvLyAuX2xvYWROb2RlU2hhbGxvdygpIHBhcnNlcyBhIHNpbmdsZSBub2RlLlxuICAvLyBza2luIGFuZCBjaGlsZCBub2RlcyBhcmUgY3JlYXRlZCBhbmQgYWRkZWQgaW4gLmxvYWROb2RlKCkgKG5vICdfJyBwcmVmaXgpLlxuICBfbG9hZE5vZGVTaGFsbG93KG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGlmICh0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdO1xuICAgIH1cbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IG5vZGVOYW1lID0gbm9kZURlZi5uYW1lID8gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobm9kZURlZi5uYW1lKSA6IFwiXCI7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IG1lc2hQcm9taXNlID0gcGFyc2VyLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0LmNyZWF0ZU5vZGVNZXNoICYmIGV4dC5jcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpO1xuICAgIH0pO1xuICAgIGlmIChtZXNoUHJvbWlzZSkge1xuICAgICAgcGVuZGluZy5wdXNoKG1lc2hQcm9taXNlKTtcbiAgICB9XG4gICAgaWYgKG5vZGVEZWYuY2FtZXJhICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY3koXCJjYW1lcmFcIiwgbm9kZURlZi5jYW1lcmEpLnRoZW4oZnVuY3Rpb24oY2FtZXJhKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZihwYXJzZXIuY2FtZXJhQ2FjaGUsIG5vZGVEZWYuY2FtZXJhLCBjYW1lcmEpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcGFyc2VyLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50ICYmIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudChub2RlSW5kZXgpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgcGVuZGluZy5wdXNoKHByb21pc2UpO1xuICAgIH0pO1xuICAgIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF0gPSBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKG9iamVjdHMpIHtcbiAgICAgIGxldCBub2RlO1xuICAgICAgaWYgKG5vZGVEZWYuaXNCb25lID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgQm9uZSgpO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBHcm91cCgpO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBub2RlID0gb2JqZWN0c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgT2JqZWN0M0QoKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlICE9PSBvYmplY3RzWzBdKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIG5vZGUuYWRkKG9iamVjdHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZURlZi5uYW1lKSB7XG4gICAgICAgIG5vZGUudXNlckRhdGEubmFtZSA9IG5vZGVEZWYubmFtZTtcbiAgICAgICAgbm9kZS5uYW1lID0gbm9kZU5hbWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG5vZGUsIG5vZGVEZWYpO1xuICAgICAgaWYgKG5vZGVEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG5vZGUsIG5vZGVEZWYpO1xuICAgICAgaWYgKG5vZGVEZWYubWF0cml4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgbWF0cml4LmZyb21BcnJheShub2RlRGVmLm1hdHJpeCk7XG4gICAgICAgIG5vZGUuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZURlZi50cmFuc2xhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5wb3NpdGlvbi5mcm9tQXJyYXkobm9kZURlZi50cmFuc2xhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVEZWYucm90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUucXVhdGVybmlvbi5mcm9tQXJyYXkobm9kZURlZi5yb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVEZWYuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUuc2NhbGUuZnJvbUFycmF5KG5vZGVEZWYuc2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXBhcnNlci5hc3NvY2lhdGlvbnMuaGFzKG5vZGUpKSB7XG4gICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG5vZGUsIHt9KTtcbiAgICAgIH1cbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KG5vZGUpLm5vZGVzID0gbm9kZUluZGV4O1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNzY2VuZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjZW5lSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxHcm91cD59XG4gICAqL1xuICBsb2FkU2NlbmUoc2NlbmVJbmRleCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3Qgc2NlbmVEZWYgPSB0aGlzLmpzb24uc2NlbmVzW3NjZW5lSW5kZXhdO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgR3JvdXAoKTtcbiAgICBpZiAoc2NlbmVEZWYubmFtZSlcbiAgICAgIHNjZW5lLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShzY2VuZURlZi5uYW1lKTtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKHNjZW5lLCBzY2VuZURlZik7XG4gICAgaWYgKHNjZW5lRGVmLmV4dGVuc2lvbnMpXG4gICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgc2NlbmUsIHNjZW5lRGVmKTtcbiAgICBjb25zdCBub2RlSWRzID0gc2NlbmVEZWYubm9kZXMgfHwgW107XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVJZHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBub2RlSWRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIHNjZW5lLmFkZChub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWR1Y2VBc3NvY2lhdGlvbnMgPSAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCByZWR1Y2VkQXNzb2NpYXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcGFyc2VyLmFzc29jaWF0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBNYXRlcmlhbCB8fCBrZXkgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICByZWR1Y2VkQXNzb2NpYXRpb25zLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS50cmF2ZXJzZSgobm9kZTIpID0+IHtcbiAgICAgICAgICBjb25zdCBtYXBwaW5ncyA9IHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KG5vZGUyKTtcbiAgICAgICAgICBpZiAobWFwcGluZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVkdWNlZEFzc29jaWF0aW9ucy5zZXQobm9kZTIsIG1hcHBpbmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVkdWNlZEFzc29jaWF0aW9ucztcbiAgICAgIH07XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zID0gcmVkdWNlQXNzb2NpYXRpb25zKHNjZW5lKTtcbiAgICAgIHJldHVybiBzY2VuZTtcbiAgICB9KTtcbiAgfVxuICBfY3JlYXRlQW5pbWF0aW9uVHJhY2tzKG5vZGUsIGlucHV0QWNjZXNzb3IsIG91dHB1dEFjY2Vzc29yLCBzYW1wbGVyLCB0YXJnZXQpIHtcbiAgICBjb25zdCB0cmFja3MgPSBbXTtcbiAgICBjb25zdCB0YXJnZXROYW1lID0gbm9kZS5uYW1lID8gbm9kZS5uYW1lIDogbm9kZS51dWlkO1xuICAgIGNvbnN0IHRhcmdldE5hbWVzID0gW107XG4gICAgaWYgKFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0gPT09IFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzKSB7XG4gICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcykge1xuICAgICAgICAgIHRhcmdldE5hbWVzLnB1c2gob2JqZWN0Lm5hbWUgPyBvYmplY3QubmFtZSA6IG9iamVjdC51dWlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldE5hbWVzLnB1c2godGFyZ2V0TmFtZSk7XG4gICAgfVxuICAgIGxldCBUeXBlZEtleWZyYW1lVHJhY2s7XG4gICAgc3dpdGNoIChQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdKSB7XG4gICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzOlxuICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnJvdGF0aW9uOlxuICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5wb3NpdGlvbjpcbiAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnNjYWxlOlxuICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN3aXRjaCAob3V0cHV0QWNjZXNzb3IuaXRlbVNpemUpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnBvbGF0aW9uID0gc2FtcGxlci5pbnRlcnBvbGF0aW9uICE9PSB2b2lkIDAgPyBJTlRFUlBPTEFUSU9OW3NhbXBsZXIuaW50ZXJwb2xhdGlvbl0gOiBJbnRlcnBvbGF0ZUxpbmVhcjtcbiAgICBjb25zdCBvdXRwdXRBcnJheSA9IHRoaXMuX2dldEFycmF5RnJvbUFjY2Vzc29yKG91dHB1dEFjY2Vzc29yKTtcbiAgICBmb3IgKGxldCBqID0gMCwgamwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICBjb25zdCB0cmFjayA9IG5ldyBUeXBlZEtleWZyYW1lVHJhY2soXG4gICAgICAgIHRhcmdldE5hbWVzW2pdICsgXCIuXCIgKyBQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdLFxuICAgICAgICBpbnB1dEFjY2Vzc29yLmFycmF5LFxuICAgICAgICBvdXRwdXRBcnJheSxcbiAgICAgICAgaW50ZXJwb2xhdGlvblxuICAgICAgKTtcbiAgICAgIGlmIChzYW1wbGVyLmludGVycG9sYXRpb24gPT09IFwiQ1VCSUNTUExJTkVcIikge1xuICAgICAgICB0aGlzLl9jcmVhdGVDdWJpY1NwbGluZVRyYWNrSW50ZXJwb2xhbnQodHJhY2spO1xuICAgICAgfVxuICAgICAgdHJhY2tzLnB1c2godHJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2tzO1xuICB9XG4gIF9nZXRBcnJheUZyb21BY2Nlc3NvcihhY2Nlc3Nvcikge1xuICAgIGxldCBvdXRwdXRBcnJheSA9IGFjY2Vzc29yLmFycmF5O1xuICAgIGlmIChhY2Nlc3Nvci5ub3JtYWxpemVkKSB7XG4gICAgICBjb25zdCBzY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShvdXRwdXRBcnJheS5jb25zdHJ1Y3Rvcik7XG4gICAgICBjb25zdCBzY2FsZWQgPSBuZXcgRmxvYXQzMkFycmF5KG91dHB1dEFycmF5Lmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBvdXRwdXRBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgIHNjYWxlZFtqXSA9IG91dHB1dEFycmF5W2pdICogc2NhbGU7XG4gICAgICB9XG4gICAgICBvdXRwdXRBcnJheSA9IHNjYWxlZDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dEFycmF5O1xuICB9XG4gIF9jcmVhdGVDdWJpY1NwbGluZVRyYWNrSW50ZXJwb2xhbnQodHJhY2spIHtcbiAgICB0cmFjay5jcmVhdGVJbnRlcnBvbGFudCA9IGZ1bmN0aW9uIEludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZShyZXN1bHQpIHtcbiAgICAgIGNvbnN0IGludGVycG9sYW50VHlwZSA9IHRoaXMgaW5zdGFuY2VvZiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayA/IEdMVEZDdWJpY1NwbGluZVF1YXRlcm5pb25JbnRlcnBvbGFudCA6IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50O1xuICAgICAgcmV0dXJuIG5ldyBpbnRlcnBvbGFudFR5cGUodGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCkgLyAzLCByZXN1bHQpO1xuICAgIH07XG4gICAgdHJhY2suY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IGJveCA9IG5ldyBCb3gzKCk7XG4gIGlmIChhdHRyaWJ1dGVzLlBPU0lUSU9OICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1thdHRyaWJ1dGVzLlBPU0lUSU9OXTtcbiAgICBjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG4gICAgY29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuICAgIGlmIChtaW4gIT09IHZvaWQgMCAmJiBtYXggIT09IHZvaWQgMCkge1xuICAgICAgYm94LnNldChuZXcgVmVjdG9yMyhtaW5bMF0sIG1pblsxXSwgbWluWzJdKSwgbmV3IFZlY3RvcjMobWF4WzBdLCBtYXhbMV0sIG1heFsyXSkpO1xuICAgICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yLmNvbXBvbmVudFR5cGVdKTtcbiAgICAgICAgYm94Lm1pbi5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICAgIGJveC5tYXgubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0cyA9IHByaW1pdGl2ZURlZi50YXJnZXRzO1xuICBpZiAodGFyZ2V0cyAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgbWF4RGlzcGxhY2VtZW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgIGlmICh0YXJnZXQuUE9TSVRJT04gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1t0YXJnZXQuUE9TSVRJT05dO1xuICAgICAgICBjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IGFjY2Vzc29yLm1heDtcbiAgICAgICAgaWYgKG1pbiAhPT0gdm9pZCAwICYmIG1heCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmVjdG9yLnNldFgoTWF0aC5tYXgoTWF0aC5hYnMobWluWzBdKSwgTWF0aC5hYnMobWF4WzBdKSkpO1xuICAgICAgICAgIHZlY3Rvci5zZXRZKE1hdGgubWF4KE1hdGguYWJzKG1pblsxXSksIE1hdGguYWJzKG1heFsxXSkpKTtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WihNYXRoLm1heChNYXRoLmFicyhtaW5bMl0pLCBNYXRoLmFicyhtYXhbMl0pKSk7XG4gICAgICAgICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJveFNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3Nvci5jb21wb25lbnRUeXBlXSk7XG4gICAgICAgICAgICB2ZWN0b3IubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXhEaXNwbGFjZW1lbnQubWF4KHZlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBib3guZXhwYW5kQnlWZWN0b3IobWF4RGlzcGxhY2VtZW50KTtcbiAgfVxuICBnZW9tZXRyeS5ib3VuZGluZ0JveCA9IGJveDtcbiAgY29uc3Qgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICBib3guZ2V0Q2VudGVyKHNwaGVyZS5jZW50ZXIpO1xuICBzcGhlcmUucmFkaXVzID0gYm94Lm1pbi5kaXN0YW5jZVRvKGJveC5tYXgpIC8gMjtcbiAgZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBzcGhlcmU7XG59XG5mdW5jdGlvbiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgZnVuY3Rpb24gYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoYWNjZXNzb3JJbmRleCwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIGFjY2Vzc29ySW5kZXgpLnRoZW4oZnVuY3Rpb24oYWNjZXNzb3IpIHtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhY2Nlc3Nvcik7XG4gICAgfSk7XG4gIH1cbiAgZm9yIChjb25zdCBnbHRmQXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1tnbHRmQXR0cmlidXRlTmFtZV0gfHwgZ2x0ZkF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGhyZWVBdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpXG4gICAgICBjb250aW51ZTtcbiAgICBwZW5kaW5nLnB1c2goYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoYXR0cmlidXRlc1tnbHRmQXR0cmlidXRlTmFtZV0sIHRocmVlQXR0cmlidXRlTmFtZSkpO1xuICB9XG4gIGlmIChwcmltaXRpdmVEZWYuaW5kaWNlcyAhPT0gdm9pZCAwICYmICFnZW9tZXRyeS5pbmRleCkge1xuICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBwcmltaXRpdmVEZWYuaW5kaWNlcykudGhlbihmdW5jdGlvbihhY2Nlc3NvcjIpIHtcbiAgICAgIGdlb21ldHJ5LnNldEluZGV4KGFjY2Vzc29yMik7XG4gICAgfSk7XG4gICAgcGVuZGluZy5wdXNoKGFjY2Vzc29yKTtcbiAgfVxuICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYpO1xuICBjb21wdXRlQm91bmRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcik7XG4gIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdm9pZCAwID8gYWRkTW9ycGhUYXJnZXRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYudGFyZ2V0cywgcGFyc2VyKSA6IGdlb21ldHJ5O1xuICB9KTtcbn1cbmV4cG9ydCB7XG4gIEdMVEZMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTFRGTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkxvYWRlciIsIkxvYWRlclV0aWxzIiwiRmlsZUxvYWRlciIsIkNvbG9yIiwiU3BvdExpZ2h0IiwiUG9pbnRMaWdodCIsIkRpcmVjdGlvbmFsTGlnaHQiLCJNZXNoQmFzaWNNYXRlcmlhbCIsIk1lc2hQaHlzaWNhbE1hdGVyaWFsIiwiVmVjdG9yMiIsIk1hdHJpeDQiLCJWZWN0b3IzIiwiUXVhdGVybmlvbiIsIkluc3RhbmNlZE1lc2giLCJJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUiLCJPYmplY3QzRCIsIlRleHR1cmVMb2FkZXIiLCJJbWFnZUJpdG1hcExvYWRlciIsIkJ1ZmZlckF0dHJpYnV0ZSIsIkludGVybGVhdmVkQnVmZmVyIiwiSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUiLCJMaW5lYXJGaWx0ZXIiLCJMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIiLCJSZXBlYXRXcmFwcGluZyIsIlBvaW50c01hdGVyaWFsIiwiTWF0ZXJpYWwiLCJMaW5lQmFzaWNNYXRlcmlhbCIsIk1lc2hTdGFuZGFyZE1hdGVyaWFsIiwiRG91YmxlU2lkZSIsIlByb3BlcnR5QmluZGluZyIsIkJ1ZmZlckdlb21ldHJ5IiwiU2tpbm5lZE1lc2giLCJNZXNoIiwiVHJpYW5nbGVTdHJpcERyYXdNb2RlIiwiVHJpYW5nbGVGYW5EcmF3TW9kZSIsIkxpbmVTZWdtZW50cyIsIkxpbmUiLCJMaW5lTG9vcCIsIlBvaW50cyIsIkdyb3VwIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJNYXRoVXRpbHMiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJTa2VsZXRvbiIsIkFuaW1hdGlvbkNsaXAiLCJCb25lIiwiSW50ZXJwb2xhdGVMaW5lYXIiLCJOZWFyZXN0RmlsdGVyIiwiTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIiLCJMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyIiwiTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciIsIkNsYW1wVG9FZGdlV3JhcHBpbmciLCJNaXJyb3JlZFJlcGVhdFdyYXBwaW5nIiwiSW50ZXJwb2xhdGVEaXNjcmV0ZSIsIkZyb250U2lkZSIsIlRleHR1cmUiLCJWZWN0b3JLZXlmcmFtZVRyYWNrIiwiTnVtYmVyS2V5ZnJhbWVUcmFjayIsIlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrIiwiQm94MyIsIlNwaGVyZSIsIkludGVycG9sYW50IiwidG9UcmlhbmdsZXNEcmF3TW9kZSIsInZlcnNpb24iLCJkZWNvZGVUZXh0IiwiU1JHQkNvbG9yU3BhY2UiLCJMaW5lYXJTUkdCQ29sb3JTcGFjZSIsInNSR0JFbmNvZGluZyIsIkxpbmVhckVuY29kaW5nIiwiR0xURkxvYWRlciIsImNvbnN0cnVjdG9yIiwibWFuYWdlciIsImRyYWNvTG9hZGVyIiwia3R4MkxvYWRlciIsIm1lc2hvcHREZWNvZGVyIiwicGx1Z2luQ2FsbGJhY2tzIiwicmVnaXN0ZXIiLCJwYXJzZXIiLCJHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0Rpc3BlcnNpb25FeHRlbnNpb24iLCJHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbiIsIkdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiIsIkdMVEZUZXh0dXJlQVZJRkV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzVm9sdW1lRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0lvckV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc1NwZWN1bGFyRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0lyaWRlc2NlbmNlRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzQnVtcEV4dGVuc2lvbiIsIkdMVEZMaWdodHNFeHRlbnNpb24iLCJHTFRGTWVzaG9wdENvbXByZXNzaW9uIiwiR0xURk1lc2hHcHVJbnN0YW5jaW5nIiwibG9hZCIsInVybCIsIm9uTG9hZCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwic2NvcGUiLCJyZXNvdXJjZVBhdGgiLCJwYXRoIiwicmVsYXRpdmVVcmwiLCJleHRyYWN0VXJsQmFzZSIsInJlc29sdmVVUkwiLCJpdGVtU3RhcnQiLCJfb25FcnJvciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJpdGVtRXJyb3IiLCJpdGVtRW5kIiwibG9hZGVyIiwic2V0UGF0aCIsInNldFJlc3BvbnNlVHlwZSIsInNldFJlcXVlc3RIZWFkZXIiLCJyZXF1ZXN0SGVhZGVyIiwic2V0V2l0aENyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiZGF0YSIsInBhcnNlIiwiZ2x0ZiIsInNldERSQUNPTG9hZGVyIiwic2V0RERTTG9hZGVyIiwiRXJyb3IiLCJzZXRLVFgyTG9hZGVyIiwic2V0TWVzaG9wdERlY29kZXIiLCJjYWxsYmFjayIsImluZGV4T2YiLCJwdXNoIiwidW5yZWdpc3RlciIsInNwbGljZSIsImpzb24iLCJleHRlbnNpb25zIiwicGx1Z2lucyIsIkpTT04iLCJBcnJheUJ1ZmZlciIsIm1hZ2ljIiwiVWludDhBcnJheSIsInNsaWNlIiwiQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMiLCJFWFRFTlNJT05TIiwiS0hSX0JJTkFSWV9HTFRGIiwiR0xURkJpbmFyeUV4dGVuc2lvbiIsImNvbnRlbnQiLCJhc3NldCIsIkdMVEZQYXJzZXIiLCJjcm9zc09yaWdpbiIsImZpbGVMb2FkZXIiLCJpIiwibGVuZ3RoIiwicGx1Z2luIiwibmFtZSIsImV4dGVuc2lvbnNVc2VkIiwiZXh0ZW5zaW9uTmFtZSIsImV4dGVuc2lvbnNSZXF1aXJlZCIsIktIUl9NQVRFUklBTFNfVU5MSVQiLCJHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24iLCJLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiIsIkdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbiIsIktIUl9URVhUVVJFX1RSQU5TRk9STSIsIkdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uIiwiS0hSX01FU0hfUVVBTlRJWkFUSU9OIiwiR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24iLCJ3YXJuIiwic2V0RXh0ZW5zaW9ucyIsInNldFBsdWdpbnMiLCJwYXJzZUFzeW5jIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJHTFRGUmVnaXN0cnkiLCJvYmplY3RzIiwiZ2V0Iiwia2V5IiwiYWRkIiwib2JqZWN0IiwicmVtb3ZlIiwicmVtb3ZlQWxsIiwiS0hSX0xJR0hUU19QVU5DVFVBTCIsIktIUl9NQVRFUklBTFNfQ0xFQVJDT0FUIiwiS0hSX01BVEVSSUFMU19ESVNQRVJTSU9OIiwiS0hSX01BVEVSSUFMU19JT1IiLCJLSFJfTUFURVJJQUxTX1NIRUVOIiwiS0hSX01BVEVSSUFMU19TUEVDVUxBUiIsIktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OIiwiS0hSX01BVEVSSUFMU19JUklERVNDRU5DRSIsIktIUl9NQVRFUklBTFNfQU5JU09UUk9QWSIsIktIUl9NQVRFUklBTFNfVk9MVU1FIiwiS0hSX1RFWFRVUkVfQkFTSVNVIiwiS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSCIsIkVYVF9NQVRFUklBTFNfQlVNUCIsIkVYVF9URVhUVVJFX1dFQlAiLCJFWFRfVEVYVFVSRV9BVklGIiwiRVhUX01FU0hPUFRfQ09NUFJFU1NJT04iLCJFWFRfTUVTSF9HUFVfSU5TVEFOQ0lORyIsImNhY2hlIiwicmVmcyIsInVzZXMiLCJfbWFya0RlZnMiLCJub2RlRGVmcyIsIm5vZGVzIiwibm9kZUluZGV4Iiwibm9kZUxlbmd0aCIsIm5vZGVEZWYiLCJsaWdodCIsIl9hZGROb2RlUmVmIiwiX2xvYWRMaWdodCIsImxpZ2h0SW5kZXgiLCJjYWNoZUtleSIsImRlcGVuZGVuY3kiLCJsaWdodERlZnMiLCJsaWdodHMiLCJsaWdodERlZiIsImxpZ2h0Tm9kZSIsImNvbG9yIiwic2V0UkdCIiwicmFuZ2UiLCJ0eXBlIiwidGFyZ2V0IiwicG9zaXRpb24iLCJzZXQiLCJkaXN0YW5jZSIsInNwb3QiLCJpbm5lckNvbmVBbmdsZSIsIm91dGVyQ29uZUFuZ2xlIiwiTWF0aCIsIlBJIiwiYW5nbGUiLCJwZW51bWJyYSIsImRlY2F5IiwiYXNzaWduRXh0cmFzVG9Vc2VyRGF0YSIsImludGVuc2l0eSIsImNyZWF0ZVVuaXF1ZU5hbWUiLCJnZXREZXBlbmRlbmN5IiwiaW5kZXgiLCJjcmVhdGVOb2RlQXR0YWNobWVudCIsInNlbGYyIiwidGhlbiIsIl9nZXROb2RlUmVmIiwiZ2V0TWF0ZXJpYWxUeXBlIiwiZXh0ZW5kUGFyYW1zIiwibWF0ZXJpYWxQYXJhbXMiLCJtYXRlcmlhbERlZiIsInBlbmRpbmciLCJvcGFjaXR5IiwibWV0YWxsaWNSb3VnaG5lc3MiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyIsIkFycmF5IiwiaXNBcnJheSIsImJhc2VDb2xvckZhY3RvciIsImFycmF5IiwiYmFzZUNvbG9yVGV4dHVyZSIsImFzc2lnblRleHR1cmUiLCJhbGwiLCJleHRlbmRNYXRlcmlhbFBhcmFtcyIsIm1hdGVyaWFsSW5kZXgiLCJtYXRlcmlhbHMiLCJlbWlzc2l2ZVN0cmVuZ3RoIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJleHRlbnNpb24iLCJjbGVhcmNvYXRGYWN0b3IiLCJjbGVhcmNvYXQiLCJjbGVhcmNvYXRUZXh0dXJlIiwiY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yIiwiY2xlYXJjb2F0Um91Z2huZXNzIiwiY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSIsImNsZWFyY29hdE5vcm1hbFRleHR1cmUiLCJzY2FsZSIsImNsZWFyY29hdE5vcm1hbFNjYWxlIiwiZGlzcGVyc2lvbiIsImlyaWRlc2NlbmNlRmFjdG9yIiwiaXJpZGVzY2VuY2UiLCJpcmlkZXNjZW5jZVRleHR1cmUiLCJpcmlkZXNjZW5jZUlvciIsImlyaWRlc2NlbmNlSU9SIiwiaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSIsInNoZWVuQ29sb3IiLCJzaGVlblJvdWdobmVzcyIsInNoZWVuIiwic2hlZW5Db2xvckZhY3RvciIsImNvbG9yRmFjdG9yIiwic2hlZW5Sb3VnaG5lc3NGYWN0b3IiLCJzaGVlbkNvbG9yVGV4dHVyZSIsInNoZWVuUm91Z2huZXNzVGV4dHVyZSIsInRyYW5zbWlzc2lvbkZhY3RvciIsInRyYW5zbWlzc2lvbiIsInRyYW5zbWlzc2lvblRleHR1cmUiLCJ0aGlja25lc3MiLCJ0aGlja25lc3NGYWN0b3IiLCJ0aGlja25lc3NUZXh0dXJlIiwiYXR0ZW51YXRpb25EaXN0YW5jZSIsIkluZmluaXR5IiwiY29sb3JBcnJheSIsImF0dGVudWF0aW9uQ29sb3IiLCJpb3IiLCJzcGVjdWxhckludGVuc2l0eSIsInNwZWN1bGFyRmFjdG9yIiwic3BlY3VsYXJUZXh0dXJlIiwic3BlY3VsYXJDb2xvckZhY3RvciIsInNwZWN1bGFyQ29sb3IiLCJzcGVjdWxhckNvbG9yVGV4dHVyZSIsImJ1bXBTY2FsZSIsImJ1bXBGYWN0b3IiLCJidW1wVGV4dHVyZSIsImFuaXNvdHJvcHlTdHJlbmd0aCIsImFuaXNvdHJvcHkiLCJhbmlzb3Ryb3B5Um90YXRpb24iLCJhbmlzb3Ryb3B5VGV4dHVyZSIsImxvYWRUZXh0dXJlIiwidGV4dHVyZUluZGV4IiwidGV4dHVyZURlZiIsInRleHR1cmVzIiwib3B0aW9ucyIsImxvYWRUZXh0dXJlSW1hZ2UiLCJzb3VyY2UiLCJpc1N1cHBvcnRlZCIsImltYWdlcyIsInRleHR1cmVMb2FkZXIiLCJ1cmkiLCJoYW5kbGVyIiwiZ2V0SGFuZGxlciIsImRldGVjdFN1cHBvcnQiLCJpbWFnZSIsIkltYWdlIiwic3JjIiwib25sb2FkIiwib25lcnJvciIsImhlaWdodCIsImxvYWRCdWZmZXJWaWV3IiwiYnVmZmVyVmlldyIsImJ1ZmZlclZpZXdzIiwiZXh0ZW5zaW9uRGVmIiwiYnVmZmVyIiwiZGVjb2RlciIsInN1cHBvcnRlZCIsInJlcyIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiY291bnQiLCJzdHJpZGUiLCJieXRlU3RyaWRlIiwiZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jIiwibW9kZSIsImZpbHRlciIsInJlczIiLCJyZWFkeSIsInJlc3VsdCIsImRlY29kZUdsdGZCdWZmZXIiLCJjcmVhdGVOb2RlTWVzaCIsIm1lc2giLCJtZXNoRGVmIiwibWVzaGVzIiwicHJpbWl0aXZlIiwicHJpbWl0aXZlcyIsIldFQkdMX0NPTlNUQU5UUyIsIlRSSUFOR0xFUyIsIlRSSUFOR0xFX1NUUklQIiwiVFJJQU5HTEVfRkFOIiwiYXR0cmlidXRlc0RlZiIsImF0dHJpYnV0ZXMiLCJhY2Nlc3NvciIsInJlc3VsdHMiLCJub2RlT2JqZWN0IiwicG9wIiwiaXNHcm91cCIsImNoaWxkcmVuIiwiaW5zdGFuY2VkTWVzaGVzIiwibSIsInAiLCJxIiwicyIsImluc3RhbmNlZE1lc2giLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiVFJBTlNMQVRJT04iLCJmcm9tQnVmZmVyQXR0cmlidXRlIiwiUk9UQVRJT04iLCJTQ0FMRSIsInNldE1hdHJpeEF0IiwiY29tcG9zZSIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyIiwiaW5zdGFuY2VDb2xvciIsIml0ZW1TaXplIiwibm9ybWFsaXplZCIsInNldEF0dHJpYnV0ZSIsInByb3RvdHlwZSIsImNvcHkiLCJjYWxsIiwiYXNzaWduRmluYWxNYXRlcmlhbCIsImNsZWFyIiwiQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIIiwiQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUyIsIkJJTiIsImJvZHkiLCJoZWFkZXJWaWV3IiwiRGF0YVZpZXciLCJoZWFkZXIiLCJnZXRVaW50MzIiLCJjaHVua0NvbnRlbnRzTGVuZ3RoIiwiY2h1bmtWaWV3IiwiY2h1bmtJbmRleCIsImNodW5rTGVuZ3RoIiwiY2h1bmtUeXBlIiwiY29udGVudEFycmF5IiwicHJlbG9hZCIsImRlY29kZVByaW1pdGl2ZSIsImJ1ZmZlclZpZXdJbmRleCIsImdsdGZBdHRyaWJ1dGVNYXAiLCJ0aHJlZUF0dHJpYnV0ZU1hcCIsImF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXAiLCJhdHRyaWJ1dGVUeXBlTWFwIiwidGhyZWVBdHRyaWJ1dGVOYW1lIiwiQVRUUklCVVRFUyIsInRvTG93ZXJDYXNlIiwiYWNjZXNzb3JEZWYiLCJhY2Nlc3NvcnMiLCJjb21wb25lbnRUeXBlIiwiV0VCR0xfQ09NUE9ORU5UX1RZUEVTIiwiZGVjb2RlRHJhY29GaWxlIiwiYXR0cmlidXRlIiwiZXh0ZW5kVGV4dHVyZSIsInRleHR1cmUiLCJ0cmFuc2Zvcm0iLCJ0ZXhDb29yZCIsImNoYW5uZWwiLCJvZmZzZXQiLCJyb3RhdGlvbiIsImNsb25lIiwiZnJvbUFycmF5IiwicmVwZWF0IiwibmVlZHNVcGRhdGUiLCJHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCIsInBhcmFtZXRlclBvc2l0aW9ucyIsInNhbXBsZVZhbHVlcyIsInNhbXBsZVNpemUiLCJyZXN1bHRCdWZmZXIiLCJjb3B5U2FtcGxlVmFsdWVfIiwidmFsdWVzIiwidmFsdWVTaXplIiwiaW50ZXJwb2xhdGVfIiwiaTEiLCJ0MCIsInQiLCJ0MSIsInN0cmlkZTIiLCJzdHJpZGUzIiwidGQiLCJwcCIsInBwcCIsIm9mZnNldDEiLCJvZmZzZXQwIiwiczIiLCJzMyIsInMwIiwiczEiLCJwMCIsIm0wIiwicDEiLCJtMSIsIl9xIiwiR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50Iiwibm9ybWFsaXplIiwidG9BcnJheSIsIkZMT0FUIiwiRkxPQVRfTUFUMyIsIkZMT0FUX01BVDQiLCJGTE9BVF9WRUMyIiwiRkxPQVRfVkVDMyIsIkZMT0FUX1ZFQzQiLCJMSU5FQVIiLCJSRVBFQVQiLCJTQU1QTEVSXzJEIiwiUE9JTlRTIiwiTElORVMiLCJMSU5FX0xPT1AiLCJMSU5FX1NUUklQIiwiVU5TSUdORURfQllURSIsIlVOU0lHTkVEX1NIT1JUIiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJXRUJHTF9GSUxURVJTIiwiV0VCR0xfV1JBUFBJTkdTIiwiV0VCR0xfVFlQRV9TSVpFUyIsIlNDQUxBUiIsIlZFQzIiLCJWRUMzIiwiVkVDNCIsIk1BVDIiLCJNQVQzIiwiTUFUNCIsIlBPU0lUSU9OIiwiTk9STUFMIiwiVEFOR0VOVCIsIlRFWENPT1JEXzAiLCJURVhDT09SRF8xIiwiVEVYQ09PUkRfMiIsIlRFWENPT1JEXzMiLCJDT0xPUl8wIiwiV0VJR0hUU18wIiwiSk9JTlRTXzAiLCJQQVRIX1BST1BFUlRJRVMiLCJ0cmFuc2xhdGlvbiIsIndlaWdodHMiLCJJTlRFUlBPTEFUSU9OIiwiQ1VCSUNTUExJTkUiLCJTVEVQIiwiQUxQSEFfTU9ERVMiLCJPUEFRVUUiLCJNQVNLIiwiQkxFTkQiLCJjcmVhdGVEZWZhdWx0TWF0ZXJpYWwiLCJlbWlzc2l2ZSIsIm1ldGFsbmVzcyIsInJvdWdobmVzcyIsInRyYW5zcGFyZW50IiwiZGVwdGhUZXN0Iiwic2lkZSIsImFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSIsImtub3duRXh0ZW5zaW9ucyIsIm9iamVjdERlZiIsInVzZXJEYXRhIiwiZ2x0ZkV4dGVuc2lvbnMiLCJnbHRmRGVmIiwiZXh0cmFzIiwiT2JqZWN0IiwiYXNzaWduIiwiYWRkTW9ycGhUYXJnZXRzIiwidGFyZ2V0cyIsImhhc01vcnBoUG9zaXRpb24iLCJoYXNNb3JwaE5vcm1hbCIsImhhc01vcnBoQ29sb3IiLCJpbCIsInBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyIsInBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMiLCJwZW5kaW5nQ29sb3JBY2Nlc3NvcnMiLCJwZW5kaW5nQWNjZXNzb3IiLCJub3JtYWwiLCJtb3JwaFBvc2l0aW9ucyIsIm1vcnBoTm9ybWFscyIsIm1vcnBoQ29sb3JzIiwibW9ycGhBdHRyaWJ1dGVzIiwibW9ycGhUYXJnZXRzUmVsYXRpdmUiLCJ1cGRhdGVNb3JwaFRhcmdldHMiLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLCJ0YXJnZXROYW1lcyIsIm1vcnBoVGFyZ2V0RGljdGlvbmFyeSIsImNyZWF0ZVByaW1pdGl2ZUtleSIsInByaW1pdGl2ZURlZiIsImdlb21ldHJ5S2V5IiwiZHJhY29FeHRlbnNpb24iLCJpbmRpY2VzIiwiY3JlYXRlQXR0cmlidXRlc0tleSIsImF0dHJpYnV0ZXNLZXkiLCJrZXlzIiwic29ydCIsImdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZSIsImdldEltYWdlVVJJTWltZVR5cGUiLCJzZWFyY2giLCJfaWRlbnRpdHlNYXRyaXgiLCJhc3NvY2lhdGlvbnMiLCJNYXAiLCJwcmltaXRpdmVDYWNoZSIsIm5vZGVDYWNoZSIsIm1lc2hDYWNoZSIsImNhbWVyYUNhY2hlIiwibGlnaHRDYWNoZSIsInNvdXJjZUNhY2hlIiwidGV4dHVyZUNhY2hlIiwibm9kZU5hbWVzVXNlZCIsImlzU2FmYXJpIiwiaXNGaXJlZm94IiwiZmlyZWZveFZlcnNpb24iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0ZXN0IiwibWF0Y2giLCJjcmVhdGVJbWFnZUJpdG1hcCIsInNldENyb3NzT3JpZ2luIiwiX2ludm9rZUFsbCIsImV4dCIsImJlZm9yZVJvb3QiLCJnZXREZXBlbmRlbmNpZXMiLCJkZXBlbmRlbmNpZXMiLCJzY2VuZSIsInNjZW5lcyIsImFuaW1hdGlvbnMiLCJjYW1lcmFzIiwiYWZ0ZXJSb290IiwidXBkYXRlTWF0cml4V29ybGQiLCJjYXRjaCIsInNraW5EZWZzIiwic2tpbnMiLCJtZXNoRGVmcyIsInNraW5JbmRleCIsInNraW5MZW5ndGgiLCJqb2ludHMiLCJpc0JvbmUiLCJza2luIiwiaXNTa2lubmVkTWVzaCIsImNhbWVyYSIsInJlZiIsInVwZGF0ZU1hcHBpbmdzIiwib3JpZ2luYWwiLCJtYXBwaW5ncyIsImNoaWxkIiwiZW50cmllcyIsIl9pbnZva2VPbmUiLCJmdW5jIiwidW5zaGlmdCIsImxvYWRTY2VuZSIsImxvYWROb2RlIiwibG9hZE1lc2giLCJsb2FkQWNjZXNzb3IiLCJsb2FkQnVmZmVyIiwibG9hZE1hdGVyaWFsIiwibG9hZFNraW4iLCJsb2FkQW5pbWF0aW9uIiwibG9hZENhbWVyYSIsImRlZnMiLCJtYXAiLCJkZWYiLCJidWZmZXJJbmRleCIsImJ1ZmZlckRlZiIsImJ1ZmZlcnMiLCJidWZmZXJWaWV3RGVmIiwiYWNjZXNzb3JJbmRleCIsInNwYXJzZSIsIlR5cGVkQXJyYXkiLCJwZW5kaW5nQnVmZmVyVmlld3MiLCJlbGVtZW50Qnl0ZXMiLCJCWVRFU19QRVJfRUxFTUVOVCIsIml0ZW1CeXRlcyIsImJ1ZmZlckF0dHJpYnV0ZSIsImliU2xpY2UiLCJmbG9vciIsImliQ2FjaGVLZXkiLCJpYiIsIml0ZW1TaXplSW5kaWNlcyIsIlR5cGVkQXJyYXlJbmRpY2VzIiwiYnl0ZU9mZnNldEluZGljZXMiLCJieXRlT2Zmc2V0VmFsdWVzIiwic3BhcnNlSW5kaWNlcyIsInNwYXJzZVZhbHVlcyIsInNldFgiLCJzZXRZIiwic2V0WiIsInNldFciLCJzb3VyY2VJbmRleCIsInNvdXJjZURlZiIsInNhbXBsZXIiLCJwcm9taXNlIiwibG9hZEltYWdlU291cmNlIiwiZmxpcFkiLCJzdGFydHNXaXRoIiwic2FtcGxlcnMiLCJtYWdGaWx0ZXIiLCJtaW5GaWx0ZXIiLCJ3cmFwUyIsIndyYXBUIiwiVVJMIiwic2VsZiIsIndlYmtpdFVSTCIsInNvdXJjZVVSSSIsImlzT2JqZWN0VVJMIiwiYmxvYiIsIkJsb2IiLCJtaW1lVHlwZSIsImNyZWF0ZU9iamVjdFVSTCIsInNvdXJjZVVSSTIiLCJpc0ltYWdlQml0bWFwTG9hZGVyIiwiaW1hZ2VCaXRtYXAiLCJyZXZva2VPYmplY3RVUkwiLCJtYXBOYW1lIiwibWFwRGVmIiwiY29sb3JTcGFjZSIsImdsdGZSZWZlcmVuY2UiLCJlbmNvZGluZyIsInVzZURlcml2YXRpdmVUYW5nZW50cyIsInRhbmdlbnQiLCJ1c2VWZXJ0ZXhDb2xvcnMiLCJ1c2VGbGF0U2hhZGluZyIsImlzUG9pbnRzIiwidXVpZCIsInBvaW50c01hdGVyaWFsIiwic2l6ZUF0dGVudWF0aW9uIiwiaXNMaW5lIiwibGluZU1hdGVyaWFsIiwiY2FjaGVkTWF0ZXJpYWwiLCJ2ZXJ0ZXhDb2xvcnMiLCJmbGF0U2hhZGluZyIsIm5vcm1hbFNjYWxlIiwieSIsIm1hdGVyaWFsVHlwZSIsIm1hdGVyaWFsRXh0ZW5zaW9ucyIsImttdUV4dGVuc2lvbiIsIm1ldGFsbGljRmFjdG9yIiwicm91Z2huZXNzRmFjdG9yIiwibWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlIiwiZG91YmxlU2lkZWQiLCJhbHBoYU1vZGUiLCJkZXB0aFdyaXRlIiwiYWxwaGFUZXN0IiwiYWxwaGFDdXRvZmYiLCJub3JtYWxUZXh0dXJlIiwib2NjbHVzaW9uVGV4dHVyZSIsInN0cmVuZ3RoIiwiYW9NYXBJbnRlbnNpdHkiLCJlbWlzc2l2ZUZhY3RvciIsImVtaXNzaXZlVGV4dHVyZSIsIm9yaWdpbmFsTmFtZSIsInNhbml0aXplZE5hbWUiLCJzYW5pdGl6ZU5vZGVOYW1lIiwibG9hZEdlb21ldHJpZXMiLCJjcmVhdGVEcmFjb1ByaW1pdGl2ZSIsImFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMiLCJjYWNoZWQiLCJnZW9tZXRyeVByb21pc2UiLCJtZXNoSW5kZXgiLCJnZW9tZXRyaWVzIiwibm9ybWFsaXplU2tpbldlaWdodHMiLCJncm91cCIsImNhbWVyYUluZGV4IiwiY2FtZXJhRGVmIiwicGFyYW1zIiwicmFkVG9EZWciLCJ5Zm92IiwiYXNwZWN0UmF0aW8iLCJ6bmVhciIsInpmYXIiLCJ4bWFnIiwieW1hZyIsInNraW5EZWYiLCJfbG9hZE5vZGVTaGFsbG93IiwiaW52ZXJzZUJpbmRNYXRyaWNlcyIsImpvaW50Tm9kZXMiLCJib25lcyIsImJvbmVJbnZlcnNlcyIsImpvaW50Tm9kZSIsIm1hdCIsImFuaW1hdGlvbkluZGV4IiwiYW5pbWF0aW9uRGVmIiwiYW5pbWF0aW9uTmFtZSIsInBlbmRpbmdOb2RlcyIsInBlbmRpbmdJbnB1dEFjY2Vzc29ycyIsInBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMiLCJwZW5kaW5nU2FtcGxlcnMiLCJwZW5kaW5nVGFyZ2V0cyIsImNoYW5uZWxzIiwibm9kZSIsImlucHV0IiwicGFyYW1ldGVycyIsIm91dHB1dCIsImlucHV0QWNjZXNzb3JzIiwib3V0cHV0QWNjZXNzb3JzIiwidHJhY2tzIiwiaW5wdXRBY2Nlc3NvciIsIm91dHB1dEFjY2Vzc29yIiwidXBkYXRlTWF0cml4IiwiY3JlYXRlZFRyYWNrcyIsIl9jcmVhdGVBbmltYXRpb25UcmFja3MiLCJrIiwidHJhdmVyc2UiLCJvIiwiaXNNZXNoIiwibm9kZVBlbmRpbmciLCJjaGlsZFBlbmRpbmciLCJjaGlsZHJlbkRlZiIsInNrZWxldG9uUGVuZGluZyIsInNrZWxldG9uIiwiYmluZCIsIm5vZGVOYW1lIiwibWVzaFByb21pc2UiLCJmb3JFYWNoIiwibWF0cml4IiwiYXBwbHlNYXRyaXg0IiwicXVhdGVybmlvbiIsImhhcyIsInNjZW5lSW5kZXgiLCJzY2VuZURlZiIsIm5vZGVJZHMiLCJyZWR1Y2VBc3NvY2lhdGlvbnMiLCJyZWR1Y2VkQXNzb2NpYXRpb25zIiwidmFsdWUiLCJub2RlMiIsInRhcmdldE5hbWUiLCJUeXBlZEtleWZyYW1lVHJhY2siLCJpbnRlcnBvbGF0aW9uIiwib3V0cHV0QXJyYXkiLCJfZ2V0QXJyYXlGcm9tQWNjZXNzb3IiLCJqIiwiamwiLCJ0cmFjayIsIl9jcmVhdGVDdWJpY1NwbGluZVRyYWNrSW50ZXJwb2xhbnQiLCJzY2FsZWQiLCJjcmVhdGVJbnRlcnBvbGFudCIsIkludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSIsImludGVycG9sYW50VHlwZSIsInRpbWVzIiwiZ2V0VmFsdWVTaXplIiwiaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUiLCJjb21wdXRlQm91bmRzIiwiYm94IiwibWluIiwibWF4IiwiYm94U2NhbGUiLCJtdWx0aXBseVNjYWxhciIsIm1heERpc3BsYWNlbWVudCIsInZlY3RvciIsImFicyIsImV4cGFuZEJ5VmVjdG9yIiwiYm91bmRpbmdCb3giLCJzcGhlcmUiLCJnZXRDZW50ZXIiLCJjZW50ZXIiLCJyYWRpdXMiLCJkaXN0YW5jZVRvIiwiYm91bmRpbmdTcGhlcmUiLCJhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvciIsImdsdGZBdHRyaWJ1dGVOYW1lIiwiYWNjZXNzb3IyIiwic2V0SW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/RGBELoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RGBELoader: () => (/* binding */ RGBELoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nclass RGBELoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n                case rgbe_write_error:\n                    throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n                case rgbe_format_error:\n                    throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n                default:\n                case rgbe_memory_error:\n                    throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n            }\n        }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                if (false !== consume) buffer2.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, RGBE_ReadHeader = function(buffer2) {\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n                valid: 0,\n                string: \"\",\n                comments: \"\",\n                programtype: \"RGBE\",\n                format: \"\",\n                gamma: 1,\n                exposure: 1,\n                width: 0,\n                height: 0\n            };\n            let line, match;\n            if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n                rgbe_error(rgbe_read_error, \"no header found\");\n            }\n            if (!(match = line.match(magic_token_re))) {\n                rgbe_error(rgbe_format_error, \"bad initial token\");\n            }\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer2);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue;\n                }\n                if (match = line.match(gamma_re)) {\n                    header.gamma = parseFloat(match[1]);\n                }\n                if (match = line.match(exposure_re)) {\n                    header.exposure = parseFloat(match[1]);\n                }\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1];\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) {\n                rgbe_error(rgbe_format_error, \"missing format specifier\");\n            }\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n                rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            }\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {\n            const scanline_width = w2;\n            if (// run length encoding is not allowed so read flat\n            scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n            2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128) {\n                return new Uint8Array(buffer2);\n            }\n            if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n                rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            }\n            const data_rgba = new Uint8Array(4 * w2 * h2);\n            if (!data_rgba.length) {\n                rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            }\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h2;\n            while(num_scanlines > 0 && pos < buffer2.byteLength){\n                if (pos + 4 > buffer2.byteLength) {\n                    rgbe_error(rgbe_read_error);\n                }\n                rgbeStart[0] = buffer2[pos++];\n                rgbeStart[1] = buffer2[pos++];\n                rgbeStart[2] = buffer2[pos++];\n                rgbeStart[3] = buffer2[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n                    rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                }\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer2.byteLength){\n                    count = buffer2[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) {\n                        rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    }\n                    if (isEncodedRun) {\n                        const byteValue = buffer2[pos++];\n                        for(let i = 0; i < count; i++){\n                            scanline_buffer[ptr++] = byteValue;\n                        }\n                    } else {\n                        scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                const l = scanline_width;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n        let data, type;\n        let numElements;\n        switch(this.type){\n            case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                numElements = image_rgba_data.length / 4;\n                const floatArray = new Float32Array(numElements * 4);\n                for(let j = 0; j < numElements; j++){\n                    RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                }\n                data = floatArray;\n                type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                numElements = image_rgba_data.length / 4;\n                const halfArray = new Uint16Array(numElements * 4);\n                for(let j = 0; j < numElements; j++){\n                    RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                }\n                data = halfArray;\n                type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n                break;\n            default:\n                throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n        }\n        return {\n            width: w,\n            height: h,\n            data,\n            header: rgbe_header_info.string,\n            gamma: rgbe_header_info.gamma,\n            exposure: rgbe_header_info.exposure,\n            type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    if (\"colorSpace\" in texture) texture.colorSpace = \"srgb-linear\";\n                    else texture.encoding = 3e3;\n                    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=RGBELoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvUkdCRUxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RjtBQUM3RixNQUFNSyxtQkFBbUJMLG9EQUFpQkE7SUFDeENNLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUdQLGdEQUFhQTtJQUMzQjtJQUNBLDhEQUE4RDtJQUM5RFEsTUFBTUMsTUFBTSxFQUFFO1FBQ1osTUFBTUMsa0JBQWtCLEdBQUdDLG1CQUFtQixHQUFHQyxvQkFBb0IsR0FBR0Msb0JBQW9CLEdBQUdDLGFBQWEsU0FBU0MsZUFBZSxFQUFFQyxHQUFHO1lBQ3ZJLE9BQVFEO2dCQUNOLEtBQUtMO29CQUNILE1BQU0sSUFBSU8sTUFBTSxtQ0FBb0NELENBQUFBLE9BQU8sRUFBQztnQkFDOUQsS0FBS0w7b0JBQ0gsTUFBTSxJQUFJTSxNQUFNLG9DQUFxQ0QsQ0FBQUEsT0FBTyxFQUFDO2dCQUMvRCxLQUFLSjtvQkFDSCxNQUFNLElBQUlLLE1BQU0sd0NBQXlDRCxDQUFBQSxPQUFPLEVBQUM7Z0JBQ25FO2dCQUNBLEtBQUtIO29CQUNILE1BQU0sSUFBSUksTUFBTSxxQ0FBc0NELENBQUFBLE9BQU8sRUFBQztZQUNsRTtRQUNGLEdBQUdFLHlCQUF5QixHQUFHQyxvQkFBb0IsR0FBR0Msd0JBQXdCLEdBQUdDLFVBQVUsTUFBTUMsUUFBUSxTQUFTQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsT0FBTztZQUMzSSxNQUFNQyxZQUFZO1lBQ2xCRixZQUFZLENBQUNBLFlBQVksT0FBT0E7WUFDaEMsSUFBSUcsSUFBSUosUUFBUUssR0FBRyxFQUFFQyxJQUFJLENBQUMsR0FBR0MsTUFBTSxHQUFHQyxJQUFJLElBQUlDLFFBQVFDLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU0sSUFBSUMsWUFBWWIsUUFBUWMsUUFBUSxDQUFDVixHQUFHQSxJQUFJRDtZQUM5SCxNQUFP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QUNBLE9BQU87WUFDTGlELE9BQU91QztZQUNQdEMsUUFBUXVDO1lBQ1JFO1lBQ0FsRCxRQUFROEMsaUJBQWlCNUMsTUFBTTtZQUMvQkksT0FBT3dDLGlCQUFpQnhDLEtBQUs7WUFDN0JDLFVBQVV1QyxpQkFBaUJ2QyxRQUFRO1lBQ25DaEQ7UUFDRjtJQUNGO0lBQ0FpRyxZQUFZQyxLQUFLLEVBQUU7UUFDakIsSUFBSSxDQUFDbEcsSUFBSSxHQUFHa0c7UUFDWixPQUFPLElBQUk7SUFDYjtJQUNBQyxLQUFLQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxPQUFPLEVBQUU7UUFDckMsU0FBU0MsZUFBZUMsT0FBTyxFQUFFQyxPQUFPO1lBQ3RDLE9BQVFELFFBQVF6RyxJQUFJO2dCQUNsQixLQUFLTiw0Q0FBU0E7Z0JBQ2QsS0FBS0QsZ0RBQWFBO29CQUNoQixJQUFJLGdCQUFnQmdILFNBQ2xCQSxRQUFRRSxVQUFVLEdBQUc7eUJBRXJCRixRQUFRRyxRQUFRLEdBQUc7b0JBQ3JCSCxRQUFRSSxTQUFTLEdBQUdqSCwrQ0FBWUE7b0JBQ2hDNkcsUUFBUUssU0FBUyxHQUFHbEgsK0NBQVlBO29CQUNoQzZHLFFBQVFNLGVBQWUsR0FBRztvQkFDMUJOLFFBQVFPLEtBQUssR0FBRztvQkFDaEI7WUFDSjtZQUNBLElBQUlYLFFBQ0ZBLE9BQU9JLFNBQVNDO1FBQ3BCO1FBQ0EsT0FBTyxLQUFLLENBQUNQLEtBQUtDLEtBQUtJLGdCQUFnQkYsWUFBWUM7SUFDckQ7QUFDRjtBQUdFLENBQ0Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNyZWF0aXZlLXBvcnRmb2xpby1zdGFydGVyLWNvZGUtZmlsZXMvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvUkdCRUxvYWRlci5qcz83YWIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGFUZXh0dXJlTG9hZGVyLCBIYWxmRmxvYXRUeXBlLCBGbG9hdFR5cGUsIERhdGFVdGlscywgTGluZWFyRmlsdGVyIH0gZnJvbSBcInRocmVlXCI7XG5jbGFzcyBSR0JFTG9hZGVyIGV4dGVuZHMgRGF0YVRleHR1cmVMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy50eXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgfVxuICAvLyBhZGFwdGVkIGZyb20gaHR0cDovL3d3dy5ncmFwaGljcy5jb3JuZWxsLmVkdS9+Ymp3L3JnYmUuaHRtbFxuICBwYXJzZShidWZmZXIpIHtcbiAgICBjb25zdCByZ2JlX3JlYWRfZXJyb3IgPSAxLCByZ2JlX3dyaXRlX2Vycm9yID0gMiwgcmdiZV9mb3JtYXRfZXJyb3IgPSAzLCByZ2JlX21lbW9yeV9lcnJvciA9IDQsIHJnYmVfZXJyb3IgPSBmdW5jdGlvbihyZ2JlX2Vycm9yX2NvZGUsIG1zZykge1xuICAgICAgc3dpdGNoIChyZ2JlX2Vycm9yX2NvZGUpIHtcbiAgICAgICAgY2FzZSByZ2JlX3JlYWRfZXJyb3I6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogUmVhZCBFcnJvcjogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgICAgY2FzZSByZ2JlX3dyaXRlX2Vycm9yOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLlJHQkVMb2FkZXI6IFdyaXRlIEVycm9yOiBcIiArIChtc2cgfHwgXCJcIikpO1xuICAgICAgICBjYXNlIHJnYmVfZm9ybWF0X2Vycm9yOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLlJHQkVMb2FkZXI6IEJhZCBGaWxlIEZvcm1hdDogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSByZ2JlX21lbW9yeV9lcnJvcjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyOiBNZW1vcnkgRXJyb3I6IFwiICsgKG1zZyB8fCBcIlwiKSk7XG4gICAgICB9XG4gICAgfSwgUkdCRV9WQUxJRF9QUk9HUkFNVFlQRSA9IDEsIFJHQkVfVkFMSURfRk9STUFUID0gMiwgUkdCRV9WQUxJRF9ESU1FTlNJT05TID0gNCwgTkVXTElORSA9IFwiXFxuXCIsIGZnZXRzID0gZnVuY3Rpb24oYnVmZmVyMiwgbGluZUxpbWl0LCBjb25zdW1lKSB7XG4gICAgICBjb25zdCBjaHVua1NpemUgPSAxMjg7XG4gICAgICBsaW5lTGltaXQgPSAhbGluZUxpbWl0ID8gMTAyNCA6IGxpbmVMaW1pdDtcbiAgICAgIGxldCBwID0gYnVmZmVyMi5wb3MsIGkgPSAtMSwgbGVuID0gMCwgcyA9IFwiXCIsIGNodW5rID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoYnVmZmVyMi5zdWJhcnJheShwLCBwICsgY2h1bmtTaXplKSkpO1xuICAgICAgd2hpbGUgKDAgPiAoaSA9IGNodW5rLmluZGV4T2YoTkVXTElORSkpICYmIGxlbiA8IGxpbmVMaW1pdCAmJiBwIDwgYnVmZmVyMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHMgKz0gY2h1bms7XG4gICAgICAgIGxlbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHAgKz0gY2h1bmtTaXplO1xuICAgICAgICBjaHVuayArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShidWZmZXIyLnN1YmFycmF5KHAsIHAgKyBjaHVua1NpemUpKSk7XG4gICAgICB9XG4gICAgICBpZiAoLTEgPCBpKSB7XG4gICAgICAgIGlmIChmYWxzZSAhPT0gY29uc3VtZSlcbiAgICAgICAgICBidWZmZXIyLnBvcyArPSBsZW4gKyBpICsgMTtcbiAgICAgICAgcmV0dXJuIHMgKyBjaHVuay5zbGljZSgwLCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBSR0JFX1JlYWRIZWFkZXIgPSBmdW5jdGlvbihidWZmZXIyKSB7XG4gICAgICBjb25zdCBtYWdpY190b2tlbl9yZSA9IC9eI1xcPyhcXFMrKS8sIGdhbW1hX3JlID0gL15cXHMqR0FNTUFcXHMqPVxccyooXFxkKyhcXC5cXGQrKT8pXFxzKiQvLCBleHBvc3VyZV9yZSA9IC9eXFxzKkVYUE9TVVJFXFxzKj1cXHMqKFxcZCsoXFwuXFxkKyk/KVxccyokLywgZm9ybWF0X3JlID0gL15cXHMqRk9STUFUPShcXFMrKVxccyokLywgZGltZW5zaW9uc19yZSA9IC9eXFxzKlxcLVlcXHMrKFxcZCspXFxzK1xcK1hcXHMrKFxcZCspXFxzKiQvLCBoZWFkZXIgPSB7XG4gICAgICAgIHZhbGlkOiAwLFxuICAgICAgICBzdHJpbmc6IFwiXCIsXG4gICAgICAgIGNvbW1lbnRzOiBcIlwiLFxuICAgICAgICBwcm9ncmFtdHlwZTogXCJSR0JFXCIsXG4gICAgICAgIGZvcm1hdDogXCJcIixcbiAgICAgICAgZ2FtbWE6IDEsXG4gICAgICAgIGV4cG9zdXJlOiAxLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9O1xuICAgICAgbGV0IGxpbmUsIG1hdGNoO1xuICAgICAgaWYgKGJ1ZmZlcjIucG9zID49IGJ1ZmZlcjIuYnl0ZUxlbmd0aCB8fCAhKGxpbmUgPSBmZ2V0cyhidWZmZXIyKSkpIHtcbiAgICAgICAgcmdiZV9lcnJvcihyZ2JlX3JlYWRfZXJyb3IsIFwibm8gaGVhZGVyIGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEobWF0Y2ggPSBsaW5lLm1hdGNoKG1hZ2ljX3Rva2VuX3JlKSkpIHtcbiAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJiYWQgaW5pdGlhbCB0b2tlblwiKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlci52YWxpZCB8PSBSR0JFX1ZBTElEX1BST0dSQU1UWVBFO1xuICAgICAgaGVhZGVyLnByb2dyYW10eXBlID0gbWF0Y2hbMV07XG4gICAgICBoZWFkZXIuc3RyaW5nICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGluZSA9IGZnZXRzKGJ1ZmZlcjIpO1xuICAgICAgICBpZiAoZmFsc2UgPT09IGxpbmUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGhlYWRlci5zdHJpbmcgKz0gbGluZSArIFwiXFxuXCI7XG4gICAgICAgIGlmIChcIiNcIiA9PT0gbGluZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICBoZWFkZXIuY29tbWVudHMgKz0gbGluZSArIFwiXFxuXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gbGluZS5tYXRjaChnYW1tYV9yZSkpIHtcbiAgICAgICAgICBoZWFkZXIuZ2FtbWEgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGV4cG9zdXJlX3JlKSkge1xuICAgICAgICAgIGhlYWRlci5leHBvc3VyZSA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZm9ybWF0X3JlKSkge1xuICAgICAgICAgIGhlYWRlci52YWxpZCB8PSBSR0JFX1ZBTElEX0ZPUk1BVDtcbiAgICAgICAgICBoZWFkZXIuZm9ybWF0ID0gbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gbGluZS5tYXRjaChkaW1lbnNpb25zX3JlKSkge1xuICAgICAgICAgIGhlYWRlci52YWxpZCB8PSBSR0JFX1ZBTElEX0RJTUVOU0lPTlM7XG4gICAgICAgICAgaGVhZGVyLmhlaWdodCA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgICAgaGVhZGVyLndpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9GT1JNQVQgJiYgaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9ESU1FTlNJT05TKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCEoaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9GT1JNQVQpKSB7XG4gICAgICAgIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwibWlzc2luZyBmb3JtYXQgc3BlY2lmaWVyXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEoaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9ESU1FTlNJT05TKSkge1xuICAgICAgICByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcIm1pc3NpbmcgaW1hZ2Ugc2l6ZSBzcGVjaWZpZXJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVhZGVyO1xuICAgIH0sIFJHQkVfUmVhZFBpeGVsc19STEUgPSBmdW5jdGlvbihidWZmZXIyLCB3MiwgaDIpIHtcbiAgICAgIGNvbnN0IHNjYW5saW5lX3dpZHRoID0gdzI7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIHJ1biBsZW5ndGggZW5jb2RpbmcgaXMgbm90IGFsbG93ZWQgc28gcmVhZCBmbGF0XG4gICAgICAgIHNjYW5saW5lX3dpZHRoIDwgOCB8fCBzY2FubGluZV93aWR0aCA+IDMyNzY3IHx8IC8vIHRoaXMgZmlsZSBpcyBub3QgcnVuIGxlbmd0aCBlbmNvZGVkXG4gICAgICAgIDIgIT09IGJ1ZmZlcjJbMF0gfHwgMiAhPT0gYnVmZmVyMlsxXSB8fCBidWZmZXIyWzJdICYgMTI4XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcjIpO1xuICAgICAgfVxuICAgICAgaWYgKHNjYW5saW5lX3dpZHRoICE9PSAoYnVmZmVyMlsyXSA8PCA4IHwgYnVmZmVyMlszXSkpIHtcbiAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJ3cm9uZyBzY2FubGluZSB3aWR0aFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGFfcmdiYSA9IG5ldyBVaW50OEFycmF5KDQgKiB3MiAqIGgyKTtcbiAgICAgIGlmICghZGF0YV9yZ2JhLmxlbmd0aCkge1xuICAgICAgICByZ2JlX2Vycm9yKHJnYmVfbWVtb3J5X2Vycm9yLCBcInVuYWJsZSB0byBhbGxvY2F0ZSBidWZmZXIgc3BhY2VcIik7XG4gICAgICB9XG4gICAgICBsZXQgb2Zmc2V0ID0gMCwgcG9zID0gMDtcbiAgICAgIGNvbnN0IHB0cl9lbmQgPSA0ICogc2NhbmxpbmVfd2lkdGg7XG4gICAgICBjb25zdCByZ2JlU3RhcnQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgIGNvbnN0IHNjYW5saW5lX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHB0cl9lbmQpO1xuICAgICAgbGV0IG51bV9zY2FubGluZXMgPSBoMjtcbiAgICAgIHdoaWxlIChudW1fc2NhbmxpbmVzID4gMCAmJiBwb3MgPCBidWZmZXIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgaWYgKHBvcyArIDQgPiBidWZmZXIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICByZ2JlX2Vycm9yKHJnYmVfcmVhZF9lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmdiZVN0YXJ0WzBdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIHJnYmVTdGFydFsxXSA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICByZ2JlU3RhcnRbMl0gPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgcmdiZVN0YXJ0WzNdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIGlmICgyICE9IHJnYmVTdGFydFswXSB8fCAyICE9IHJnYmVTdGFydFsxXSB8fCAocmdiZVN0YXJ0WzJdIDw8IDggfCByZ2JlU3RhcnRbM10pICE9IHNjYW5saW5lX3dpZHRoKSB7XG4gICAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJiYWQgcmdiZSBzY2FubGluZSBmb3JtYXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB0ciA9IDAsIGNvdW50O1xuICAgICAgICB3aGlsZSAocHRyIDwgcHRyX2VuZCAmJiBwb3MgPCBidWZmZXIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICBjb3VudCA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICAgIGNvbnN0IGlzRW5jb2RlZFJ1biA9IGNvdW50ID4gMTI4O1xuICAgICAgICAgIGlmIChpc0VuY29kZWRSdW4pXG4gICAgICAgICAgICBjb3VudCAtPSAxMjg7XG4gICAgICAgICAgaWYgKDAgPT09IGNvdW50IHx8IHB0ciArIGNvdW50ID4gcHRyX2VuZCkge1xuICAgICAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJiYWQgc2NhbmxpbmUgZGF0YVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRW5jb2RlZFJ1bikge1xuICAgICAgICAgICAgY29uc3QgYnl0ZVZhbHVlID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgc2NhbmxpbmVfYnVmZmVyW3B0cisrXSA9IGJ5dGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NhbmxpbmVfYnVmZmVyLnNldChidWZmZXIyLnN1YmFycmF5KHBvcywgcG9zICsgY291bnQpLCBwdHIpO1xuICAgICAgICAgICAgcHRyICs9IGNvdW50O1xuICAgICAgICAgICAgcG9zICs9IGNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsID0gc2NhbmxpbmVfd2lkdGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbGV0IG9mZiA9IDA7XG4gICAgICAgICAgZGF0YV9yZ2JhW29mZnNldF0gPSBzY2FubGluZV9idWZmZXJbaSArIG9mZl07XG4gICAgICAgICAgb2ZmICs9IHNjYW5saW5lX3dpZHRoO1xuICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXQgKyAxXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmYgKz0gc2NhbmxpbmVfd2lkdGg7XG4gICAgICAgICAgZGF0YV9yZ2JhW29mZnNldCArIDJdID0gc2NhbmxpbmVfYnVmZmVyW2kgKyBvZmZdO1xuICAgICAgICAgIG9mZiArPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0ICsgM10gPSBzY2FubGluZV9idWZmZXJbaSArIG9mZl07XG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgbnVtX3NjYW5saW5lcy0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFfcmdiYTtcbiAgICB9O1xuICAgIGNvbnN0IFJHQkVCeXRlVG9SR0JGbG9hdCA9IGZ1bmN0aW9uKHNvdXJjZUFycmF5LCBzb3VyY2VPZmZzZXQsIGRlc3RBcnJheSwgZGVzdE9mZnNldCkge1xuICAgICAgY29uc3QgZSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDNdO1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBlIC0gMTI4KSAvIDI1NTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMF0gPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAwXSAqIHNjYWxlO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAxXSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDFdICogc2NhbGU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDJdID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMl0gKiBzY2FsZTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgM10gPSAxO1xuICAgIH07XG4gICAgY29uc3QgUkdCRUJ5dGVUb1JHQkhhbGYgPSBmdW5jdGlvbihzb3VyY2VBcnJheSwgc291cmNlT2Zmc2V0LCBkZXN0QXJyYXksIGRlc3RPZmZzZXQpIHtcbiAgICAgIGNvbnN0IGUgPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAzXTtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgZSAtIDEyOCkgLyAyNTU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDBdID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KE1hdGgubWluKHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDBdICogc2NhbGUsIDY1NTA0KSk7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDFdID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KE1hdGgubWluKHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDFdICogc2NhbGUsIDY1NTA0KSk7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDJdID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KE1hdGgubWluKHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDJdICogc2NhbGUsIDY1NTA0KSk7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDNdID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KDEpO1xuICAgIH07XG4gICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBieXRlQXJyYXkucG9zID0gMDtcbiAgICBjb25zdCByZ2JlX2hlYWRlcl9pbmZvID0gUkdCRV9SZWFkSGVhZGVyKGJ5dGVBcnJheSk7XG4gICAgY29uc3QgdyA9IHJnYmVfaGVhZGVyX2luZm8ud2lkdGgsIGggPSByZ2JlX2hlYWRlcl9pbmZvLmhlaWdodCwgaW1hZ2VfcmdiYV9kYXRhID0gUkdCRV9SZWFkUGl4ZWxzX1JMRShieXRlQXJyYXkuc3ViYXJyYXkoYnl0ZUFycmF5LnBvcyksIHcsIGgpO1xuICAgIGxldCBkYXRhLCB0eXBlO1xuICAgIGxldCBudW1FbGVtZW50cztcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgIG51bUVsZW1lbnRzID0gaW1hZ2VfcmdiYV9kYXRhLmxlbmd0aCAvIDQ7XG4gICAgICAgIGNvbnN0IGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KG51bUVsZW1lbnRzICogNCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtRWxlbWVudHM7IGorKykge1xuICAgICAgICAgIFJHQkVCeXRlVG9SR0JGbG9hdChpbWFnZV9yZ2JhX2RhdGEsIGogKiA0LCBmbG9hdEFycmF5LCBqICogNCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGZsb2F0QXJyYXk7XG4gICAgICAgIHR5cGUgPSBGbG9hdFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICBudW1FbGVtZW50cyA9IGltYWdlX3JnYmFfZGF0YS5sZW5ndGggLyA0O1xuICAgICAgICBjb25zdCBoYWxmQXJyYXkgPSBuZXcgVWludDE2QXJyYXkobnVtRWxlbWVudHMgKiA0KTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1FbGVtZW50czsgaisrKSB7XG4gICAgICAgICAgUkdCRUJ5dGVUb1JHQkhhbGYoaW1hZ2VfcmdiYV9kYXRhLCBqICogNCwgaGFsZkFycmF5LCBqICogNCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGhhbGZBcnJheTtcbiAgICAgICAgdHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogVW5zdXBwb3J0ZWQgdHlwZTogXCIgKyB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHcsXG4gICAgICBoZWlnaHQ6IGgsXG4gICAgICBkYXRhLFxuICAgICAgaGVhZGVyOiByZ2JlX2hlYWRlcl9pbmZvLnN0cmluZyxcbiAgICAgIGdhbW1hOiByZ2JlX2hlYWRlcl9pbmZvLmdhbW1hLFxuICAgICAgZXhwb3N1cmU6IHJnYmVfaGVhZGVyX2luZm8uZXhwb3N1cmUsXG4gICAgICB0eXBlXG4gICAgfTtcbiAgfVxuICBzZXREYXRhVHlwZSh2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBmdW5jdGlvbiBvbkxvYWRDYWxsYmFjayh0ZXh0dXJlLCB0ZXhEYXRhKSB7XG4gICAgICBzd2l0Y2ggKHRleHR1cmUudHlwZSkge1xuICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgIGlmIChcImNvbG9yU3BhY2VcIiBpbiB0ZXh0dXJlKVxuICAgICAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gXCJzcmdiLWxpbmVhclwiO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRleHR1cmUuZW5jb2RpbmcgPSAzZTM7XG4gICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgICAgICB0ZXh0dXJlLmZsaXBZID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChvbkxvYWQpXG4gICAgICAgIG9uTG9hZCh0ZXh0dXJlLCB0ZXhEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmxvYWQodXJsLCBvbkxvYWRDYWxsYmFjaywgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFJHQkVMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SR0JFTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkRhdGFUZXh0dXJlTG9hZGVyIiwiSGFsZkZsb2F0VHlwZSIsIkZsb2F0VHlwZSIsIkRhdGFVdGlscyIsIkxpbmVhckZpbHRlciIsIlJHQkVMb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJ0eXBlIiwicGFyc2UiLCJidWZmZXIiLCJyZ2JlX3JlYWRfZXJyb3IiLCJyZ2JlX3dyaXRlX2Vycm9yIiwicmdiZV9mb3JtYXRfZXJyb3IiLCJyZ2JlX21lbW9yeV9lcnJvciIsInJnYmVfZXJyb3IiLCJyZ2JlX2Vycm9yX2NvZGUiLCJtc2ciLCJFcnJvciIsIlJHQkVfVkFMSURfUFJPR1JBTVRZUEUiLCJSR0JFX1ZBTElEX0ZPUk1BVCIsIlJHQkVfVkFMSURfRElNRU5TSU9OUyIsIk5FV0xJTkUiLCJmZ2V0cyIsImJ1ZmZlcjIiLCJsaW5lTGltaXQiLCJjb25zdW1lIiwiY2h1bmtTaXplIiwicCIsInBvcyIsImkiLCJsZW4iLCJzIiwiY2h1bmsiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsIlVpbnQxNkFycmF5Iiwic3ViYXJyYXkiLCJpbmRleE9mIiwiYnl0ZUxlbmd0aCIsImxlbmd0aCIsInNsaWNlIiwiUkdCRV9SZWFkSGVhZGVyIiwibWFnaWNfdG9rZW5fcmUiLCJnYW1tYV9yZSIsImV4cG9zdXJlX3JlIiwiZm9ybWF0X3JlIiwiZGltZW5zaW9uc19yZSIsImhlYWRlciIsInZhbGlkIiwic3RyaW5nIiwiY29tbWVudHMiLCJwcm9ncmFtdHlwZSIsImZvcm1hdCIsImdhbW1hIiwiZXhwb3N1cmUiLCJ3aWR0aCIsImhlaWdodCIsImxpbmUiLCJtYXRjaCIsImNoYXJBdCIsInBhcnNlRmxvYXQiLCJwYXJzZUludCIsIlJHQkVfUmVhZFBpeGVsc19STEUiLCJ3MiIsImgyIiwic2NhbmxpbmVfd2lkdGgiLCJVaW50OEFycmF5IiwiZGF0YV9yZ2JhIiwib2Zmc2V0IiwicHRyX2VuZCIsInJnYmVTdGFydCIsInNjYW5saW5lX2J1ZmZlciIsIm51bV9zY2FubGluZXMiLCJwdHIiLCJjb3VudCIsImlzRW5jb2RlZFJ1biIsImJ5dGVWYWx1ZSIsInNldCIsImwiLCJvZmYiLCJSR0JFQnl0ZVRvUkdCRmxvYXQiLCJzb3VyY2VBcnJheSIsInNvdXJjZU9mZnNldCIsImRlc3RBcnJheSIsImRlc3RPZmZzZXQiLCJlIiwic2NhbGUiLCJNYXRoIiwicG93IiwiUkdCRUJ5dGVUb1JHQkhhbGYiLCJ0b0hhbGZGbG9hdCIsIm1pbiIsImJ5dGVBcnJheSIsInJnYmVfaGVhZGVyX2luZm8iLCJ3IiwiaCIsImltYWdlX3JnYmFfZGF0YSIsImRhdGEiLCJudW1FbGVtZW50cyIsImZsb2F0QXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJqIiwiaGFsZkFycmF5Iiwic2V0RGF0YVR5cGUiLCJ2YWx1ZSIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsIm9uTG9hZENhbGxiYWNrIiwidGV4dHVyZSIsInRleERhdGEiLCJjb2xvclNwYWNlIiwiZW5jb2RpbmciLCJtaW5GaWx0ZXIiLCJtYWdGaWx0ZXIiLCJnZW5lcmF0ZU1pcG1hcHMiLCJmbGlwWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCompress: () => (/* binding */ AsyncGzip),\n/* harmony export */   AsyncDecompress: () => (/* binding */ AsyncDecompress),\n/* harmony export */   AsyncDeflate: () => (/* binding */ AsyncDeflate),\n/* harmony export */   AsyncGunzip: () => (/* binding */ AsyncGunzip),\n/* harmony export */   AsyncGzip: () => (/* binding */ AsyncGzip),\n/* harmony export */   AsyncInflate: () => (/* binding */ AsyncInflate),\n/* harmony export */   AsyncUnzipInflate: () => (/* binding */ AsyncUnzipInflate),\n/* harmony export */   AsyncUnzlib: () => (/* binding */ AsyncUnzlib),\n/* harmony export */   AsyncZipDeflate: () => (/* binding */ AsyncZipDeflate),\n/* harmony export */   AsyncZlib: () => (/* binding */ AsyncZlib),\n/* harmony export */   Compress: () => (/* binding */ Gzip),\n/* harmony export */   DecodeUTF8: () => (/* binding */ DecodeUTF8),\n/* harmony export */   Decompress: () => (/* binding */ Decompress),\n/* harmony export */   Deflate: () => (/* binding */ Deflate),\n/* harmony export */   EncodeUTF8: () => (/* binding */ EncodeUTF8),\n/* harmony export */   Gunzip: () => (/* binding */ Gunzip),\n/* harmony export */   Gzip: () => (/* binding */ Gzip),\n/* harmony export */   Inflate: () => (/* binding */ Inflate),\n/* harmony export */   Unzip: () => (/* binding */ Unzip),\n/* harmony export */   UnzipInflate: () => (/* binding */ UnzipInflate),\n/* harmony export */   UnzipPassThrough: () => (/* binding */ UnzipPassThrough),\n/* harmony export */   Unzlib: () => (/* binding */ Unzlib),\n/* harmony export */   Zip: () => (/* binding */ Zip),\n/* harmony export */   ZipDeflate: () => (/* binding */ ZipDeflate),\n/* harmony export */   ZipPassThrough: () => (/* binding */ ZipPassThrough),\n/* harmony export */   Zlib: () => (/* binding */ Zlib),\n/* harmony export */   compress: () => (/* binding */ gzip),\n/* harmony export */   compressSync: () => (/* binding */ gzipSync),\n/* harmony export */   decompress: () => (/* binding */ decompress),\n/* harmony export */   decompressSync: () => (/* binding */ decompressSync),\n/* harmony export */   deflate: () => (/* binding */ deflate),\n/* harmony export */   deflateSync: () => (/* binding */ deflateSync),\n/* harmony export */   gunzip: () => (/* binding */ gunzip),\n/* harmony export */   gunzipSync: () => (/* binding */ gunzipSync),\n/* harmony export */   gzip: () => (/* binding */ gzip),\n/* harmony export */   gzipSync: () => (/* binding */ gzipSync),\n/* harmony export */   inflate: () => (/* binding */ inflate),\n/* harmony export */   inflateSync: () => (/* binding */ inflateSync),\n/* harmony export */   strFromU8: () => (/* binding */ strFromU8),\n/* harmony export */   strToU8: () => (/* binding */ strToU8),\n/* harmony export */   unzip: () => (/* binding */ unzip),\n/* harmony export */   unzipSync: () => (/* binding */ unzipSync),\n/* harmony export */   unzlib: () => (/* binding */ unzlib),\n/* harmony export */   unzlibSync: () => (/* binding */ unzlibSync),\n/* harmony export */   zip: () => (/* binding */ zip),\n/* harmony export */   zipSync: () => (/* binding */ zipSync),\n/* harmony export */   zlib: () => (/* binding */ zlib),\n/* harmony export */   zlibSync: () => (/* binding */ zlibSync)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n\nvar require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"/\");\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\n// Mediocre shim\nvar Worker;\nvar workerAdd = \";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global\";\ntry {\n    Worker = require(\"worker_threads\").Worker;\n} catch (e) {}\nvar wk = Worker ? function(c, _, msg, transfer, cb) {\n    var done = false;\n    var w = new Worker(c + workerAdd, {\n        eval: true\n    }).on(\"error\", function(e) {\n        return cb(e, null);\n    }).on(\"message\", function(m) {\n        return cb(null, m);\n    }).on(\"exit\", function(c) {\n        if (c && !done) cb(new Error(\"exited with code \" + c), null);\n    });\n    w.postMessage(msg, transfer);\n    w.terminate = function() {\n        done = true;\n        return Worker.prototype.terminate.call(w);\n    };\n    return w;\n} : function(_, __, ___, ____, cb) {\n    setImmediate(function() {\n        return cb(new Error(\"async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)\"), null);\n    });\n    var NOP = function() {};\n    return {\n        terminate: NOP,\n        postMessage: NOP\n    };\n};\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */ 0,\n    0,\n    /* impossible */ 0\n]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */ 0,\n    0\n]);\n// code length index map\nvar clim = new u8([\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n]);\n// get base, reverse index map from extra bits\nvar freb = function(eb, start) {\n    var b = new u16(31);\n    for(var i = 0; i < 31; ++i){\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for(var i = 1; i < 30; ++i){\n        for(var j = b[i]; j < b[i + 1]; ++j){\n            r[j] = j - b[i] << 5 | i;\n        }\n    }\n    return [\n        b,\n        r\n    ];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor(var i = 0; i < 32768; ++i){\n    // reverse table algorithm from SO\n    var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n    x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n    x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n    rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = function(cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for(; i < s; ++i)++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for(i = 0; i < mb; ++i){\n        le[i] = le[i - 1] + l[i - 1] << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for(i = 0; i < s; ++i){\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = i << 4 | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for(var m = v | (1 << r_1) - 1; v <= m; ++v){\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    } else {\n        co = new u16(s);\n        for(i = 0; i < s; ++i){\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n            }\n        }\n    }\n    return co;\n};\n// fixed length tree\nvar flt = new u8(288);\nfor(var i = 0; i < 144; ++i)flt[i] = 8;\nfor(var i = 144; i < 256; ++i)flt[i] = 9;\nfor(var i = 256; i < 280; ++i)flt[i] = 7;\nfor(var i = 280; i < 288; ++i)flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor(var i = 0; i < 32; ++i)fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function(a) {\n    var m = a[0];\n    for(var i = 1; i < a.length; ++i){\n        if (a[i] > m) m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\n// get end of byte\nvar shft = function(p) {\n    return (p / 8 | 0) + (p & 7 && 1);\n};\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function(v, s, e) {\n    if (s == null || s < 0) s = 0;\n    if (e == null || e > v.length) e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function(dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || st && !st.l && sl < 5) return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st) st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf) buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function(l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n                if (t > sl) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                // ensure size\n                if (noBuf) cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for(var i = 0; i < hcLen; ++i){\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for(var i = 0; i < tl;){\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    } else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n                        while(n--)ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            } else throw \"invalid block type\";\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf) cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for(;; lpos = pos){\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n            if (!c) throw \"invalid length/literal\";\n            if (sym < 256) buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            } else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d) throw \"invalid distance\";\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                if (noBuf) cbuf(bt + 131072);\n                var end = bt + add;\n                for(; bt < end; bt += 4){\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    }while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function(d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for(var i = 0; i < d.length; ++i){\n        if (d[i]) t.push({\n            s: i,\n            f: d[i]\n        });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s) return [\n        et,\n        0\n    ];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [\n            v,\n            1\n        ];\n    }\n    t.sort(function(a, b) {\n        return a.f - b.f;\n    });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({\n        s: -1,\n        f: 25001\n    });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = {\n        s: -1,\n        f: l.f + r.f,\n        l: l,\n        r: r\n    };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while(i1 != s - 1){\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = {\n            s: -1,\n            f: l.f + r.f,\n            l: l,\n            r: r\n        };\n    }\n    var maxSym = t2[0].s;\n    for(var i = 1; i < s; ++i){\n        if (t2[i].s > maxSym) maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function(a, b) {\n            return tr[b.s] - tr[a.s] || a.f - b.f;\n        });\n        for(; i < s; ++i){\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << mbt - tr[i2_1]);\n                tr[i2_1] = mb;\n            } else break;\n        }\n        dt >>>= lft;\n        while(dt > 0){\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;\n            else ++i;\n        }\n        for(; i >= 0 && dt; --i){\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [\n        new u8(tr),\n        mbt\n    ];\n};\n// get the max length and assign length codes\nvar ln = function(n, l, d) {\n    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;\n};\n// length codes generation\nvar lc = function(c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while(s && !c[--s]);\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function(v) {\n        cl[cli++] = v;\n    };\n    for(var i = 1; i <= s; ++i){\n        if (c[i] == cln && i != s) ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for(; cls > 138; cls -= 138)w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n                    cls = 0;\n                }\n            } else if (cls > 3) {\n                w(cln), --cls;\n                for(; cls > 6; cls -= 6)w(8304);\n                if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;\n            }\n            while(cls--)w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [\n        cl.subarray(0, cli),\n        s\n    ];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function(cf, cl) {\n    var l = 0;\n    for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function(out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for(var i = 0; i < lclt.length; ++i)lcfreq[lclt[i] & 31]++;\n    for(var i = 0; i < lcdt.length; ++i)lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for(; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n    var flen = bl + 5 << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for(var i = 0; i < nlcc; ++i)wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [\n            lclt,\n            lcdt\n        ];\n        for(var it = 0; it < 2; ++it){\n            var clct = lcts[it];\n            for(var i = 0; i < clct.length; ++i){\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15) wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;\n            }\n        }\n    } else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for(var i = 0; i < li; ++i){\n        if (syms[i] > 255) {\n            var len = syms[i] >>> 18 & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7) wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3) wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];\n        } else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([\n    65540,\n    131080,\n    131088,\n    131104,\n    262176,\n    1048704,\n    1048832,\n    2114560,\n    2117632\n]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function(dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for(var i = 0; i <= s; i += 65535){\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            } else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    } else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function(i) {\n            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;\n        };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for(; i < s; ++i){\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for(var j = 0; j < 286; ++j)lf[j] = 0;\n                    for(var j = 0; j < 30; ++j)df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while(dif <= maxd && --ch_1 && imod != pimod){\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn) break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for(var j = 0; j < mmd; ++j){\n                                    var ti = i - dif + j + 32768 & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti + 32768 & 32767;\n                                    if (cd > md) md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod + 32768 & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                } else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ function() {\n    var t = new Int32Array(256);\n    for(var i = 0; i < 256; ++i){\n        var c = i, k = 9;\n        while(--k)c = (c & 1 && -306674912) ^ c >>> 1;\n        t[i] = c;\n    }\n    return t;\n}();\n// CRC32\nvar crc = function() {\n    var c = -1;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var cr = c;\n            for(var i = 0; i < d.length; ++i)cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;\n            c = cr;\n        },\n        d: function() {\n            return ~c;\n        }\n    };\n};\n// Alder32\nvar adler = function() {\n    var a = 1, b = 0;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for(var i = 0; i != l;){\n                var e = Math.min(i + 2655, l);\n                for(; i < e; ++i)m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function() {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function(dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function(a, b) {\n    var o = {};\n    for(var k in a)o[k] = a[k];\n    for(var k in b)o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function(fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf(\"[\") + 1, st.lastIndexOf(\"]\")).replace(/ /g, \"\").split(\",\");\n    for(var i = 0; i < dt.length; ++i){\n        var v = dt[i], k = ks[i];\n        if (typeof v == \"function\") {\n            fnStr += \";\" + k + \"=\";\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf(\"[native code]\") != -1) {\n                    var spInd = st_1.indexOf(\" \", 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf(\"(\", spInd));\n                } else {\n                    fnStr += st_1;\n                    for(var t in v.prototype)fnStr += \";\" + k + \".prototype.\" + t + \"=\" + v.prototype[t].toString();\n                }\n            } else fnStr += st_1;\n        } else td[k] = v;\n    }\n    return [\n        fnStr,\n        td\n    ];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function(v) {\n    var tl = [];\n    for(var k in v){\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32) tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function(fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = \"\", td_1 = {}, m = fns.length - 1;\n        for(var i = 0; i < m; ++i)_a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + \";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\" + init.toString() + \"}\", id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function() {\n    return [\n        u8,\n        u16,\n        u32,\n        fleb,\n        fdeb,\n        clim,\n        fl,\n        fd,\n        flrm,\n        fdrm,\n        rev,\n        hMap,\n        max,\n        bits,\n        bits16,\n        shft,\n        slc,\n        inflt,\n        inflateSync,\n        pbf,\n        gu8\n    ];\n};\nvar bDflt = function() {\n    return [\n        u8,\n        u16,\n        u32,\n        fleb,\n        fdeb,\n        clim,\n        revfl,\n        revfd,\n        flm,\n        flt,\n        fdm,\n        fdt,\n        rev,\n        deo,\n        et,\n        hMap,\n        wbits,\n        wbits16,\n        hTree,\n        ln,\n        lc,\n        clen,\n        wfblk,\n        wblk,\n        shft,\n        slc,\n        dflt,\n        dopt,\n        deflateSync,\n        pbf\n    ];\n};\n// gzip extra\nvar gze = function() {\n    return [\n        gzh,\n        gzhl,\n        wbytes,\n        crc,\n        crct\n    ];\n};\n// gunzip extra\nvar guze = function() {\n    return [\n        gzs,\n        gzl\n    ];\n};\n// zlib extra\nvar zle = function() {\n    return [\n        zlh,\n        wbytes,\n        adler\n    ];\n};\n// unzlib extra\nvar zule = function() {\n    return [\n        zlv\n    ];\n};\n// post buf\nvar pbf = function(msg) {\n    return postMessage(msg, [\n        msg.buffer\n    ]);\n};\n// get u8\nvar gu8 = function(o) {\n    return o && o.size && new u8(o.size);\n};\n// async helper\nvar cbify = function(dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function(err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([\n        dat,\n        opts\n    ], opts.consume ? [\n        dat.buffer\n    ] : []);\n    return function() {\n        w.terminate();\n    };\n};\n// auto stream\nvar astrm = function(strm) {\n    strm.ondata = function(dat, final) {\n        return postMessage([\n            dat,\n            final\n        ], [\n            dat.buffer\n        ]);\n    };\n    return function(ev) {\n        return strm.push(ev.data[0], ev.data[1]);\n    };\n};\n// async stream attach\nvar astrmify = function(fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function(err, dat) {\n        if (err) w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1]) w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function(d, f) {\n        if (t) throw \"stream finished\";\n        if (!strm.ondata) throw \"no stream handler\";\n        w.postMessage([\n            d,\n            t = f\n        ], [\n            d.buffer\n        ]);\n    };\n    strm.terminate = function() {\n        w.terminate();\n    };\n};\n// read 2 bytes\nvar b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n};\n// read 4 bytes\nvar b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n};\nvar b8 = function(d, b) {\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\n};\n// write bytes\nvar wbytes = function(d, b, v) {\n    for(; v; ++b)d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function(c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for(var i = 0; i <= fn.length; ++i)c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8) throw \"invalid gzip data\";\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4) st += d[10] | (d[11] << 8) + 2;\n    for(var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function(d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function(o) {\n    return 10 + (o.filename && o.filename.length + 1 || 0);\n};\n// zlib header\nvar zlh = function(c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = fl << 6 | (fl ? 32 - 2 * fl : 1);\n};\n// zlib valid\nvar zlv = function(d) {\n    if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw \"invalid zlib data\";\n    if (d[1] & 32) throw \"invalid zlib data: preset dictionaries not supported\";\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */ var Deflate = /*#__PURE__*/ function() {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function(c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Deflate.prototype.push = function(chunk, final) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE compression\n */ var AsyncDeflate = /*#__PURE__*/ function() {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function() {\n                return [\n                    astrm,\n                    Deflate\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}();\n\nfunction deflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt\n    ], function(ev) {\n        return pbf(deflateSync(ev.data[0], ev.data[1]));\n    }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */ function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */ var Inflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function(c) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function(final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */ Inflate.prototype.push = function(chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE decompression\n */ var AsyncInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function() {\n                return [\n                    astrm,\n                    Inflate\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}();\n\nfunction inflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt\n    ], function(ev) {\n        return pbf(inflateSync(ev.data[0], gu8(ev.data[1])));\n    }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */ var Gzip = /*#__PURE__*/ function() {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gzip.prototype.push = function(chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function(c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v) gzh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}();\n\n/**\n * Asynchronous streaming GZIP compression\n */ var AsyncGzip = /*#__PURE__*/ function() {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Gzip\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}();\n\nfunction gzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function() {\n            return [\n                gzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gzipSync(ev.data[0], ev.data[1]));\n    }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */ function gzipSync(data, opts) {\n    if (!opts) opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */ var Gunzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gunzip.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final) return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8) throw \"invalid gzip stream\";\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}();\n\n/**\n * Asynchronous streaming GZIP decompression\n */ var AsyncGunzip = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Gunzip\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}();\n\nfunction gunzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function() {\n            return [\n                gunzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gunzipSync(ev.data[0]));\n    }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */ function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */ var Zlib = /*#__PURE__*/ function() {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Zlib.prototype.push = function(chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function(c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v) zlh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}();\n\n/**\n * Asynchronous streaming Zlib compression\n */ var AsyncZlib = /*#__PURE__*/ function() {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Zlib\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}();\n\nfunction zlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function() {\n            return [\n                zlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(zlibSync(ev.data[0], ev.data[1]));\n    }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */ function zlibSync(data, opts) {\n    if (!opts) opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */ var Unzlib = /*#__PURE__*/ function() {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzlib.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final) return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4) throw \"invalid zlib stream\";\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}();\n\n/**\n * Asynchronous streaming Zlib decompression\n */ var AsyncUnzlib = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Unzlib\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}();\n\nfunction unzlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function() {\n            return [\n                unzlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(unzlibSync(ev.data[0], gu8(ev.data[1])));\n    }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var Decompress = /*#__PURE__*/ function() {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */ function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Decompress.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no stream handler\";\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            } else this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function() {\n                    _this_1.ondata.apply(_this_1, arguments);\n                };\n                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        } else this.s.push(chunk, final);\n    };\n    return Decompress;\n}();\n\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var AsyncDecompress = /*#__PURE__*/ function() {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */ function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncDecompress.prototype.push = function(chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}();\n\nfunction decompress(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function decompressSync(data, out) {\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function(d, p, t, o) {\n    for(var k in d){\n        var val = d[k], n = p + k;\n        if (val instanceof u8) t[n] = [\n            val,\n            o\n        ];\n        else if (Array.isArray(val)) t[n] = [\n            val[0],\n            mrg(o, val[1])\n        ];\n        else fltn(val, n + \"/\", t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != \"undefined\" && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != \"undefined\" && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, {\n        stream: true\n    });\n    tds = 1;\n} catch (e) {}\n// decode UTF8\nvar dutf8 = function(d) {\n    for(var r = \"\", i = 0;;){\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length) return [\n            r,\n            slc(d, i - 1)\n        ];\n        if (!eb) r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n        } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);\n        else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */ var DecodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */ function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds) this.t = new TextDecoder();\n        else this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ DecodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, {\n                stream: true\n            }), final);\n            if (final) {\n                if (this.t.decode().length) throw \"invalid utf-8 data\";\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p) throw \"stream finished\";\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length) throw \"invalid utf-8 data\";\n            this.p = null;\n        } else this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}();\n\n/**\n * Streaming UTF-8 encoding\n */ var EncodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */ function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */ EncodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        if (this.d) throw \"stream finished\";\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}();\n\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */ function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for(var i = 0; i < str.length; ++i)ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te) return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function(v) {\n        ar[ai++] = v;\n    };\n    for(var i = 0; i < l; ++i){\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + (l - i << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1) w(c);\n        else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);\n        else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);\n        else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */ function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = \"\";\n        for(var i = 0; i < dat.length; i += 16384)r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    } else if (td) return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length) throw \"invalid utf-8 data\";\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function(l) {\n    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;\n};\n// skip local zip header\nvar slzh = function(d, b) {\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n};\n// read zip header\nvar zh = function(d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [\n        bs,\n        b4(d, b + 24),\n        b4(d, b + 42)\n    ], sc = _a[0], su = _a[1], off = _a[2];\n    return [\n        b2(d, b + 10),\n        sc,\n        su,\n        fn,\n        es + b2(d, b + 30) + b2(d, b + 32),\n        off\n    ];\n};\n// read zip64 extra field\nvar z64e = function(d, b) {\n    for(; b2(d, b) != 1; b += 4 + b2(d, b + 2));\n    return [\n        b8(d, b + 12),\n        b8(d, b + 4),\n        b8(d, b + 20)\n    ];\n};\n// extra field length\nvar exfl = function(ex) {\n    var le = 0;\n    if (ex) {\n        for(var k in ex){\n            var l = ex[k].length;\n            if (l > 65535) throw \"extra field too long\";\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function(d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null) d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119) throw \"date not in range 1980-2099\";\n    wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for(var k in ex){\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col) d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function(o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */ var ZipPassThrough = /*#__PURE__*/ function() {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */ function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.process = function(chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback - add to ZIP archive before pushing\";\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final) this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}();\n\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */ var ZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function(chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        } catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */ var AsyncZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function(err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function(chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}();\n\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */ var Zip = /*#__PURE__*/ function() {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */ function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */ Zip.prototype.add = function(file) {\n        var _this_1 = this;\n        if (this.d & 2) throw \"stream finished\";\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || o && com.length != o.length;\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535) throw \"filename too long\";\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [\n            header\n        ];\n        var pAll = function() {\n            for(var _i = 0, chks_1 = chks; _i < chks_1.length; _i++){\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function() {\n                if (file.terminate) file.terminate();\n            },\n            r: function() {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt) nxt.r();\n                    else _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function(err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            } else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr) uf.r();\n                    tr = 1;\n                } else if (tr) pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */ Zip.prototype.end = function() {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1) throw \"stream finishing\";\n            throw \"stream finished\";\n        }\n        if (this.d) this.e();\n        else this.u.push({\n            r: function() {\n                if (!(_this_1.d & 1)) return;\n                _this_1.u.splice(-1, 1);\n                _this_1.e();\n            },\n            t: function() {}\n        });\n        this.d = 3;\n    };\n    Zip.prototype.e = function() {\n        var bt = 0, l = 0, tl = 0;\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for(var _b = 0, _c = this.u; _b < _c.length; _b++){\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */ Zip.prototype.terminate = function() {\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}();\n\nfunction zip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    var r = {};\n    fltn(data, \"\", r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var cbf = function() {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for(var i = 0; i < slft; ++i){\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            } catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft) cbf();\n    var _loop_1 = function(i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || m && com.length != ms,\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft) cbf();\n            }\n        };\n        if (s > 65535) cbl(\"filename too long\", null);\n        if (!compression) cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            } catch (e) {\n                cbl(e, null);\n            }\n        } else term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for(var i = 0; i < slft; ++i){\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */ function zipSync(data, opts) {\n    if (!opts) opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, \"\", r, opts);\n    var o = 0;\n    var tot = 0;\n    for(var fn in r){\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535) throw \"filename too long\";\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || m && com.length != ms,\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for(var i = 0; i < files.length; ++i){\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */ var UnzipPassThrough = /*#__PURE__*/ function() {\n    function UnzipPassThrough() {}\n    UnzipPassThrough.prototype.push = function(data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}();\n\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */ var UnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function(data, final) {\n        try {\n            this.i.push(data, final);\n        } catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */ var AsyncUnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function(dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        } else {\n            this.i = new AsyncInflate(function(err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function(data, final) {\n        if (this.i.terminate) data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}();\n\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */ var Unzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */ function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzip.prototype.push = function(chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile) throw \"no callback\";\n        if (!this.p) throw \"stream finished\";\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d) this.d.push(toAdd, !this.c);\n            else this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length) return this.push(chunk, final);\n        } else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length) buf = chunk;\n            else if (!chunk.length) buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function() {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [\n                                -2\n                            ] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        } else if (dd) sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function() {\n                                if (!file_1.ondata) throw \"no callback\";\n                                if (!sc_1) file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr) throw \"unknown compression type \" + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function(err, dat, final) {\n                                        file_1.ondata(err, dat, final);\n                                    };\n                                    for(var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++){\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c) _this_1.d = d_1;\n                                    else d_1.push(et, true);\n                                }\n                            },\n                            terminate: function() {\n                                if (d_1 && d_1.terminate) d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                } else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    } else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for(; i < l - 4; ++i){\n                var state_1 = _loop_2();\n                if (state_1 === \"break\") break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add) add.push(dat, !!f);\n                else this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2) return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c) throw \"invalid zip file\";\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */ Unzip.prototype.register = function(decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}();\n\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */ function unzip(data, cb) {\n    if (typeof cb != \"function\") throw \"no callback\";\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) {\n            cb(\"invalid zip file\", null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft) cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb(\"invalid zip file\", null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function(i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                files[fn] = d;\n                if (!--lft) cb(null, files);\n            }\n        };\n        if (!c_1) cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                } catch (e) {\n                    cbl(e, null);\n                }\n            } else term.push(inflate(infl, {\n                size: su\n            }, cbl));\n        } else cbl(\"unknown compression type \" + c_1, null);\n    };\n    for(var i = 0; i < c; ++i){\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */ function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) throw \"invalid zip file\";\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c) return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) throw \"invalid zip file\";\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for(var i = 0; i < c; ++i){\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2) files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else throw \"unknown compression type \" + c_2;\n    }\n    return files;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL25vZGVfbW9kdWxlcy9mZmxhdGUvZXNtL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ3ZDLElBQUlDLFVBQVVELHFEQUFhQSxDQUFDO0FBQzVCLDJGQUEyRjtBQUMzRixzQ0FBc0M7QUFDdEMsMkVBQTJFO0FBQzNFLHFFQUFxRTtBQUNyRSw0REFBNEQ7QUFDNUQsc0NBQXNDO0FBQ3RDLHVIQUF1SDtBQUN2SCwyRkFBMkY7QUFDM0Ysb0RBQW9EO0FBQ3BELGdCQUFnQjtBQUNoQixJQUFJRTtBQUNKLElBQUlDLFlBQVk7QUFDaEIsSUFBSTtJQUNBRCxTQUFTRCxRQUFRLGtCQUFrQkMsTUFBTTtBQUM3QyxFQUNBLE9BQU9FLEdBQUcsQ0FDVjtBQUNBLElBQUlDLEtBQUtILFNBQVMsU0FBVUksQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEdBQUcsRUFBRUMsUUFBUSxFQUFFQyxFQUFFO0lBQy9DLElBQUlDLE9BQU87SUFDWCxJQUFJQyxJQUFJLElBQUlWLE9BQU9JLElBQUlILFdBQVc7UUFBRVUsTUFBTTtJQUFLLEdBQzFDQyxFQUFFLENBQUMsU0FBUyxTQUFVVixDQUFDO1FBQUksT0FBT00sR0FBR04sR0FBRztJQUFPLEdBQy9DVSxFQUFFLENBQUMsV0FBVyxTQUFVQyxDQUFDO1FBQUksT0FBT0wsR0FBRyxNQUFNSztJQUFJLEdBQ2pERCxFQUFFLENBQUMsUUFBUSxTQUFVUixDQUFDO1FBQ3ZCLElBQUlBLEtBQUssQ0FBQ0ssTUFDTkQsR0FBRyxJQUFJTSxNQUFNLHNCQUFzQlYsSUFBSTtJQUMvQztJQUNBTSxFQUFFSyxXQUFXLENBQUNULEtBQUtDO0lBQ25CRyxFQUFFTSxTQUFTLEdBQUc7UUFDVlAsT0FBTztRQUNQLE9BQU9ULE9BQU9pQixTQUFTLENBQUNELFNBQVMsQ0FBQ0UsSUFBSSxDQUFDUjtJQUMz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UUFDeEIsSUFBSUcsS0FBS3dULEdBQUdsRixNQUFNdk0sR0FBRzBSLElBQUltRyxNQUFNNVosRUFBRSxDQUFDLEVBQUUsRUFBRTZULEtBQUs3VCxFQUFFLENBQUMsRUFBRSxFQUFFOFQsS0FBSzlULEVBQUUsQ0FBQyxFQUFFLEVBQUV3TCxLQUFLeEwsRUFBRSxDQUFDLEVBQUUsRUFBRXlaLEtBQUt6WixFQUFFLENBQUMsRUFBRSxFQUFFK1QsTUFBTS9ULEVBQUUsQ0FBQyxFQUFFLEVBQUVKLElBQUkyVCxLQUFLakYsTUFBTXlGO1FBQ2xIaFMsSUFBSTBYO1FBQ0osSUFBSSxDQUFDRyxLQUNEOUMsS0FBSyxDQUFDdEwsR0FBRyxHQUFHdEosSUFBSW9NLE1BQU0xTyxHQUFHQSxJQUFJaVU7YUFDNUIsSUFBSStGLE9BQU8sR0FDWjlDLEtBQUssQ0FBQ3RMLEdBQUcsR0FBR3FCLFlBQVl5QixLQUFLak0sUUFBUSxDQUFDekMsR0FBR0EsSUFBSWlVLEtBQUssSUFBSTdVLEdBQUc4VTthQUV6RCxNQUFNLDhCQUE4QjhGO0lBQzVDO0lBQ0EsT0FBTzlDO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtY3JlYXRpdmUtcG9ydGZvbGlvLXN0YXJ0ZXItY29kZS1maWxlcy8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbm9kZV9tb2R1bGVzL2ZmbGF0ZS9lc20vaW5kZXgubWpzP2NjNjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gJ21vZHVsZSc7XG52YXIgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoJy8nKTtcbi8vIERFRkxBVEUgaXMgYSBjb21wbGV4IGZvcm1hdDsgdG8gcmVhZCB0aGlzIGNvZGUsIHlvdSBzaG91bGQgcHJvYmFibHkgY2hlY2sgdGhlIFJGQyBmaXJzdDpcbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxOTUxXG4vLyBZb3UgbWF5IGFsc28gd2lzaCB0byB0YWtlIGEgbG9vayBhdCB0aGUgZ3VpZGUgSSBtYWRlIGFib3V0IHRoaXMgcHJvZ3JhbTpcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwMWFycm93ei8yNTNmMzFlYjVhYmMzZDkyNzVhYjk0MzAwM2ZmZWNhZFxuLy8gU29tZSBvZiB0aGUgZm9sbG93aW5nIGNvZGUgaXMgc2ltaWxhciB0byB0aGF0IG9mIFVaSVAuanM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9wZWEvVVpJUC5qc1xuLy8gSG93ZXZlciwgdGhlIHZhc3QgbWFqb3JpdHkgb2YgdGhlIGNvZGViYXNlIGhhcyBkaXZlcmdlZCBmcm9tIFVaSVAuanMgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UgYW5kIHJlZHVjZSBidW5kbGUgc2l6ZS5cbi8vIFNvbWV0aW1lcyAwIHdpbGwgYXBwZWFyIHdoZXJlIC0xIHdvdWxkIGJlIG1vcmUgYXBwcm9wcmlhdGUuIFRoaXMgaXMgYmVjYXVzZSB1c2luZyBhIHVpbnRcbi8vIGlzIGJldHRlciBmb3IgbWVtb3J5IGluIG1vc3QgZW5naW5lcyAoSSAqdGhpbmsqKS5cbi8vIE1lZGlvY3JlIHNoaW1cbnZhciBXb3JrZXI7XG52YXIgd29ya2VyQWRkID0gXCI7dmFyIF9fdz1yZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpO19fdy5wYXJlbnRQb3J0Lm9uKCdtZXNzYWdlJyxmdW5jdGlvbihtKXtvbm1lc3NhZ2Uoe2RhdGE6bX0pfSkscG9zdE1lc3NhZ2U9ZnVuY3Rpb24obSx0KXtfX3cucGFyZW50UG9ydC5wb3N0TWVzc2FnZShtLHQpfSxjbG9zZT1wcm9jZXNzLmV4aXQ7c2VsZj1nbG9iYWxcIjtcbnRyeSB7XG4gICAgV29ya2VyID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKS5Xb3JrZXI7XG59XG5jYXRjaCAoZSkge1xufVxudmFyIHdrID0gV29ya2VyID8gZnVuY3Rpb24gKGMsIF8sIG1zZywgdHJhbnNmZXIsIGNiKSB7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB2YXIgdyA9IG5ldyBXb3JrZXIoYyArIHdvcmtlckFkZCwgeyBldmFsOiB0cnVlIH0pXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gY2IoZSwgbnVsbCk7IH0pXG4gICAgICAgIC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChtKSB7IHJldHVybiBjYihudWxsLCBtKTsgfSlcbiAgICAgICAgLm9uKCdleGl0JywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgJiYgIWRvbmUpXG4gICAgICAgICAgICBjYihuZXcgRXJyb3IoJ2V4aXRlZCB3aXRoIGNvZGUgJyArIGMpLCBudWxsKTtcbiAgICB9KTtcbiAgICB3LnBvc3RNZXNzYWdlKG1zZywgdHJhbnNmZXIpO1xuICAgIHcudGVybWluYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFdvcmtlci5wcm90b3R5cGUudGVybWluYXRlLmNhbGwodyk7XG4gICAgfTtcbiAgICByZXR1cm4gdztcbn0gOiBmdW5jdGlvbiAoXywgX18sIF9fXywgX19fXywgY2IpIHtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2IobmV3IEVycm9yKCdhc3luYyBvcGVyYXRpb25zIHVuc3VwcG9ydGVkIC0gdXBkYXRlIHRvIE5vZGUgMTIrIChvciBOb2RlIDEwLTExIHdpdGggdGhlIC0tZXhwZXJpbWVudGFsLXdvcmtlciBDTEkgZmxhZyknKSwgbnVsbCk7IH0pO1xuICAgIHZhciBOT1AgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGVybWluYXRlOiBOT1AsXG4gICAgICAgIHBvc3RNZXNzYWdlOiBOT1BcbiAgICB9O1xufTtcblxuLy8gYWxpYXNlcyBmb3Igc2hvcnRlciBjb21wcmVzc2VkIGNvZGUgKG1vc3QgbWluaWZlcnMgZG9uJ3QgZG8gdGhpcylcbnZhciB1OCA9IFVpbnQ4QXJyYXksIHUxNiA9IFVpbnQxNkFycmF5LCB1MzIgPSBVaW50MzJBcnJheTtcbi8vIGZpeGVkIGxlbmd0aCBleHRyYSBiaXRzXG52YXIgZmxlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgLyogdW51c2VkICovIDAsIDAsIC8qIGltcG9zc2libGUgKi8gMF0pO1xuLy8gZml4ZWQgZGlzdGFuY2UgZXh0cmEgYml0c1xuLy8gc2VlIGZsZWIgbm90ZVxudmFyIGZkZWIgPSBuZXcgdTgoWzAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgLyogdW51c2VkICovIDAsIDBdKTtcbi8vIGNvZGUgbGVuZ3RoIGluZGV4IG1hcFxudmFyIGNsaW0gPSBuZXcgdTgoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKTtcbi8vIGdldCBiYXNlLCByZXZlcnNlIGluZGV4IG1hcCBmcm9tIGV4dHJhIGJpdHNcbnZhciBmcmViID0gZnVuY3Rpb24gKGViLCBzdGFydCkge1xuICAgIHZhciBiID0gbmV3IHUxNigzMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMTsgKytpKSB7XG4gICAgICAgIGJbaV0gPSBzdGFydCArPSAxIDw8IGViW2kgLSAxXTtcbiAgICB9XG4gICAgLy8gbnVtYmVycyBoZXJlIGFyZSBhdCBtYXggMTggYml0c1xuICAgIHZhciByID0gbmV3IHUzMihiWzMwXSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAzMDsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBiW2ldOyBqIDwgYltpICsgMV07ICsraikge1xuICAgICAgICAgICAgcltqXSA9ICgoaiAtIGJbaV0pIDw8IDUpIHwgaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2IsIHJdO1xufTtcbnZhciBfYSA9IGZyZWIoZmxlYiwgMiksIGZsID0gX2FbMF0sIHJldmZsID0gX2FbMV07XG4vLyB3ZSBjYW4gaWdub3JlIHRoZSBmYWN0IHRoYXQgdGhlIG90aGVyIG51bWJlcnMgYXJlIHdyb25nOyB0aGV5IG5ldmVyIGhhcHBlbiBhbnl3YXlcbmZsWzI4XSA9IDI1OCwgcmV2ZmxbMjU4XSA9IDI4O1xudmFyIF9iID0gZnJlYihmZGViLCAwKSwgZmQgPSBfYlswXSwgcmV2ZmQgPSBfYlsxXTtcbi8vIG1hcCBvZiB2YWx1ZSB0byByZXZlcnNlIChhc3N1bWluZyAxNiBiaXRzKVxudmFyIHJldiA9IG5ldyB1MTYoMzI3NjgpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjc2ODsgKytpKSB7XG4gICAgLy8gcmV2ZXJzZSB0YWJsZSBhbGdvcml0aG0gZnJvbSBTT1xuICAgIHZhciB4ID0gKChpICYgMHhBQUFBKSA+Pj4gMSkgfCAoKGkgJiAweDU1NTUpIDw8IDEpO1xuICAgIHggPSAoKHggJiAweENDQ0MpID4+PiAyKSB8ICgoeCAmIDB4MzMzMykgPDwgMik7XG4gICAgeCA9ICgoeCAmIDB4RjBGMCkgPj4+IDQpIHwgKCh4ICYgMHgwRjBGKSA8PCA0KTtcbiAgICByZXZbaV0gPSAoKCh4ICYgMHhGRjAwKSA+Pj4gOCkgfCAoKHggJiAweDAwRkYpIDw8IDgpKSA+Pj4gMTtcbn1cbi8vIGNyZWF0ZSBodWZmbWFuIHRyZWUgZnJvbSB1OCBcIm1hcFwiOiBpbmRleCAtPiBjb2RlIGxlbmd0aCBmb3IgY29kZSBpbmRleFxuLy8gbWIgKG1heCBiaXRzKSBtdXN0IGJlIGF0IG1vc3QgMTVcbi8vIFRPRE86IG9wdGltaXplL3NwbGl0IHVwP1xudmFyIGhNYXAgPSAoZnVuY3Rpb24gKGNkLCBtYiwgcikge1xuICAgIHZhciBzID0gY2QubGVuZ3RoO1xuICAgIC8vIGluZGV4XG4gICAgdmFyIGkgPSAwO1xuICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiAjIG9mIGNvZGVzIHdpdGggYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGwgPSBuZXcgdTE2KG1iKTtcbiAgICAvLyBsZW5ndGggb2YgY2QgbXVzdCBiZSAyODggKHRvdGFsICMgb2YgY29kZXMpXG4gICAgZm9yICg7IGkgPCBzOyArK2kpXG4gICAgICAgICsrbFtjZFtpXSAtIDFdO1xuICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiBtaW5pbXVtIGNvZGUgZm9yIGJpdCBsZW5ndGggPSBpbmRleFxuICAgIHZhciBsZSA9IG5ldyB1MTYobWIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtYjsgKytpKSB7XG4gICAgICAgIGxlW2ldID0gKGxlW2kgLSAxXSArIGxbaSAtIDFdKSA8PCAxO1xuICAgIH1cbiAgICB2YXIgY287XG4gICAgaWYgKHIpIHtcbiAgICAgICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG51bWJlciBvZiBhY3R1YWwgYml0cywgc3ltYm9sIGZvciBjb2RlXG4gICAgICAgIGNvID0gbmV3IHUxNigxIDw8IG1iKTtcbiAgICAgICAgLy8gYml0cyB0byByZW1vdmUgZm9yIHJldmVyc2VyXG4gICAgICAgIHZhciBydmIgPSAxNSAtIG1iO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgMCBsZW5ndGhzXG4gICAgICAgICAgICBpZiAoY2RbaV0pIHtcbiAgICAgICAgICAgICAgICAvLyBudW0gZW5jb2RpbmcgYm90aCBzeW1ib2wgYW5kIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgIHZhciBzdiA9IChpIDw8IDQpIHwgY2RbaV07XG4gICAgICAgICAgICAgICAgLy8gZnJlZSBiaXRzXG4gICAgICAgICAgICAgICAgdmFyIHJfMSA9IG1iIC0gY2RbaV07XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGxlW2NkW2ldIC0gMV0rKyA8PCByXzE7XG4gICAgICAgICAgICAgICAgLy8gbSBpcyBlbmQgdmFsdWVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gdiB8ICgoMSA8PCByXzEpIC0gMSk7IHYgPD0gbTsgKyt2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZXJ5IDE2IGJpdCB2YWx1ZSBzdGFydGluZyB3aXRoIHRoZSBjb2RlIHlpZWxkcyB0aGUgc2FtZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgY29bcmV2W3ZdID4+PiBydmJdID0gc3Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjbyA9IG5ldyB1MTYocyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIGNvW2ldID0gcmV2W2xlW2NkW2ldIC0gMV0rK10gPj4+ICgxNSAtIGNkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY287XG59KTtcbi8vIGZpeGVkIGxlbmd0aCB0cmVlXG52YXIgZmx0ID0gbmV3IHU4KDI4OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDE0NDsgKytpKVxuICAgIGZsdFtpXSA9IDg7XG5mb3IgKHZhciBpID0gMTQ0OyBpIDwgMjU2OyArK2kpXG4gICAgZmx0W2ldID0gOTtcbmZvciAodmFyIGkgPSAyNTY7IGkgPCAyODA7ICsraSlcbiAgICBmbHRbaV0gPSA3O1xuZm9yICh2YXIgaSA9IDI4MDsgaSA8IDI4ODsgKytpKVxuICAgIGZsdFtpXSA9IDg7XG4vLyBmaXhlZCBkaXN0YW5jZSB0cmVlXG52YXIgZmR0ID0gbmV3IHU4KDMyKTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMzI7ICsraSlcbiAgICBmZHRbaV0gPSA1O1xuLy8gZml4ZWQgbGVuZ3RoIG1hcFxudmFyIGZsbSA9IC8qI19fUFVSRV9fKi8gaE1hcChmbHQsIDksIDApLCBmbHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBtYXBcbnZhciBmZG0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmR0LCA1LCAwKSwgZmRybSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDEpO1xuLy8gZmluZCBtYXggb2YgYXJyYXlcbnZhciBtYXggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBtID0gYVswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gPiBtKVxuICAgICAgICAgICAgbSA9IGFbaV07XG4gICAgfVxuICAgIHJldHVybiBtO1xufTtcbi8vIHJlYWQgZCwgc3RhcnRpbmcgYXQgYml0IHAgYW5kIG1hc2sgd2l0aCBtXG52YXIgYml0cyA9IGZ1bmN0aW9uIChkLCBwLCBtKSB7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICByZXR1cm4gKChkW29dIHwgKGRbbyArIDFdIDw8IDgpKSA+PiAocCAmIDcpKSAmIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBjb250aW51aW5nIGZvciBhdCBsZWFzdCAxNiBiaXRzXG52YXIgYml0czE2ID0gZnVuY3Rpb24gKGQsIHApIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkgfCAoZFtvICsgMl0gPDwgMTYpKSA+PiAocCAmIDcpKTtcbn07XG4vLyBnZXQgZW5kIG9mIGJ5dGVcbnZhciBzaGZ0ID0gZnVuY3Rpb24gKHApIHsgcmV0dXJuICgocCAvIDgpIHwgMCkgKyAocCAmIDcgJiYgMSk7IH07XG4vLyB0eXBlZCBhcnJheSBzbGljZSAtIGFsbG93cyBnYXJiYWdlIGNvbGxlY3RvciB0byBmcmVlIG9yaWdpbmFsIHJlZmVyZW5jZSxcbi8vIHdoaWxlIGJlaW5nIG1vcmUgY29tcGF0aWJsZSB0aGFuIC5zbGljZVxudmFyIHNsYyA9IGZ1bmN0aW9uICh2LCBzLCBlKSB7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIGUgPSB2Lmxlbmd0aDtcbiAgICAvLyBjYW4ndCB1c2UgLmNvbnN0cnVjdG9yIGluIGNhc2UgdXNlci1zdXBwbGllZFxuICAgIHZhciBuID0gbmV3ICh2IGluc3RhbmNlb2YgdTE2ID8gdTE2IDogdiBpbnN0YW5jZW9mIHUzMiA/IHUzMiA6IHU4KShlIC0gcyk7XG4gICAgbi5zZXQodi5zdWJhcnJheShzLCBlKSk7XG4gICAgcmV0dXJuIG47XG59O1xuLy8gZXhwYW5kcyByYXcgREVGTEFURSBkYXRhXG52YXIgaW5mbHQgPSBmdW5jdGlvbiAoZGF0LCBidWYsIHN0KSB7XG4gICAgLy8gc291cmNlIGxlbmd0aFxuICAgIHZhciBzbCA9IGRhdC5sZW5ndGg7XG4gICAgaWYgKCFzbCB8fCAoc3QgJiYgIXN0LmwgJiYgc2wgPCA1KSlcbiAgICAgICAgcmV0dXJuIGJ1ZiB8fCBuZXcgdTgoMCk7XG4gICAgLy8gaGF2ZSB0byBlc3RpbWF0ZSBzaXplXG4gICAgdmFyIG5vQnVmID0gIWJ1ZiB8fCBzdDtcbiAgICAvLyBubyBzdGF0ZVxuICAgIHZhciBub1N0ID0gIXN0IHx8IHN0Lmk7XG4gICAgaWYgKCFzdClcbiAgICAgICAgc3QgPSB7fTtcbiAgICAvLyBBc3N1bWVzIHJvdWdobHkgMzMlIGNvbXByZXNzaW9uIHJhdGlvIGF2ZXJhZ2VcbiAgICBpZiAoIWJ1ZilcbiAgICAgICAgYnVmID0gbmV3IHU4KHNsICogMyk7XG4gICAgLy8gZW5zdXJlIGJ1ZmZlciBjYW4gZml0IGF0IGxlYXN0IGwgZWxlbWVudHNcbiAgICB2YXIgY2J1ZiA9IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHZhciBibCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIC8vIG5lZWQgdG8gaW5jcmVhc2Ugc2l6ZSB0byBmaXRcbiAgICAgICAgaWYgKGwgPiBibCkge1xuICAgICAgICAgICAgLy8gRG91YmxlIG9yIHNldCB0byBuZWNlc3NhcnksIHdoaWNoZXZlciBpcyBncmVhdGVyXG4gICAgICAgICAgICB2YXIgbmJ1ZiA9IG5ldyB1OChNYXRoLm1heChibCAqIDIsIGwpKTtcbiAgICAgICAgICAgIG5idWYuc2V0KGJ1Zik7XG4gICAgICAgICAgICBidWYgPSBuYnVmO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAgbGFzdCBjaHVuayAgICAgICAgIGJpdHBvcyAgICAgICAgICAgYnl0ZXNcbiAgICB2YXIgZmluYWwgPSBzdC5mIHx8IDAsIHBvcyA9IHN0LnAgfHwgMCwgYnQgPSBzdC5iIHx8IDAsIGxtID0gc3QubCwgZG0gPSBzdC5kLCBsYnQgPSBzdC5tLCBkYnQgPSBzdC5uO1xuICAgIC8vIHRvdGFsIGJpdHNcbiAgICB2YXIgdGJ0cyA9IHNsICogODtcbiAgICBkbyB7XG4gICAgICAgIGlmICghbG0pIHtcbiAgICAgICAgICAgIC8vIEJGSU5BTCAtIHRoaXMgaXMgb25seSAxIHdoZW4gbGFzdCBjaHVuayBpcyBuZXh0XG4gICAgICAgICAgICBzdC5mID0gZmluYWwgPSBiaXRzKGRhdCwgcG9zLCAxKTtcbiAgICAgICAgICAgIC8vIHR5cGU6IDAgPSBubyBjb21wcmVzc2lvbiwgMSA9IGZpeGVkIGh1ZmZtYW4sIDIgPSBkeW5hbWljIGh1ZmZtYW5cbiAgICAgICAgICAgIHZhciB0eXBlID0gYml0cyhkYXQsIHBvcyArIDEsIDMpO1xuICAgICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBnbyB0byBlbmQgb2YgYnl0ZSBib3VuZGFyeVxuICAgICAgICAgICAgICAgIHZhciBzID0gc2hmdChwb3MpICsgNCwgbCA9IGRhdFtzIC0gNF0gfCAoZGF0W3MgLSAzXSA8PCA4KSwgdCA9IHMgKyBsO1xuICAgICAgICAgICAgICAgIGlmICh0ID4gc2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5leHBlY3RlZCBFT0YnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHNpemVcbiAgICAgICAgICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICAgICAgICAgIGNidWYoYnQgKyBsKTtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IG92ZXIgdW5jb21wcmVzc2VkIGRhdGFcbiAgICAgICAgICAgICAgICBidWYuc2V0KGRhdC5zdWJhcnJheShzLCB0KSwgYnQpO1xuICAgICAgICAgICAgICAgIC8vIEdldCBuZXcgYml0cG9zLCB1cGRhdGUgYnl0ZSBjb3VudFxuICAgICAgICAgICAgICAgIHN0LmIgPSBidCArPSBsLCBzdC5wID0gcG9zID0gdCAqIDg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDEpXG4gICAgICAgICAgICAgICAgbG0gPSBmbHJtLCBkbSA9IGZkcm0sIGxidCA9IDksIGRidCA9IDU7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyAgbGl0ZXJhbCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhzXG4gICAgICAgICAgICAgICAgdmFyIGhMaXQgPSBiaXRzKGRhdCwgcG9zLCAzMSkgKyAyNTcsIGhjTGVuID0gYml0cyhkYXQsIHBvcyArIDEwLCAxNSkgKyA0O1xuICAgICAgICAgICAgICAgIHZhciB0bCA9IGhMaXQgKyBiaXRzKGRhdCwgcG9zICsgNSwgMzEpICsgMTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTQ7XG4gICAgICAgICAgICAgICAgLy8gbGVuZ3RoK2Rpc3RhbmNlIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgbGR0ID0gbmV3IHU4KHRsKTtcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGNsdCA9IG5ldyB1OCgxOSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoY0xlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBpbmRleCBtYXAgdG8gZ2V0IHJlYWwgY29kZVxuICAgICAgICAgICAgICAgICAgICBjbHRbY2xpbVtpXV0gPSBiaXRzKGRhdCwgcG9zICsgaSAqIDMsIDcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gaGNMZW4gKiAzO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBiaXRzXG4gICAgICAgICAgICAgICAgdmFyIGNsYiA9IG1heChjbHQpLCBjbGJtc2sgPSAoMSA8PCBjbGIpIC0gMTtcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aHMgbWFwXG4gICAgICAgICAgICAgICAgdmFyIGNsbSA9IGhNYXAoY2x0LCBjbGIsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGw7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gY2xtW2JpdHMoZGF0LCBwb3MsIGNsYm1zayldO1xuICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIHJlYWRcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IHIgJiAxNTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gciA+Pj4gNDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGggdG8gY29weVxuICAgICAgICAgICAgICAgICAgICBpZiAocyA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZHRbaSsrXSA9IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgY29weSAgIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IDAsIG4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT0gMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDMgKyBiaXRzKGRhdCwgcG9zLCAzKSwgcG9zICs9IDIsIGMgPSBsZHRbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxNylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDcpLCBwb3MgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gMTgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDExICsgYml0cyhkYXQsIHBvcywgMTI3KSwgcG9zICs9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobi0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxkdFtpKytdID0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICBsZW5ndGggdHJlZSAgICAgICAgICAgICAgICAgZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsdCA9IGxkdC5zdWJhcnJheSgwLCBoTGl0KSwgZHQgPSBsZHQuc3ViYXJyYXkoaExpdCk7XG4gICAgICAgICAgICAgICAgLy8gbWF4IGxlbmd0aCBiaXRzXG4gICAgICAgICAgICAgICAgbGJ0ID0gbWF4KGx0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggZGlzdCBiaXRzXG4gICAgICAgICAgICAgICAgZGJ0ID0gbWF4KGR0KTtcbiAgICAgICAgICAgICAgICBsbSA9IGhNYXAobHQsIGxidCwgMSk7XG4gICAgICAgICAgICAgICAgZG0gPSBoTWFwKGR0LCBkYnQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3VuZXhwZWN0ZWQgRU9GJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGJ1ZmZlciBjYW4gaG9sZCB0aGlzICsgdGhlIGxhcmdlc3QgcG9zc2libGUgYWRkaXRpb25cbiAgICAgICAgLy8gTWF4aW11bSBjaHVuayBzaXplIChwcmFjdGljYWxseSwgdGhlb3JldGljYWxseSBpbmZpbml0ZSkgaXMgMl4xNztcbiAgICAgICAgaWYgKG5vQnVmKVxuICAgICAgICAgICAgY2J1ZihidCArIDEzMTA3Mik7XG4gICAgICAgIHZhciBsbXMgPSAoMSA8PCBsYnQpIC0gMSwgZG1zID0gKDEgPDwgZGJ0KSAtIDE7XG4gICAgICAgIHZhciBscG9zID0gcG9zO1xuICAgICAgICBmb3IgKDs7IGxwb3MgPSBwb3MpIHtcbiAgICAgICAgICAgIC8vIGJpdHMgcmVhZCwgY29kZVxuICAgICAgICAgICAgdmFyIGMgPSBsbVtiaXRzMTYoZGF0LCBwb3MpICYgbG1zXSwgc3ltID0gYyA+Pj4gNDtcbiAgICAgICAgICAgIHBvcyArPSBjICYgMTU7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5leHBlY3RlZCBFT0YnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGxlbmd0aC9saXRlcmFsJztcbiAgICAgICAgICAgIGlmIChzeW0gPCAyNTYpXG4gICAgICAgICAgICAgICAgYnVmW2J0KytdID0gc3ltO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3ltID09IDI1Nikge1xuICAgICAgICAgICAgICAgIGxwb3MgPSBwb3MsIGxtID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhZGQgPSBzeW0gLSAyNTQ7XG4gICAgICAgICAgICAgICAgLy8gbm8gZXh0cmEgYml0cyBuZWVkZWQgaWYgbGVzc1xuICAgICAgICAgICAgICAgIGlmIChzeW0gPiAyNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBzeW0gLSAyNTcsIGIgPSBmbGViW2ldO1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSBiaXRzKGRhdCwgcG9zLCAoMSA8PCBiKSAtIDEpICsgZmxbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXN0XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkbVtiaXRzMTYoZGF0LCBwb3MpICYgZG1zXSwgZHN5bSA9IGQgPj4+IDQ7XG4gICAgICAgICAgICAgICAgaWYgKCFkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCBkaXN0YW5jZSc7XG4gICAgICAgICAgICAgICAgcG9zICs9IGQgJiAxNTtcbiAgICAgICAgICAgICAgICB2YXIgZHQgPSBmZFtkc3ltXTtcbiAgICAgICAgICAgICAgICBpZiAoZHN5bSA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBmZGViW2RzeW1dO1xuICAgICAgICAgICAgICAgICAgICBkdCArPSBiaXRzMTYoZGF0LCBwb3MpICYgKCgxIDw8IGIpIC0gMSksIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICAgICAgICAgIGNidWYoYnQgKyAxMzEwNzIpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBidCArIGFkZDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYnQgPCBlbmQ7IGJ0ICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0XSA9IGJ1ZltidCAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgMV0gPSBidWZbYnQgKyAxIC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAyXSA9IGJ1ZltidCArIDIgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDNdID0gYnVmW2J0ICsgMyAtIGR0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3QubCA9IGxtLCBzdC5wID0gbHBvcywgc3QuYiA9IGJ0O1xuICAgICAgICBpZiAobG0pXG4gICAgICAgICAgICBmaW5hbCA9IDEsIHN0Lm0gPSBsYnQsIHN0LmQgPSBkbSwgc3QubiA9IGRidDtcbiAgICB9IHdoaWxlICghZmluYWwpO1xuICAgIHJldHVybiBidCA9PSBidWYubGVuZ3RoID8gYnVmIDogc2xjKGJ1ZiwgMCwgYnQpO1xufTtcbi8vIHN0YXJ0aW5nIGF0IHAsIHdyaXRlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBiaXRzIHRoYXQgY2FuIGhvbGQgdiB0byBkXG52YXIgd2JpdHMgPSBmdW5jdGlvbiAoZCwgcCwgdikge1xuICAgIHYgPDw9IHAgJiA3O1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgZFtvXSB8PSB2O1xuICAgIGRbbyArIDFdIHw9IHYgPj4+IDg7XG59O1xuLy8gc3RhcnRpbmcgYXQgcCwgd3JpdGUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJpdHMgKD44KSB0aGF0IGNhbiBob2xkIHYgdG8gZFxudmFyIHdiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCwgdikge1xuICAgIHYgPDw9IHAgJiA3O1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgZFtvXSB8PSB2O1xuICAgIGRbbyArIDFdIHw9IHYgPj4+IDg7XG4gICAgZFtvICsgMl0gfD0gdiA+Pj4gMTY7XG59O1xuLy8gY3JlYXRlcyBjb2RlIGxlbmd0aHMgZnJvbSBhIGZyZXF1ZW5jeSB0YWJsZVxudmFyIGhUcmVlID0gZnVuY3Rpb24gKGQsIG1iKSB7XG4gICAgLy8gTmVlZCBleHRyYSBpbmZvIHRvIG1ha2UgYSB0cmVlXG4gICAgdmFyIHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGRbaV0pXG4gICAgICAgICAgICB0LnB1c2goeyBzOiBpLCBmOiBkW2ldIH0pO1xuICAgIH1cbiAgICB2YXIgcyA9IHQubGVuZ3RoO1xuICAgIHZhciB0MiA9IHQuc2xpY2UoKTtcbiAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybiBbZXQsIDBdO1xuICAgIGlmIChzID09IDEpIHtcbiAgICAgICAgdmFyIHYgPSBuZXcgdTgodFswXS5zICsgMSk7XG4gICAgICAgIHZbdFswXS5zXSA9IDE7XG4gICAgICAgIHJldHVybiBbdiwgMV07XG4gICAgfVxuICAgIHQuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5mIC0gYi5mOyB9KTtcbiAgICAvLyBhZnRlciBpMiByZWFjaGVzIGxhc3QgaW5kLCB3aWxsIGJlIHN0b3BwZWRcbiAgICAvLyBmcmVxIG11c3QgYmUgZ3JlYXRlciB0aGFuIGxhcmdlc3QgcG9zc2libGUgbnVtYmVyIG9mIHN5bWJvbHNcbiAgICB0LnB1c2goeyBzOiAtMSwgZjogMjUwMDEgfSk7XG4gICAgdmFyIGwgPSB0WzBdLCByID0gdFsxXSwgaTAgPSAwLCBpMSA9IDEsIGkyID0gMjtcbiAgICB0WzBdID0geyBzOiAtMSwgZjogbC5mICsgci5mLCBsOiBsLCByOiByIH07XG4gICAgLy8gZWZmaWNpZW50IGFsZ29yaXRobSBmcm9tIFVaSVAuanNcbiAgICAvLyBpMCBpcyBsb29rYmVoaW5kLCBpMiBpcyBsb29rYWhlYWQgLSBhZnRlciBwcm9jZXNzaW5nIHR3byBsb3ctZnJlcVxuICAgIC8vIHN5bWJvbHMgdGhhdCBjb21iaW5lZCBoYXZlIGhpZ2ggZnJlcSwgd2lsbCBzdGFydCBwcm9jZXNzaW5nIGkyIChoaWdoLWZyZXEsXG4gICAgLy8gbm9uLWNvbXBvc2l0ZSkgc3ltYm9scyBpbnN0ZWFkXG4gICAgLy8gc2VlIGh0dHBzOi8vcmVkZGl0LmNvbS9yL3Bob3RvcGVhL2NvbW1lbnRzL2lrZWtodC91emlwanNfcXVlc3Rpb25zL1xuICAgIHdoaWxlIChpMSAhPSBzIC0gMSkge1xuICAgICAgICBsID0gdFt0W2kwXS5mIDwgdFtpMl0uZiA/IGkwKysgOiBpMisrXTtcbiAgICAgICAgciA9IHRbaTAgIT0gaTEgJiYgdFtpMF0uZiA8IHRbaTJdLmYgPyBpMCsrIDogaTIrK107XG4gICAgICAgIHRbaTErK10gPSB7IHM6IC0xLCBmOiBsLmYgKyByLmYsIGw6IGwsIHI6IHIgfTtcbiAgICB9XG4gICAgdmFyIG1heFN5bSA9IHQyWzBdLnM7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgaWYgKHQyW2ldLnMgPiBtYXhTeW0pXG4gICAgICAgICAgICBtYXhTeW0gPSB0MltpXS5zO1xuICAgIH1cbiAgICAvLyBjb2RlIGxlbmd0aHNcbiAgICB2YXIgdHIgPSBuZXcgdTE2KG1heFN5bSArIDEpO1xuICAgIC8vIG1heCBiaXRzIGluIHRyZWVcbiAgICB2YXIgbWJ0ID0gbG4odFtpMSAtIDFdLCB0ciwgMCk7XG4gICAgaWYgKG1idCA+IG1iKSB7XG4gICAgICAgIC8vIG1vcmUgYWxnb3JpdGhtcyBmcm9tIFVaSVAuanNcbiAgICAgICAgLy8gVE9ETzogZmluZCBvdXQgaG93IHRoaXMgY29kZSB3b3JrcyAoZGVidClcbiAgICAgICAgLy8gIGluZCAgICBkZWJ0XG4gICAgICAgIHZhciBpID0gMCwgZHQgPSAwO1xuICAgICAgICAvLyAgICBsZWZ0ICAgICAgICAgICAgY29zdFxuICAgICAgICB2YXIgbGZ0ID0gbWJ0IC0gbWIsIGNzdCA9IDEgPDwgbGZ0O1xuICAgICAgICB0Mi5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiB0cltiLnNdIC0gdHJbYS5zXSB8fCBhLmYgLSBiLmY7IH0pO1xuICAgICAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgdmFyIGkyXzEgPSB0MltpXS5zO1xuICAgICAgICAgICAgaWYgKHRyW2kyXzFdID4gbWIpIHtcbiAgICAgICAgICAgICAgICBkdCArPSBjc3QgLSAoMSA8PCAobWJ0IC0gdHJbaTJfMV0pKTtcbiAgICAgICAgICAgICAgICB0cltpMl8xXSA9IG1iO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGR0ID4+Pj0gbGZ0O1xuICAgICAgICB3aGlsZSAoZHQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgaTJfMiA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfMl0gPCBtYilcbiAgICAgICAgICAgICAgICBkdCAtPSAxIDw8IChtYiAtIHRyW2kyXzJdKysgLSAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPj0gMCAmJiBkdDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgaTJfMyA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfM10gPT0gbWIpIHtcbiAgICAgICAgICAgICAgICAtLXRyW2kyXzNdO1xuICAgICAgICAgICAgICAgICsrZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWJ0ID0gbWI7XG4gICAgfVxuICAgIHJldHVybiBbbmV3IHU4KHRyKSwgbWJ0XTtcbn07XG4vLyBnZXQgdGhlIG1heCBsZW5ndGggYW5kIGFzc2lnbiBsZW5ndGggY29kZXNcbnZhciBsbiA9IGZ1bmN0aW9uIChuLCBsLCBkKSB7XG4gICAgcmV0dXJuIG4ucyA9PSAtMVxuICAgICAgICA/IE1hdGgubWF4KGxuKG4ubCwgbCwgZCArIDEpLCBsbihuLnIsIGwsIGQgKyAxKSlcbiAgICAgICAgOiAobFtuLnNdID0gZCk7XG59O1xuLy8gbGVuZ3RoIGNvZGVzIGdlbmVyYXRpb25cbnZhciBsYyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHMgPSBjLmxlbmd0aDtcbiAgICAvLyBOb3RlIHRoYXQgdGhlIHNlbWljb2xvbiB3YXMgaW50ZW50aW9uYWxcbiAgICB3aGlsZSAocyAmJiAhY1stLXNdKVxuICAgICAgICA7XG4gICAgdmFyIGNsID0gbmV3IHUxNigrK3MpO1xuICAgIC8vICBpbmQgICAgICBudW0gICAgICAgICBzdHJlYWtcbiAgICB2YXIgY2xpID0gMCwgY2xuID0gY1swXSwgY2xzID0gMTtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uICh2KSB7IGNsW2NsaSsrXSA9IHY7IH07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gczsgKytpKSB7XG4gICAgICAgIGlmIChjW2ldID09IGNsbiAmJiBpICE9IHMpXG4gICAgICAgICAgICArK2NscztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNsbiAmJiBjbHMgPiAyKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGNscyA+IDEzODsgY2xzIC09IDEzOClcbiAgICAgICAgICAgICAgICAgICAgdygzMjc1NCk7XG4gICAgICAgICAgICAgICAgaWYgKGNscyA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdyhjbHMgPiAxMCA/ICgoY2xzIC0gMTEpIDw8IDUpIHwgMjg2OTAgOiAoKGNscyAtIDMpIDw8IDUpIHwgMTIzMDUpO1xuICAgICAgICAgICAgICAgICAgICBjbHMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNscyA+IDMpIHtcbiAgICAgICAgICAgICAgICB3KGNsbiksIC0tY2xzO1xuICAgICAgICAgICAgICAgIGZvciAoOyBjbHMgPiA2OyBjbHMgLT0gNilcbiAgICAgICAgICAgICAgICAgICAgdyg4MzA0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzID4gMilcbiAgICAgICAgICAgICAgICAgICAgdygoKGNscyAtIDMpIDw8IDUpIHwgODIwOCksIGNscyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2xzLS0pXG4gICAgICAgICAgICAgICAgdyhjbG4pO1xuICAgICAgICAgICAgY2xzID0gMTtcbiAgICAgICAgICAgIGNsbiA9IGNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtjbC5zdWJhcnJheSgwLCBjbGkpLCBzXTtcbn07XG4vLyBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiBvdXRwdXQgZnJvbSB0cmVlLCBjb2RlIGxlbmd0aHNcbnZhciBjbGVuID0gZnVuY3Rpb24gKGNmLCBjbCkge1xuICAgIHZhciBsID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsLmxlbmd0aDsgKytpKVxuICAgICAgICBsICs9IGNmW2ldICogY2xbaV07XG4gICAgcmV0dXJuIGw7XG59O1xuLy8gd3JpdGVzIGEgZml4ZWQgYmxvY2tcbi8vIHJldHVybnMgdGhlIG5ldyBiaXQgcG9zXG52YXIgd2ZibGsgPSBmdW5jdGlvbiAob3V0LCBwb3MsIGRhdCkge1xuICAgIC8vIG5vIG5lZWQgdG8gd3JpdGUgMDAgYXMgdHlwZTogVHlwZWRBcnJheSBkZWZhdWx0cyB0byAwXG4gICAgdmFyIHMgPSBkYXQubGVuZ3RoO1xuICAgIHZhciBvID0gc2hmdChwb3MgKyAyKTtcbiAgICBvdXRbb10gPSBzICYgMjU1O1xuICAgIG91dFtvICsgMV0gPSBzID4+PiA4O1xuICAgIG91dFtvICsgMl0gPSBvdXRbb10gXiAyNTU7XG4gICAgb3V0W28gKyAzXSA9IG91dFtvICsgMV0gXiAyNTU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyArK2kpXG4gICAgICAgIG91dFtvICsgaSArIDRdID0gZGF0W2ldO1xuICAgIHJldHVybiAobyArIDQgKyBzKSAqIDg7XG59O1xuLy8gd3JpdGVzIGEgYmxvY2tcbnZhciB3YmxrID0gZnVuY3Rpb24gKGRhdCwgb3V0LCBmaW5hbCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBibCwgcCkge1xuICAgIHdiaXRzKG91dCwgcCsrLCBmaW5hbCk7XG4gICAgKytsZlsyNTZdO1xuICAgIHZhciBfYSA9IGhUcmVlKGxmLCAxNSksIGRsdCA9IF9hWzBdLCBtbGIgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSBoVHJlZShkZiwgMTUpLCBkZHQgPSBfYlswXSwgbWRiID0gX2JbMV07XG4gICAgdmFyIF9jID0gbGMoZGx0KSwgbGNsdCA9IF9jWzBdLCBubGMgPSBfY1sxXTtcbiAgICB2YXIgX2QgPSBsYyhkZHQpLCBsY2R0ID0gX2RbMF0sIG5kYyA9IF9kWzFdO1xuICAgIHZhciBsY2ZyZXEgPSBuZXcgdTE2KDE5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxjbHQubGVuZ3RoOyArK2kpXG4gICAgICAgIGxjZnJlcVtsY2x0W2ldICYgMzFdKys7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsY2R0Lmxlbmd0aDsgKytpKVxuICAgICAgICBsY2ZyZXFbbGNkdFtpXSAmIDMxXSsrO1xuICAgIHZhciBfZSA9IGhUcmVlKGxjZnJlcSwgNyksIGxjdCA9IF9lWzBdLCBtbGNiID0gX2VbMV07XG4gICAgdmFyIG5sY2MgPSAxOTtcbiAgICBmb3IgKDsgbmxjYyA+IDQgJiYgIWxjdFtjbGltW25sY2MgLSAxXV07IC0tbmxjYylcbiAgICAgICAgO1xuICAgIHZhciBmbGVuID0gKGJsICsgNSkgPDwgMztcbiAgICB2YXIgZnRsZW4gPSBjbGVuKGxmLCBmbHQpICsgY2xlbihkZiwgZmR0KSArIGViO1xuICAgIHZhciBkdGxlbiA9IGNsZW4obGYsIGRsdCkgKyBjbGVuKGRmLCBkZHQpICsgZWIgKyAxNCArIDMgKiBubGNjICsgY2xlbihsY2ZyZXEsIGxjdCkgKyAoMiAqIGxjZnJlcVsxNl0gKyAzICogbGNmcmVxWzE3XSArIDcgKiBsY2ZyZXFbMThdKTtcbiAgICBpZiAoZmxlbiA8PSBmdGxlbiAmJiBmbGVuIDw9IGR0bGVuKVxuICAgICAgICByZXR1cm4gd2ZibGsob3V0LCBwLCBkYXQuc3ViYXJyYXkoYnMsIGJzICsgYmwpKTtcbiAgICB2YXIgbG0sIGxsLCBkbSwgZGw7XG4gICAgd2JpdHMob3V0LCBwLCAxICsgKGR0bGVuIDwgZnRsZW4pKSwgcCArPSAyO1xuICAgIGlmIChkdGxlbiA8IGZ0bGVuKSB7XG4gICAgICAgIGxtID0gaE1hcChkbHQsIG1sYiwgMCksIGxsID0gZGx0LCBkbSA9IGhNYXAoZGR0LCBtZGIsIDApLCBkbCA9IGRkdDtcbiAgICAgICAgdmFyIGxsbSA9IGhNYXAobGN0LCBtbGNiLCAwKTtcbiAgICAgICAgd2JpdHMob3V0LCBwLCBubGMgLSAyNTcpO1xuICAgICAgICB3Yml0cyhvdXQsIHAgKyA1LCBuZGMgLSAxKTtcbiAgICAgICAgd2JpdHMob3V0LCBwICsgMTAsIG5sY2MgLSA0KTtcbiAgICAgICAgcCArPSAxNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBubGNjOyArK2kpXG4gICAgICAgICAgICB3Yml0cyhvdXQsIHAgKyAzICogaSwgbGN0W2NsaW1baV1dKTtcbiAgICAgICAgcCArPSAzICogbmxjYztcbiAgICAgICAgdmFyIGxjdHMgPSBbbGNsdCwgbGNkdF07XG4gICAgICAgIGZvciAodmFyIGl0ID0gMDsgaXQgPCAyOyArK2l0KSB7XG4gICAgICAgICAgICB2YXIgY2xjdCA9IGxjdHNbaXRdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGNsY3RbaV0gJiAzMTtcbiAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIGxsbVtsZW5dKSwgcCArPSBsY3RbbGVuXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMTUpXG4gICAgICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgKGNsY3RbaV0gPj4+IDUpICYgMTI3KSwgcCArPSBjbGN0W2ldID4+PiAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG0gPSBmbG0sIGxsID0gZmx0LCBkbSA9IGZkbSwgZGwgPSBmZHQ7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGk7ICsraSkge1xuICAgICAgICBpZiAoc3ltc1tpXSA+IDI1NSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IChzeW1zW2ldID4+PiAxOCkgJiAzMTtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBsbVtsZW4gKyAyNTddKSwgcCArPSBsbFtsZW4gKyAyNTddO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDcpXG4gICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCAoc3ltc1tpXSA+Pj4gMjMpICYgMzEpLCBwICs9IGZsZWJbbGVuXTtcbiAgICAgICAgICAgIHZhciBkc3QgPSBzeW1zW2ldICYgMzE7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgZG1bZHN0XSksIHAgKz0gZGxbZHN0XTtcbiAgICAgICAgICAgIGlmIChkc3QgPiAzKVxuICAgICAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCAoc3ltc1tpXSA+Pj4gNSkgJiA4MTkxKSwgcCArPSBmZGViW2RzdF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgbG1bc3ltc1tpXV0pLCBwICs9IGxsW3N5bXNbaV1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdiaXRzMTYob3V0LCBwLCBsbVsyNTZdKTtcbiAgICByZXR1cm4gcCArIGxsWzI1Nl07XG59O1xuLy8gZGVmbGF0ZSBvcHRpb25zIChuaWNlIDw8IDEzKSB8IGNoYWluXG52YXIgZGVvID0gLyojX19QVVJFX18qLyBuZXcgdTMyKFs2NTU0MCwgMTMxMDgwLCAxMzEwODgsIDEzMTEwNCwgMjYyMTc2LCAxMDQ4NzA0LCAxMDQ4ODMyLCAyMTE0NTYwLCAyMTE3NjMyXSk7XG4vLyBlbXB0eVxudmFyIGV0ID0gLyojX19QVVJFX18qLyBuZXcgdTgoMCk7XG4vLyBjb21wcmVzc2VzIGRhdGEgaW50byBhIHJhdyBERUZMQVRFIGJ1ZmZlclxudmFyIGRmbHQgPSBmdW5jdGlvbiAoZGF0LCBsdmwsIHBsdmwsIHByZSwgcG9zdCwgbHN0KSB7XG4gICAgdmFyIHMgPSBkYXQubGVuZ3RoO1xuICAgIHZhciBvID0gbmV3IHU4KHByZSArIHMgKyA1ICogKDEgKyBNYXRoLmNlaWwocyAvIDcwMDApKSArIHBvc3QpO1xuICAgIC8vIHdyaXRpbmcgdG8gdGhpcyB3cml0ZXMgdG8gdGhlIG91dHB1dCBidWZmZXJcbiAgICB2YXIgdyA9IG8uc3ViYXJyYXkocHJlLCBvLmxlbmd0aCAtIHBvc3QpO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIGlmICghbHZsIHx8IHMgPCA4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHM7IGkgKz0gNjU1MzUpIHtcbiAgICAgICAgICAgIC8vIGVuZFxuICAgICAgICAgICAgdmFyIGUgPSBpICsgNjU1MzU7XG4gICAgICAgICAgICBpZiAoZSA8IHMpIHtcbiAgICAgICAgICAgICAgICAvLyB3cml0ZSBmdWxsIGJsb2NrXG4gICAgICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zLCBkYXQuc3ViYXJyYXkoaSwgZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd3JpdGUgZmluYWwgYmxvY2tcbiAgICAgICAgICAgICAgICB3W2ldID0gbHN0O1xuICAgICAgICAgICAgICAgIHBvcyA9IHdmYmxrKHcsIHBvcywgZGF0LnN1YmFycmF5KGksIHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9wdCA9IGRlb1tsdmwgLSAxXTtcbiAgICAgICAgdmFyIG4gPSBvcHQgPj4+IDEzLCBjID0gb3B0ICYgODE5MTtcbiAgICAgICAgdmFyIG1za18xID0gKDEgPDwgcGx2bCkgLSAxO1xuICAgICAgICAvLyAgICBwcmV2IDItYnl0ZSB2YWwgbWFwICAgIGN1cnIgMi1ieXRlIHZhbCBtYXBcbiAgICAgICAgdmFyIHByZXYgPSBuZXcgdTE2KDMyNzY4KSwgaGVhZCA9IG5ldyB1MTYobXNrXzEgKyAxKTtcbiAgICAgICAgdmFyIGJzMV8xID0gTWF0aC5jZWlsKHBsdmwgLyAzKSwgYnMyXzEgPSAyICogYnMxXzE7XG4gICAgICAgIHZhciBoc2ggPSBmdW5jdGlvbiAoaSkgeyByZXR1cm4gKGRhdFtpXSBeIChkYXRbaSArIDFdIDw8IGJzMV8xKSBeIChkYXRbaSArIDJdIDw8IGJzMl8xKSkgJiBtc2tfMTsgfTtcbiAgICAgICAgLy8gMjQ1NzYgaXMgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBtYXhpbXVtIHN5bWJvbHMgcGVyIGJsb2NrXG4gICAgICAgIC8vIDQyNCBidWZmZXIgZm9yIGxhc3QgYmxvY2tcbiAgICAgICAgdmFyIHN5bXMgPSBuZXcgdTMyKDI1MDAwKTtcbiAgICAgICAgLy8gbGVuZ3RoL2xpdGVyYWwgZnJlcSAgIGRpc3RhbmNlIGZyZXFcbiAgICAgICAgdmFyIGxmID0gbmV3IHUxNigyODgpLCBkZiA9IG5ldyB1MTYoMzIpO1xuICAgICAgICAvLyAgbC9sY250ICBleGJpdHMgIGluZGV4ICBsL2xpbmQgIHdhaXRkeCAgYml0cG9zXG4gICAgICAgIHZhciBsY18xID0gMCwgZWIgPSAwLCBpID0gMCwgbGkgPSAwLCB3aSA9IDAsIGJzID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGhhc2ggdmFsdWVcbiAgICAgICAgICAgIC8vIGRlb3B0IHdoZW4gaSA+IHMgLSAzIC0gYXQgZW5kLCBkZW9wdCBhY2NlcHRhYmxlXG4gICAgICAgICAgICB2YXIgaHYgPSBoc2goaSk7XG4gICAgICAgICAgICAvLyBpbmRleCBtb2QgMzI3NjggICAgcHJldmlvdXMgaW5kZXggbW9kXG4gICAgICAgICAgICB2YXIgaW1vZCA9IGkgJiAzMjc2NywgcGltb2QgPSBoZWFkW2h2XTtcbiAgICAgICAgICAgIHByZXZbaW1vZF0gPSBwaW1vZDtcbiAgICAgICAgICAgIGhlYWRbaHZdID0gaW1vZDtcbiAgICAgICAgICAgIC8vIFdlIGFsd2F5cyBzaG91bGQgbW9kaWZ5IGhlYWQgYW5kIHByZXYsIGJ1dCBvbmx5IGFkZCBzeW1ib2xzIGlmXG4gICAgICAgICAgICAvLyB0aGlzIGRhdGEgaXMgbm90IHlldCBwcm9jZXNzZWQgKFwid2FpdFwiIGZvciB3YWl0IGluZGV4KVxuICAgICAgICAgICAgaWYgKHdpIDw9IGkpIHtcbiAgICAgICAgICAgICAgICAvLyBieXRlcyByZW1haW5pbmdcbiAgICAgICAgICAgICAgICB2YXIgcmVtID0gcyAtIGk7XG4gICAgICAgICAgICAgICAgaWYgKChsY18xID4gNzAwMCB8fCBsaSA+IDI0NTc2KSAmJiByZW0gPiA0MjMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gd2JsayhkYXQsIHcsIDAsIHN5bXMsIGxmLCBkZiwgZWIsIGxpLCBicywgaSAtIGJzLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICBsaSA9IGxjXzEgPSBlYiA9IDAsIGJzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyODY7ICsrailcbiAgICAgICAgICAgICAgICAgICAgICAgIGxmW2pdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzMDsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGZbal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgbGVuICAgIGRpc3QgICBjaGFpblxuICAgICAgICAgICAgICAgIHZhciBsID0gMiwgZCA9IDAsIGNoXzEgPSBjLCBkaWYgPSAoaW1vZCAtIHBpbW9kKSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgIGlmIChyZW0gPiAyICYmIGh2ID09IGhzaChpIC0gZGlmKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4biA9IE1hdGgubWluKG4sIHJlbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ZCA9IE1hdGgubWluKDMyNzY3LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF4IHBvc3NpYmxlIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgY2FwcGVkIGF0IGRpZiBiZWNhdXNlIGRlY29tcHJlc3NvcnMgaW1wbGVtZW50IFwicm9sbGluZ1wiIGluZGV4IHBvcHVsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1sID0gTWF0aC5taW4oMjU4LCByZW0pO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGlmIDw9IG1heGQgJiYgLS1jaF8xICYmIGltb2QgIT0gcGltb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRbaSArIGxdID09IGRhdFtpICsgbCAtIGRpZl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBubCA8IG1sICYmIGRhdFtpICsgbmxdID09IGRhdFtpICsgbmwgLSBkaWZdOyArK25sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5sID4gbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gbmwsIGQgPSBkaWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyZWFrIG91dCBlYXJseSB3aGVuIHdlIHJlYWNoIFwibmljZVwiICh3ZSBhcmUgc2F0aXNmaWVkIGVub3VnaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5sID4gbWF4bilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3csIGZpbmQgdGhlIHJhcmVzdCAyLWJ5dGUgc2VxdWVuY2Ugd2l0aGluIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxpdGVyYWxzIGFuZCBzZWFyY2ggZm9yIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVjaCBmYXN0ZXIgdGhhbiBqdXN0IHVzaW5nIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW1kID0gTWF0aC5taW4oZGlmLCBubCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1tZDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGkgPSAoaSAtIGRpZiArIGogKyAzMjc2OCkgJiAzMjc2NztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdGkgPSBwcmV2W3RpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZCA9ICh0aSAtIHB0aSArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNkID4gbWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWQgPSBjZCwgcGltb2QgPSB0aTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBwcmV2aW91cyBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1vZCA9IHBpbW9kLCBwaW1vZCA9IHByZXZbaW1vZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWYgKz0gKGltb2QgLSBwaW1vZCArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGQgd2lsbCBiZSBub256ZXJvIG9ubHkgd2hlbiBhIG1hdGNoIHdhcyBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGJvdGggZGlzdCBhbmQgbGVuIGRhdGEgaW4gb25lIFVpbnQzMlxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhpcyBpcyByZWNvZ25pemVkIGFzIGEgbGVuL2Rpc3Qgd2l0aCAyOHRoIGJpdCAoMl4yOClcbiAgICAgICAgICAgICAgICAgICAgc3ltc1tsaSsrXSA9IDI2ODQzNTQ1NiB8IChyZXZmbFtsXSA8PCAxOCkgfCByZXZmZFtkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbiA9IHJldmZsW2xdICYgMzEsIGRpbiA9IHJldmZkW2RdICYgMzE7XG4gICAgICAgICAgICAgICAgICAgIGViICs9IGZsZWJbbGluXSArIGZkZWJbZGluXTtcbiAgICAgICAgICAgICAgICAgICAgKytsZlsyNTcgKyBsaW5dO1xuICAgICAgICAgICAgICAgICAgICArK2RmW2Rpbl07XG4gICAgICAgICAgICAgICAgICAgIHdpID0gaSArIGw7XG4gICAgICAgICAgICAgICAgICAgICsrbGNfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bXNbbGkrK10gPSBkYXRbaV07XG4gICAgICAgICAgICAgICAgICAgICsrbGZbZGF0W2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gd2JsayhkYXQsIHcsIGxzdCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBpIC0gYnMsIHBvcyk7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVhc2llc3Qgd2F5IHRvIGF2b2lkIG5lZWRpbmcgdG8gbWFpbnRhaW4gc3RhdGVcbiAgICAgICAgaWYgKCFsc3QgJiYgcG9zICYgNylcbiAgICAgICAgICAgIHBvcyA9IHdmYmxrKHcsIHBvcyArIDEsIGV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNsYyhvLCAwLCBwcmUgKyBzaGZ0KHBvcykgKyBwb3N0KTtcbn07XG4vLyBDUkMzMiB0YWJsZVxudmFyIGNyY3QgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHQgPSBuZXcgSW50MzJBcnJheSgyNTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBpLCBrID0gOTtcbiAgICAgICAgd2hpbGUgKC0taylcbiAgICAgICAgICAgIGMgPSAoKGMgJiAxKSAmJiAtMzA2Njc0OTEyKSBeIChjID4+PiAxKTtcbiAgICAgICAgdFtpXSA9IGM7XG4gICAgfVxuICAgIHJldHVybiB0O1xufSkoKTtcbi8vIENSQzMyXG52YXIgY3JjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjID0gLTE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcDogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIC8vIGNsb3N1cmVzIGhhdmUgYXdmdWwgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIHZhciBjciA9IGM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY3IgPSBjcmN0WyhjciAmIDI1NSkgXiBkW2ldXSBeIChjciA+Pj4gOCk7XG4gICAgICAgICAgICBjID0gY3I7XG4gICAgICAgIH0sXG4gICAgICAgIGQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIH5jOyB9XG4gICAgfTtcbn07XG4vLyBBbGRlcjMyXG52YXIgYWRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSAxLCBiID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgLy8gY2xvc3VyZXMgaGF2ZSBhd2Z1bCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgdmFyIG4gPSBhLCBtID0gYjtcbiAgICAgICAgICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPSBsOykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gTWF0aC5taW4oaSArIDI2NTUsIGwpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZTsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtICs9IG4gKz0gZFtpXTtcbiAgICAgICAgICAgICAgICBuID0gKG4gJiA2NTUzNSkgKyAxNSAqIChuID4+IDE2KSwgbSA9IChtICYgNjU1MzUpICsgMTUgKiAobSA+PiAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gbiwgYiA9IG07XG4gICAgICAgIH0sXG4gICAgICAgIGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGEgJT0gNjU1MjEsIGIgJT0gNjU1MjE7XG4gICAgICAgICAgICByZXR1cm4gKGEgJiAyNTUpIDw8IDI0IHwgKGEgPj4+IDgpIDw8IDE2IHwgKGIgJiAyNTUpIDw8IDggfCAoYiA+Pj4gOCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbjtcbi8vIGRlZmxhdGUgd2l0aCBvcHRzXG52YXIgZG9wdCA9IGZ1bmN0aW9uIChkYXQsIG9wdCwgcHJlLCBwb3N0LCBzdCkge1xuICAgIHJldHVybiBkZmx0KGRhdCwgb3B0LmxldmVsID09IG51bGwgPyA2IDogb3B0LmxldmVsLCBvcHQubWVtID09IG51bGwgPyBNYXRoLmNlaWwoTWF0aC5tYXgoOCwgTWF0aC5taW4oMTMsIE1hdGgubG9nKGRhdC5sZW5ndGgpKSkgKiAxLjUpIDogKDEyICsgb3B0Lm1lbSksIHByZSwgcG9zdCwgIXN0KTtcbn07XG4vLyBXYWxtYXJ0IG9iamVjdCBzcHJlYWRcbnZhciBtcmcgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBvID0ge307XG4gICAgZm9yICh2YXIgayBpbiBhKVxuICAgICAgICBvW2tdID0gYVtrXTtcbiAgICBmb3IgKHZhciBrIGluIGIpXG4gICAgICAgIG9ba10gPSBiW2tdO1xuICAgIHJldHVybiBvO1xufTtcbi8vIHdvcmtlciBjbG9uZVxuLy8gVGhpcyBpcyBwb3NzaWJseSB0aGUgY3Jhemllc3QgcGFydCBvZiB0aGUgZW50aXJlIGNvZGViYXNlLCBkZXNwaXRlIGhvdyBzaW1wbGUgaXQgbWF5IHNlZW0uXG4vLyBUaGUgb25seSBwYXJhbWV0ZXIgdG8gdGhpcyBmdW5jdGlvbiBpcyBhIGNsb3N1cmUgdGhhdCByZXR1cm5zIGFuIGFycmF5IG9mIHZhcmlhYmxlcyBvdXRzaWRlIG9mIHRoZSBmdW5jdGlvbiBzY29wZS5cbi8vIFdlJ3JlIGdvaW5nIHRvIHRyeSB0byBmaWd1cmUgb3V0IHRoZSB2YXJpYWJsZSBuYW1lcyB1c2VkIGluIHRoZSBjbG9zdXJlIGFzIHN0cmluZ3MgYmVjYXVzZSB0aGF0IGlzIGNydWNpYWwgZm9yIHdvcmtlcml6YXRpb24uXG4vLyBXZSB3aWxsIHJldHVybiBhbiBvYmplY3QgbWFwcGluZyBvZiB0cnVlIHZhcmlhYmxlIG5hbWUgdG8gdmFsdWUgKGJhc2ljYWxseSwgdGhlIGN1cnJlbnQgc2NvcGUgYXMgYSBKUyBvYmplY3QpLlxuLy8gVGhlIHJlYXNvbiB3ZSBjYW4ndCBqdXN0IHVzZSB0aGUgb3JpZ2luYWwgdmFyaWFibGUgbmFtZXMgaXMgbWluaWZpZXJzIG1hbmdsaW5nIHRoZSB0b3BsZXZlbCBzY29wZS5cbi8vIFRoaXMgdG9vayBtZSB0aHJlZSB3ZWVrcyB0byBmaWd1cmUgb3V0IGhvdyB0byBkby5cbnZhciB3Y2xuID0gZnVuY3Rpb24gKGZuLCBmblN0ciwgdGQpIHtcbiAgICB2YXIgZHQgPSBmbigpO1xuICAgIHZhciBzdCA9IGZuLnRvU3RyaW5nKCk7XG4gICAgdmFyIGtzID0gc3Quc2xpY2Uoc3QuaW5kZXhPZignWycpICsgMSwgc3QubGFzdEluZGV4T2YoJ10nKSkucmVwbGFjZSgvIC9nLCAnJykuc3BsaXQoJywnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB2ID0gZHRbaV0sIGsgPSBrc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGZuU3RyICs9ICc7JyArIGsgKyAnPSc7XG4gICAgICAgICAgICB2YXIgc3RfMSA9IHYudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh2LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGZvciBnbG9iYWwgb2JqZWN0c1xuICAgICAgICAgICAgICAgIGlmIChzdF8xLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BJbmQgPSBzdF8xLmluZGV4T2YoJyAnLCA4KSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGZuU3RyICs9IHN0XzEuc2xpY2Uoc3BJbmQsIHN0XzEuaW5kZXhPZignKCcsIHNwSW5kKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmblN0ciArPSBzdF8xO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0IGluIHYucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm5TdHIgKz0gJzsnICsgayArICcucHJvdG90eXBlLicgKyB0ICsgJz0nICsgdi5wcm90b3R5cGVbdF0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm5TdHIgKz0gc3RfMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ZFtrXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBbZm5TdHIsIHRkXTtcbn07XG52YXIgY2ggPSBbXTtcbi8vIGNsb25lIGJ1ZnNcbnZhciBjYmZzID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgdGwgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIHYpIHtcbiAgICAgICAgaWYgKHZba10gaW5zdGFuY2VvZiB1OCB8fCB2W2tdIGluc3RhbmNlb2YgdTE2IHx8IHZba10gaW5zdGFuY2VvZiB1MzIpXG4gICAgICAgICAgICB0bC5wdXNoKCh2W2tdID0gbmV3IHZba10uY29uc3RydWN0b3IodltrXSkpLmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiB0bDtcbn07XG4vLyB1c2UgYSB3b3JrZXIgdG8gZXhlY3V0ZSBjb2RlXG52YXIgd3JrciA9IGZ1bmN0aW9uIChmbnMsIGluaXQsIGlkLCBjYikge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWNoW2lkXSkge1xuICAgICAgICB2YXIgZm5TdHIgPSAnJywgdGRfMSA9IHt9LCBtID0gZm5zLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbTsgKytpKVxuICAgICAgICAgICAgX2EgPSB3Y2xuKGZuc1tpXSwgZm5TdHIsIHRkXzEpLCBmblN0ciA9IF9hWzBdLCB0ZF8xID0gX2FbMV07XG4gICAgICAgIGNoW2lkXSA9IHdjbG4oZm5zW21dLCBmblN0ciwgdGRfMSk7XG4gICAgfVxuICAgIHZhciB0ZCA9IG1yZyh7fSwgY2hbaWRdWzFdKTtcbiAgICByZXR1cm4gd2soY2hbaWRdWzBdICsgJztvbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7Zm9yKHZhciBrIGluIGUuZGF0YSlzZWxmW2tdPWUuZGF0YVtrXTtvbm1lc3NhZ2U9JyArIGluaXQudG9TdHJpbmcoKSArICd9JywgaWQsIHRkLCBjYmZzKHRkKSwgY2IpO1xufTtcbi8vIGJhc2UgYXN5bmMgaW5mbGF0ZSBmblxudmFyIGJJbmZsdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt1OCwgdTE2LCB1MzIsIGZsZWIsIGZkZWIsIGNsaW0sIGZsLCBmZCwgZmxybSwgZmRybSwgcmV2LCBoTWFwLCBtYXgsIGJpdHMsIGJpdHMxNiwgc2hmdCwgc2xjLCBpbmZsdCwgaW5mbGF0ZVN5bmMsIHBiZiwgZ3U4XTsgfTtcbnZhciBiRGZsdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt1OCwgdTE2LCB1MzIsIGZsZWIsIGZkZWIsIGNsaW0sIHJldmZsLCByZXZmZCwgZmxtLCBmbHQsIGZkbSwgZmR0LCByZXYsIGRlbywgZXQsIGhNYXAsIHdiaXRzLCB3Yml0czE2LCBoVHJlZSwgbG4sIGxjLCBjbGVuLCB3ZmJsaywgd2Jsaywgc2hmdCwgc2xjLCBkZmx0LCBkb3B0LCBkZWZsYXRlU3luYywgcGJmXTsgfTtcbi8vIGd6aXAgZXh0cmFcbnZhciBnemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3poLCBnemhsLCB3Ynl0ZXMsIGNyYywgY3JjdF07IH07XG4vLyBndW56aXAgZXh0cmFcbnZhciBndXplID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW2d6cywgZ3psXTsgfTtcbi8vIHpsaWIgZXh0cmFcbnZhciB6bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbemxoLCB3Ynl0ZXMsIGFkbGVyXTsgfTtcbi8vIHVuemxpYiBleHRyYVxudmFyIHp1bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbemx2XTsgfTtcbi8vIHBvc3QgYnVmXG52YXIgcGJmID0gZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gcG9zdE1lc3NhZ2UobXNnLCBbbXNnLmJ1ZmZlcl0pOyB9O1xuLy8gZ2V0IHU4XG52YXIgZ3U4ID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgby5zaXplICYmIG5ldyB1OChvLnNpemUpOyB9O1xuLy8gYXN5bmMgaGVscGVyXG52YXIgY2JpZnkgPSBmdW5jdGlvbiAoZGF0LCBvcHRzLCBmbnMsIGluaXQsIGlkLCBjYikge1xuICAgIHZhciB3ID0gd3JrcihmbnMsIGluaXQsIGlkLCBmdW5jdGlvbiAoZXJyLCBkYXQpIHtcbiAgICAgICAgdy50ZXJtaW5hdGUoKTtcbiAgICAgICAgY2IoZXJyLCBkYXQpO1xuICAgIH0pO1xuICAgIHcucG9zdE1lc3NhZ2UoW2RhdCwgb3B0c10sIG9wdHMuY29uc3VtZSA/IFtkYXQuYnVmZmVyXSA6IFtdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB3LnRlcm1pbmF0ZSgpOyB9O1xufTtcbi8vIGF1dG8gc3RyZWFtXG52YXIgYXN0cm0gPSBmdW5jdGlvbiAoc3RybSkge1xuICAgIHN0cm0ub25kYXRhID0gZnVuY3Rpb24gKGRhdCwgZmluYWwpIHsgcmV0dXJuIHBvc3RNZXNzYWdlKFtkYXQsIGZpbmFsXSwgW2RhdC5idWZmZXJdKTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2KSB7IHJldHVybiBzdHJtLnB1c2goZXYuZGF0YVswXSwgZXYuZGF0YVsxXSk7IH07XG59O1xuLy8gYXN5bmMgc3RyZWFtIGF0dGFjaFxudmFyIGFzdHJtaWZ5ID0gZnVuY3Rpb24gKGZucywgc3RybSwgb3B0cywgaW5pdCwgaWQpIHtcbiAgICB2YXIgdDtcbiAgICB2YXIgdyA9IHdya3IoZm5zLCBpbml0LCBpZCwgZnVuY3Rpb24gKGVyciwgZGF0KSB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICB3LnRlcm1pbmF0ZSgpLCBzdHJtLm9uZGF0YS5jYWxsKHN0cm0sIGVycik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRhdFsxXSlcbiAgICAgICAgICAgICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgc3RybS5vbmRhdGEuY2FsbChzdHJtLCBlcnIsIGRhdFswXSwgZGF0WzFdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHcucG9zdE1lc3NhZ2Uob3B0cyk7XG4gICAgc3RybS5wdXNoID0gZnVuY3Rpb24gKGQsIGYpIHtcbiAgICAgICAgaWYgKHQpXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgaWYgKCFzdHJtLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBzdHJlYW0gaGFuZGxlcic7XG4gICAgICAgIHcucG9zdE1lc3NhZ2UoW2QsIHQgPSBmXSwgW2QuYnVmZmVyXSk7XG4gICAgfTtcbiAgICBzdHJtLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uICgpIHsgdy50ZXJtaW5hdGUoKTsgfTtcbn07XG4vLyByZWFkIDIgYnl0ZXNcbnZhciBiMiA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBkW2JdIHwgKGRbYiArIDFdIDw8IDgpOyB9O1xuLy8gcmVhZCA0IGJ5dGVzXG52YXIgYjQgPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gKGRbYl0gfCAoZFtiICsgMV0gPDwgOCkgfCAoZFtiICsgMl0gPDwgMTYpIHwgKGRbYiArIDNdIDw8IDI0KSkgPj4+IDA7IH07XG52YXIgYjggPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gYjQoZCwgYikgKyAoYjQoZCwgYiArIDQpICogNDI5NDk2NzI5Nik7IH07XG4vLyB3cml0ZSBieXRlc1xudmFyIHdieXRlcyA9IGZ1bmN0aW9uIChkLCBiLCB2KSB7XG4gICAgZm9yICg7IHY7ICsrYilcbiAgICAgICAgZFtiXSA9IHYsIHYgPj4+PSA4O1xufTtcbi8vIGd6aXAgaGVhZGVyXG52YXIgZ3poID0gZnVuY3Rpb24gKGMsIG8pIHtcbiAgICB2YXIgZm4gPSBvLmZpbGVuYW1lO1xuICAgIGNbMF0gPSAzMSwgY1sxXSA9IDEzOSwgY1syXSA9IDgsIGNbOF0gPSBvLmxldmVsIDwgMiA/IDQgOiBvLmxldmVsID09IDkgPyAyIDogMCwgY1s5XSA9IDM7IC8vIGFzc3VtZSBVbml4XG4gICAgaWYgKG8ubXRpbWUgIT0gMClcbiAgICAgICAgd2J5dGVzKGMsIDQsIE1hdGguZmxvb3IobmV3IERhdGUoby5tdGltZSB8fCBEYXRlLm5vdygpKSAvIDEwMDApKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgICAgY1szXSA9IDg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGZuLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgY1tpICsgMTBdID0gZm4uY2hhckNvZGVBdChpKTtcbiAgICB9XG59O1xuLy8gZ3ppcCBmb290ZXI6IC04IHRvIC00ID0gQ1JDLCAtNCB0byAtMCBpcyBsZW5ndGhcbi8vIGd6aXAgc3RhcnRcbnZhciBnenMgPSBmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkWzBdICE9IDMxIHx8IGRbMV0gIT0gMTM5IHx8IGRbMl0gIT0gOClcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgZ3ppcCBkYXRhJztcbiAgICB2YXIgZmxnID0gZFszXTtcbiAgICB2YXIgc3QgPSAxMDtcbiAgICBpZiAoZmxnICYgNClcbiAgICAgICAgc3QgKz0gZFsxMF0gfCAoZFsxMV0gPDwgOCkgKyAyO1xuICAgIGZvciAodmFyIHpzID0gKGZsZyA+PiAzICYgMSkgKyAoZmxnID4+IDQgJiAxKTsgenMgPiAwOyB6cyAtPSAhZFtzdCsrXSlcbiAgICAgICAgO1xuICAgIHJldHVybiBzdCArIChmbGcgJiAyKTtcbn07XG4vLyBnemlwIGxlbmd0aFxudmFyIGd6bCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgdmFyIGwgPSBkLmxlbmd0aDtcbiAgICByZXR1cm4gKChkW2wgLSA0XSB8IGRbbCAtIDNdIDw8IDggfCBkW2wgLSAyXSA8PCAxNikgfCAoZFtsIC0gMV0gPDwgMjQpKSA+Pj4gMDtcbn07XG4vLyBnemlwIGhlYWRlciBsZW5ndGhcbnZhciBnemhsID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIDEwICsgKChvLmZpbGVuYW1lICYmIChvLmZpbGVuYW1lLmxlbmd0aCArIDEpKSB8fCAwKTsgfTtcbi8vIHpsaWIgaGVhZGVyXG52YXIgemxoID0gZnVuY3Rpb24gKGMsIG8pIHtcbiAgICB2YXIgbHYgPSBvLmxldmVsLCBmbCA9IGx2ID09IDAgPyAwIDogbHYgPCA2ID8gMSA6IGx2ID09IDkgPyAzIDogMjtcbiAgICBjWzBdID0gMTIwLCBjWzFdID0gKGZsIDw8IDYpIHwgKGZsID8gKDMyIC0gMiAqIGZsKSA6IDEpO1xufTtcbi8vIHpsaWIgdmFsaWRcbnZhciB6bHYgPSBmdW5jdGlvbiAoZCkge1xuICAgIGlmICgoZFswXSAmIDE1KSAhPSA4IHx8IChkWzBdID4+PiA0KSA+IDcgfHwgKChkWzBdIDw8IDggfCBkWzFdKSAlIDMxKSlcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgemxpYiBkYXRhJztcbiAgICBpZiAoZFsxXSAmIDMyKVxuICAgICAgICB0aHJvdyAnaW52YWxpZCB6bGliIGRhdGE6IHByZXNldCBkaWN0aW9uYXJpZXMgbm90IHN1cHBvcnRlZCc7XG59O1xuZnVuY3Rpb24gQXN5bmNDbXBTdHJtKG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYiAmJiB0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIHJldHVybiBvcHRzO1xufVxuLy8gemxpYiBmb290ZXI6IC00IHRvIC0wIGlzIEFkbGVyMzJcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb25cbiAqL1xudmFyIERlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmbGF0ZShvcHRzLCBjYikge1xuICAgICAgICBpZiAoIWNiICYmIHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgdGhpcy5vID0gb3B0cyB8fCB7fTtcbiAgICB9XG4gICAgRGVmbGF0ZS5wcm90b3R5cGUucCA9IGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgIHRoaXMub25kYXRhKGRvcHQoYywgdGhpcy5vLCAwLCAwLCAhZiksIGYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIHN0cmVhbSBoYW5kbGVyJztcbiAgICAgICAgdGhpcy5kID0gZmluYWw7XG4gICAgICAgIHRoaXMucChjaHVuaywgZmluYWwgfHwgZmFsc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgRGVmbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY0RlZmxhdGUob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkRmbHQsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIERlZmxhdGVdOyB9XG4gICAgICAgIF0sIHRoaXMsIEFzeW5jQ21wU3RybS5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBEZWZsYXRlKGV2LmRhdGEpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDYpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNEZWZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jRGVmbGF0ZSB9O1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGUoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkRmbHQsXG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoZGVmbGF0ZVN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCAwLCBjYik7XG59XG4vKipcbiAqIENvbXByZXNzZXMgZGF0YSB3aXRoIERFRkxBVEUgd2l0aG91dCBhbnkgd3JhcHBlclxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZGVmbGF0ZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZVN5bmMoZGF0YSwgb3B0cykge1xuICAgIHJldHVybiBkb3B0KGRhdGEsIG9wdHMgfHwge30sIDAsIDApO1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5mbGF0aW9uIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGluZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5mbGF0ZShjYikge1xuICAgICAgICB0aGlzLnMgPSB7fTtcbiAgICAgICAgdGhpcy5wID0gbmV3IHU4KDApO1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIH1cbiAgICBJbmZsYXRlLnByb3RvdHlwZS5lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIHN0cmVhbSBoYW5kbGVyJztcbiAgICAgICAgdmFyIGwgPSB0aGlzLnAubGVuZ3RoO1xuICAgICAgICB2YXIgbiA9IG5ldyB1OChsICsgYy5sZW5ndGgpO1xuICAgICAgICBuLnNldCh0aGlzLnApLCBuLnNldChjLCBsKSwgdGhpcy5wID0gbjtcbiAgICB9O1xuICAgIEluZmxhdGUucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoZmluYWwpIHtcbiAgICAgICAgdGhpcy5kID0gdGhpcy5zLmkgPSBmaW5hbCB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGJ0cyA9IHRoaXMucy5iO1xuICAgICAgICB2YXIgZHQgPSBpbmZsdCh0aGlzLnAsIHRoaXMubywgdGhpcy5zKTtcbiAgICAgICAgdGhpcy5vbmRhdGEoc2xjKGR0LCBidHMsIHRoaXMucy5iKSwgdGhpcy5kKTtcbiAgICAgICAgdGhpcy5vID0gc2xjKGR0LCB0aGlzLnMuYiAtIDMyNzY4KSwgdGhpcy5zLmIgPSB0aGlzLm8ubGVuZ3RoO1xuICAgICAgICB0aGlzLnAgPSBzbGModGhpcy5wLCAodGhpcy5zLnAgLyA4KSB8IDApLCB0aGlzLnMucCAmPSA3O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgaW5mbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBmaW5hbCBjaHVua1xuICAgICAqL1xuICAgIEluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMuZShjaHVuayksIHRoaXMuYyhmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBJbmZsYXRlIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0luZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgaW5mbGF0aW9uIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGRlZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNJbmZsYXRlKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgSW5mbGF0ZV07IH1cbiAgICAgICAgXSwgdGhpcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgSW5mbGF0ZSgpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDcpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jSW5mbGF0ZSB9O1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGUoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoaW5mbGF0ZVN5bmMoZXYuZGF0YVswXSwgZ3U4KGV2LmRhdGFbMV0pKSk7IH0sIDEsIGNiKTtcbn1cbi8qKlxuICogRXhwYW5kcyBERUZMQVRFIGRhdGEgd2l0aCBubyB3cmFwcGVyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBTYXZlcyBtZW1vcnkgaWYgeW91IGtub3cgdGhlIGRlY29tcHJlc3NlZCBzaXplIGFuZCBwcm92aWRlIGFuIG91dHB1dCBidWZmZXIgb2YgdGhhdCBsZW5ndGguXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiBpbmZsdChkYXRhLCBvdXQpO1xufVxuLy8gYmVmb3JlIHlvdSB5ZWxsIGF0IG1lIGZvciBub3QganVzdCB1c2luZyBleHRlbmRzLCBteSByZWFzb24gaXMgdGhhdCBUUyBpbmhlcml0YW5jZSBpcyBoYXJkIHRvIHdvcmtlcml6ZS5cbi8qKlxuICogU3RyZWFtaW5nIEdaSVAgY29tcHJlc3Npb25cbiAqL1xudmFyIEd6aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3ppcChvcHRzLCBjYikge1xuICAgICAgICB0aGlzLmMgPSBjcmMoKTtcbiAgICAgICAgdGhpcy5sID0gMDtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgRGVmbGF0ZS5jYWxsKHRoaXMsIG9wdHMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgR1pJUHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBHemlwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIEd6aXAucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB0aGlzLmMucChjKTtcbiAgICAgICAgdGhpcy5sICs9IGMubGVuZ3RoO1xuICAgICAgICB2YXIgcmF3ID0gZG9wdChjLCB0aGlzLm8sIHRoaXMudiAmJiBnemhsKHRoaXMubyksIGYgJiYgOCwgIWYpO1xuICAgICAgICBpZiAodGhpcy52KVxuICAgICAgICAgICAgZ3poKHJhdywgdGhpcy5vKSwgdGhpcy52ID0gMDtcbiAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICB3Ynl0ZXMocmF3LCByYXcubGVuZ3RoIC0gOCwgdGhpcy5jLmQoKSksIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA0LCB0aGlzLmwpO1xuICAgICAgICB0aGlzLm9uZGF0YShyYXcsIGYpO1xuICAgIH07XG4gICAgcmV0dXJuIEd6aXA7XG59KCkpO1xuZXhwb3J0IHsgR3ppcCB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIEdaSVAgY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jR3ppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY0d6aXAob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkRmbHQsXG4gICAgICAgICAgICBnemUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIERlZmxhdGUsIEd6aXBdOyB9XG4gICAgICAgIF0sIHRoaXMsIEFzeW5jQ21wU3RybS5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBHemlwKGV2LmRhdGEpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDgpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNHemlwO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jR3ppcCB9O1xuZXhwb3J0IGZ1bmN0aW9uIGd6aXAoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkRmbHQsXG4gICAgICAgIGd6ZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2d6aXBTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGd6aXBTeW5jKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pKTsgfSwgMiwgY2IpO1xufVxuLyoqXG4gKiBDb21wcmVzc2VzIGRhdGEgd2l0aCBHWklQXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBnemlwcGVkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGd6aXBTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpXG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB2YXIgYyA9IGNyYygpLCBsID0gZGF0YS5sZW5ndGg7XG4gICAgYy5wKGRhdGEpO1xuICAgIHZhciBkID0gZG9wdChkYXRhLCBvcHRzLCBnemhsKG9wdHMpLCA4KSwgcyA9IGQubGVuZ3RoO1xuICAgIHJldHVybiBnemgoZCwgb3B0cyksIHdieXRlcyhkLCBzIC0gOCwgYy5kKCkpLCB3Ynl0ZXMoZCwgcyAtIDQsIGwpLCBkO1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgR1pJUCBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBHdW56aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEdVTlpJUCBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBpbmZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEd1bnppcChjYikge1xuICAgICAgICB0aGlzLnYgPSAxO1xuICAgICAgICBJbmZsYXRlLmNhbGwodGhpcywgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBHVU5aSVBwZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgR3VuemlwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5lLmNhbGwodGhpcywgY2h1bmspO1xuICAgICAgICBpZiAodGhpcy52KSB7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMucC5sZW5ndGggPiAzID8gZ3pzKHRoaXMucCkgOiA0O1xuICAgICAgICAgICAgaWYgKHMgPj0gdGhpcy5wLmxlbmd0aCAmJiAhZmluYWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KHMpLCB0aGlzLnYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPCA4KVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGd6aXAgc3RyZWFtJztcbiAgICAgICAgICAgIHRoaXMucCA9IHRoaXMucC5zdWJhcnJheSgwLCAtOCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVjZXNzYXJ5IHRvIHByZXZlbnQgVFMgZnJvbSB1c2luZyB0aGUgY2xvc3VyZSB2YWx1ZVxuICAgICAgICAvLyBUaGlzIGFsbG93cyBmb3Igd29ya2VyaXphdGlvbiB0byBmdW5jdGlvbiBjb3JyZWN0bHlcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuYy5jYWxsKHRoaXMsIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBHdW56aXA7XG59KCkpO1xuZXhwb3J0IHsgR3VuemlwIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0d1bnppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBHVU5aSVAgc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVmbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY0d1bnppcChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiSW5mbHQsXG4gICAgICAgICAgICBndXplLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBJbmZsYXRlLCBHdW56aXBdOyB9XG4gICAgICAgIF0sIHRoaXMsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IEd1bnppcCgpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDkpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNHdW56aXA7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNHdW56aXAgfTtcbmV4cG9ydCBmdW5jdGlvbiBndW56aXAoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0LFxuICAgICAgICBndXplLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3VuemlwU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihndW56aXBTeW5jKGV2LmRhdGFbMF0pKTsgfSwgMywgY2IpO1xufVxuLyoqXG4gKiBFeHBhbmRzIEdaSVAgZGF0YVxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG91dCBXaGVyZSB0byB3cml0ZSB0aGUgZGF0YS4gR1pJUCBhbHJlYWR5IGVuY29kZXMgdGhlIG91dHB1dCBzaXplLCBzbyBwcm92aWRpbmcgdGhpcyBkb2Vzbid0IHNhdmUgbWVtb3J5LlxuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBndW56aXBTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiBpbmZsdChkYXRhLnN1YmFycmF5KGd6cyhkYXRhKSwgLTgpLCBvdXQgfHwgbmV3IHU4KGd6bChkYXRhKSkpO1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgWmxpYiBjb21wcmVzc2lvblxuICovXG52YXIgWmxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBabGliKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMuYyA9IGFkbGVyKCk7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIERlZmxhdGUuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIHpsaWJiZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmxpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgRGVmbGF0ZS5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICBabGliLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdGhpcy5jLnAoYyk7XG4gICAgICAgIHZhciByYXcgPSBkb3B0KGMsIHRoaXMubywgdGhpcy52ICYmIDIsIGYgJiYgNCwgIWYpO1xuICAgICAgICBpZiAodGhpcy52KVxuICAgICAgICAgICAgemxoKHJhdywgdGhpcy5vKSwgdGhpcy52ID0gMDtcbiAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICB3Ynl0ZXMocmF3LCByYXcubGVuZ3RoIC0gNCwgdGhpcy5jLmQoKSk7XG4gICAgICAgIHRoaXMub25kYXRhKHJhdywgZik7XG4gICAgfTtcbiAgICByZXR1cm4gWmxpYjtcbn0oKSk7XG5leHBvcnQgeyBabGliIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgWmxpYiBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNabGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jWmxpYihvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIHpsZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZSwgWmxpYl07IH1cbiAgICAgICAgXSwgdGhpcywgQXN5bmNDbXBTdHJtLmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IFpsaWIoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNabGliO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jWmxpYiB9O1xuZXhwb3J0IGZ1bmN0aW9uIHpsaWIoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkRmbHQsXG4gICAgICAgIHpsZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW3psaWJTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKHpsaWJTeW5jKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pKTsgfSwgNCwgY2IpO1xufVxuLyoqXG4gKiBDb21wcmVzcyBkYXRhIHdpdGggWmxpYlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgemxpYi1jb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHpsaWJTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpXG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB2YXIgYSA9IGFkbGVyKCk7XG4gICAgYS5wKGRhdGEpO1xuICAgIHZhciBkID0gZG9wdChkYXRhLCBvcHRzLCAyLCA0KTtcbiAgICByZXR1cm4gemxoKGQsIG9wdHMpLCB3Ynl0ZXMoZCwgZC5sZW5ndGggLSA0LCBhLmQoKSksIGQ7XG59XG4vKipcbiAqIFN0cmVhbWluZyBabGliIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIFVuemxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgWmxpYiBkZWNvbXByZXNzaW9uIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGluZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gVW56bGliKGNiKSB7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIEluZmxhdGUuY2FsbCh0aGlzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIHVuemxpYmJlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBVbnpsaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmUuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIGlmICh0aGlzLnYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoIDwgMiAmJiAhZmluYWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDIpLCB0aGlzLnYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPCA0KVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHpsaWIgc3RyZWFtJztcbiAgICAgICAgICAgIHRoaXMucCA9IHRoaXMucC5zdWJhcnJheSgwLCAtNCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVjZXNzYXJ5IHRvIHByZXZlbnQgVFMgZnJvbSB1c2luZyB0aGUgY2xvc3VyZSB2YWx1ZVxuICAgICAgICAvLyBUaGlzIGFsbG93cyBmb3Igd29ya2VyaXphdGlvbiB0byBmdW5jdGlvbiBjb3JyZWN0bHlcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuYy5jYWxsKHRoaXMsIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBVbnpsaWI7XG59KCkpO1xuZXhwb3J0IHsgVW56bGliIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgWmxpYiBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY1VuemxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBabGliIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVmbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY1VuemxpYihjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiSW5mbHQsXG4gICAgICAgICAgICB6dWxlLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBJbmZsYXRlLCBVbnpsaWJdOyB9XG4gICAgICAgIF0sIHRoaXMsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IFVuemxpYigpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDExKTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jVW56bGliO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jVW56bGliIH07XG5leHBvcnQgZnVuY3Rpb24gdW56bGliKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJJbmZsdCxcbiAgICAgICAgenVsZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW3VuemxpYlN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYodW56bGliU3luYyhldi5kYXRhWzBdLCBndTgoZXYuZGF0YVsxXSkpKTsgfSwgNSwgY2IpO1xufVxuLyoqXG4gKiBFeHBhbmRzIFpsaWIgZGF0YVxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG91dCBXaGVyZSB0byB3cml0ZSB0aGUgZGF0YS4gU2F2ZXMgbWVtb3J5IGlmIHlvdSBrbm93IHRoZSBkZWNvbXByZXNzZWQgc2l6ZSBhbmQgcHJvdmlkZSBhbiBvdXRwdXQgYnVmZmVyIG9mIHRoYXQgbGVuZ3RoLlxuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnpsaWJTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiBpbmZsdCgoemx2KGRhdGEpLCBkYXRhLnN1YmFycmF5KDIsIC00KSksIG91dCk7XG59XG4vLyBEZWZhdWx0IGFsZ29yaXRobSBmb3IgY29tcHJlc3Npb24gKHVzZWQgYmVjYXVzZSBoYXZpbmcgYSBrbm93biBvdXRwdXQgc2l6ZSBhbGxvd3MgZmFzdGVyIGRlY29tcHJlc3Npb24pXG5leHBvcnQgeyBnemlwIGFzIGNvbXByZXNzLCBBc3luY0d6aXAgYXMgQXN5bmNDb21wcmVzcyB9O1xuLy8gRGVmYXVsdCBhbGdvcml0aG0gZm9yIGNvbXByZXNzaW9uICh1c2VkIGJlY2F1c2UgaGF2aW5nIGEga25vd24gb3V0cHV0IHNpemUgYWxsb3dzIGZhc3RlciBkZWNvbXByZXNzaW9uKVxuZXhwb3J0IHsgZ3ppcFN5bmMgYXMgY29tcHJlc3NTeW5jLCBHemlwIGFzIENvbXByZXNzIH07XG4vKipcbiAqIFN0cmVhbWluZyBHWklQLCBabGliLCBvciByYXcgREVGTEFURSBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBEZWNvbXByZXNzID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWNvbXByZXNzaW9uIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGRlY29tcHJlc3NlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY29tcHJlc3MoY2IpIHtcbiAgICAgICAgdGhpcy5HID0gR3VuemlwO1xuICAgICAgICB0aGlzLkkgPSBJbmZsYXRlO1xuICAgICAgICB0aGlzLlogPSBVbnpsaWI7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlY29tcHJlc3NlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIHN0cmVhbSBoYW5kbGVyJztcbiAgICAgICAgaWYgKCF0aGlzLnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAgJiYgdGhpcy5wLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG4uc2V0KHRoaXMucCksIG4uc2V0KGNodW5rLCB0aGlzLnAubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBjaHVuaztcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7IF90aGlzXzEub25kYXRhLmFwcGx5KF90aGlzXzEsIGFyZ3VtZW50cyk7IH07XG4gICAgICAgICAgICAgICAgdGhpcy5zID0gKHRoaXMucFswXSA9PSAzMSAmJiB0aGlzLnBbMV0gPT0gMTM5ICYmIHRoaXMucFsyXSA9PSA4KVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyB0aGlzLkcoY2IpXG4gICAgICAgICAgICAgICAgICAgIDogKCh0aGlzLnBbMF0gJiAxNSkgIT0gOCB8fCAodGhpcy5wWzBdID4+IDQpID4gNyB8fCAoKHRoaXMucFswXSA8PCA4IHwgdGhpcy5wWzFdKSAlIDMxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IHRoaXMuSShjYilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IHRoaXMuWihjYik7XG4gICAgICAgICAgICAgICAgdGhpcy5zLnB1c2godGhpcy5wLCBmaW5hbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnMucHVzaChjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY29tcHJlc3M7XG59KCkpO1xuZXhwb3J0IHsgRGVjb21wcmVzcyB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jRGVjb21wcmVzcyA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVjb21wcmVzc2VkXG4gICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jRGVjb21wcmVzcyhjYikge1xuICAgICAgICB0aGlzLkcgPSBBc3luY0d1bnppcDtcbiAgICAgICAgdGhpcy5JID0gQXN5bmNJbmZsYXRlO1xuICAgICAgICB0aGlzLlogPSBBc3luY1VuemxpYjtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVjb21wcmVzc2VkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEFzeW5jRGVjb21wcmVzcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgRGVjb21wcmVzcy5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNEZWNvbXByZXNzO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jRGVjb21wcmVzcyB9O1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcHJlc3MoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIChkYXRhWzBdID09IDMxICYmIGRhdGFbMV0gPT0gMTM5ICYmIGRhdGFbMl0gPT0gOClcbiAgICAgICAgPyBndW56aXAoZGF0YSwgb3B0cywgY2IpXG4gICAgICAgIDogKChkYXRhWzBdICYgMTUpICE9IDggfHwgKGRhdGFbMF0gPj4gNCkgPiA3IHx8ICgoZGF0YVswXSA8PCA4IHwgZGF0YVsxXSkgJSAzMSkpXG4gICAgICAgICAgICA/IGluZmxhdGUoZGF0YSwgb3B0cywgY2IpXG4gICAgICAgICAgICA6IHVuemxpYihkYXRhLCBvcHRzLCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgY29tcHJlc3NlZCBHWklQLCBabGliLCBvciByYXcgREVGTEFURSBkYXRhLCBhdXRvbWF0aWNhbGx5IGRldGVjdGluZyB0aGUgZm9ybWF0XG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBTYXZlcyBtZW1vcnkgaWYgeW91IGtub3cgdGhlIGRlY29tcHJlc3NlZCBzaXplIGFuZCBwcm92aWRlIGFuIG91dHB1dCBidWZmZXIgb2YgdGhhdCBsZW5ndGguXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcHJlc3NTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiAoZGF0YVswXSA9PSAzMSAmJiBkYXRhWzFdID09IDEzOSAmJiBkYXRhWzJdID09IDgpXG4gICAgICAgID8gZ3VuemlwU3luYyhkYXRhLCBvdXQpXG4gICAgICAgIDogKChkYXRhWzBdICYgMTUpICE9IDggfHwgKGRhdGFbMF0gPj4gNCkgPiA3IHx8ICgoZGF0YVswXSA8PCA4IHwgZGF0YVsxXSkgJSAzMSkpXG4gICAgICAgICAgICA/IGluZmxhdGVTeW5jKGRhdGEsIG91dClcbiAgICAgICAgICAgIDogdW56bGliU3luYyhkYXRhLCBvdXQpO1xufVxuLy8gZmxhdHRlbiBhIGRpcmVjdG9yeSBzdHJ1Y3R1cmVcbnZhciBmbHRuID0gZnVuY3Rpb24gKGQsIHAsIHQsIG8pIHtcbiAgICBmb3IgKHZhciBrIGluIGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRba10sIG4gPSBwICsgaztcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIHU4KVxuICAgICAgICAgICAgdFtuXSA9IFt2YWwsIG9dO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgICAgICAgICB0W25dID0gW3ZhbFswXSwgbXJnKG8sIHZhbFsxXSldO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmbHRuKHZhbCwgbiArICcvJywgdCwgbyk7XG4gICAgfVxufTtcbi8vIHRleHQgZW5jb2RlclxudmFyIHRlID0gdHlwZW9mIFRleHRFbmNvZGVyICE9ICd1bmRlZmluZWQnICYmIC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG4vLyB0ZXh0IGRlY29kZXJcbnZhciB0ZCA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPSAndW5kZWZpbmVkJyAmJiAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RGVjb2RlcigpO1xuLy8gdGV4dCBkZWNvZGVyIHN0cmVhbVxudmFyIHRkcyA9IDA7XG50cnkge1xuICAgIHRkLmRlY29kZShldCwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgdGRzID0gMTtcbn1cbmNhdGNoIChlKSB7IH1cbi8vIGRlY29kZSBVVEY4XG52YXIgZHV0ZjggPSBmdW5jdGlvbiAoZCkge1xuICAgIGZvciAodmFyIHIgPSAnJywgaSA9IDA7Oykge1xuICAgICAgICB2YXIgYyA9IGRbaSsrXTtcbiAgICAgICAgdmFyIGViID0gKGMgPiAxMjcpICsgKGMgPiAyMjMpICsgKGMgPiAyMzkpO1xuICAgICAgICBpZiAoaSArIGViID4gZC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gW3IsIHNsYyhkLCBpIC0gMSldO1xuICAgICAgICBpZiAoIWViKVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICBlbHNlIGlmIChlYiA9PSAzKSB7XG4gICAgICAgICAgICBjID0gKChjICYgMTUpIDw8IDE4IHwgKGRbaSsrXSAmIDYzKSA8PCAxMiB8IChkW2krK10gJiA2MykgPDwgNiB8IChkW2krK10gJiA2MykpIC0gNjU1MzYsXG4gICAgICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgKGMgPj4gMTApLCA1NjMyMCB8IChjICYgMTAyMykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGViICYgMSlcbiAgICAgICAgICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDMxKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDE1KSA8PCAxMiB8IChkW2krK10gJiA2MykgPDwgNiB8IChkW2krK10gJiA2MykpO1xuICAgIH1cbn07XG4vKipcbiAqIFN0cmVhbWluZyBVVEYtOCBkZWNvZGluZ1xuICovXG52YXIgRGVjb2RlVVRGOCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVVRGLTggZGVjb2Rpbmcgc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVjb2RlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY29kZVVURjgoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgaWYgKHRkcylcbiAgICAgICAgICAgIHRoaXMudCA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnAgPSBldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVjb2RlZCBmcm9tIFVURi04IGJpbmFyeVxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWNvZGVVVEY4LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICAgICAgZmluYWwgPSAhIWZpbmFsO1xuICAgICAgICBpZiAodGhpcy50KSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YSh0aGlzLnQuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KSwgZmluYWwpO1xuICAgICAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudC5kZWNvZGUoKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHV0Zi04IGRhdGEnO1xuICAgICAgICAgICAgICAgIHRoaXMudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnApXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgdmFyIGRhdCA9IG5ldyB1OCh0aGlzLnAubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgZGF0LnNldCh0aGlzLnApO1xuICAgICAgICBkYXQuc2V0KGNodW5rLCB0aGlzLnAubGVuZ3RoKTtcbiAgICAgICAgdmFyIF9hID0gZHV0ZjgoZGF0KSwgY2ggPSBfYVswXSwgbnAgPSBfYVsxXTtcbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAobnAubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHV0Zi04IGRhdGEnO1xuICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnAgPSBucDtcbiAgICAgICAgdGhpcy5vbmRhdGEoY2gsIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWNvZGVVVEY4O1xufSgpKTtcbmV4cG9ydCB7IERlY29kZVVURjggfTtcbi8qKlxuICogU3RyZWFtaW5nIFVURi04IGVuY29kaW5nXG4gKi9cbnZhciBFbmNvZGVVVEY4ID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVVEYtOCBkZWNvZGluZyBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBlbmNvZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRW5jb2RlVVRGOChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBlbmNvZGVkIHRvIFVURi04XG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBzdHJpbmcgZGF0YSB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEVuY29kZVVURjgucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIHRoaXMub25kYXRhKHN0clRvVTgoY2h1bmspLCB0aGlzLmQgPSBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRW5jb2RlVVRGODtcbn0oKSk7XG5leHBvcnQgeyBFbmNvZGVVVEY4IH07XG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBVaW50OEFycmF5IGZvciB1c2Ugd2l0aCBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIG1ldGhvZHNcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEBwYXJhbSBsYXRpbjEgV2hldGhlciBvciBub3QgdG8gaW50ZXJwcmV0IHRoZSBkYXRhIGFzIExhdGluLTEuIFRoaXMgc2hvdWxkXG4gKiAgICAgICAgICAgICAgIG5vdCBuZWVkIHRvIGJlIHRydWUgdW5sZXNzIGRlY29kaW5nIGEgYmluYXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcgZW5jb2RlZCBpbiBVVEYtOC9MYXRpbi0xIGJpbmFyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyVG9VOChzdHIsIGxhdGluMSkge1xuICAgIGlmIChsYXRpbjEpIHtcbiAgICAgICAgdmFyIGFyXzEgPSBuZXcgdTgoc3RyLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYXJfMVtpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICByZXR1cm4gYXJfMTtcbiAgICB9XG4gICAgaWYgKHRlKVxuICAgICAgICByZXR1cm4gdGUuZW5jb2RlKHN0cik7XG4gICAgdmFyIGwgPSBzdHIubGVuZ3RoO1xuICAgIHZhciBhciA9IG5ldyB1OChzdHIubGVuZ3RoICsgKHN0ci5sZW5ndGggPj4gMSkpO1xuICAgIHZhciBhaSA9IDA7XG4gICAgdmFyIHcgPSBmdW5jdGlvbiAodikgeyBhclthaSsrXSA9IHY7IH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgaWYgKGFpICsgNSA+IGFyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG4gPSBuZXcgdTgoYWkgKyA4ICsgKChsIC0gaSkgPDwgMSkpO1xuICAgICAgICAgICAgbi5zZXQoYXIpO1xuICAgICAgICAgICAgYXIgPSBuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4IHx8IGxhdGluMSlcbiAgICAgICAgICAgIHcoYyk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxuICAgICAgICAgICAgdygxOTIgfCAoYyA+PiA2KSksIHcoMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICBlbHNlIGlmIChjID4gNTUyOTUgJiYgYyA8IDU3MzQ0KVxuICAgICAgICAgICAgYyA9IDY1NTM2ICsgKGMgJiAxMDIzIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMTAyMyksXG4gICAgICAgICAgICAgICAgdygyNDAgfCAoYyA+PiAxOCkpLCB3KDEyOCB8ICgoYyA+PiAxMikgJiA2MykpLCB3KDEyOCB8ICgoYyA+PiA2KSAmIDYzKSksIHcoMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3KDIyNCB8IChjID4+IDEyKSksIHcoMTI4IHwgKChjID4+IDYpICYgNjMpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgfVxuICAgIHJldHVybiBzbGMoYXIsIDAsIGFpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgc3RyaW5nXG4gKiBAcGFyYW0gZGF0IFRoZSBkYXRhIHRvIGRlY29kZSB0byBzdHJpbmdcbiAqIEBwYXJhbSBsYXRpbjEgV2hldGhlciBvciBub3QgdG8gaW50ZXJwcmV0IHRoZSBkYXRhIGFzIExhdGluLTEuIFRoaXMgc2hvdWxkXG4gKiAgICAgICAgICAgICAgIG5vdCBuZWVkIHRvIGJlIHRydWUgdW5sZXNzIGVuY29kaW5nIHRvIGJpbmFyeSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgb3JpZ2luYWwgVVRGLTgvTGF0aW4tMSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0ckZyb21VOChkYXQsIGxhdGluMSkge1xuICAgIGlmIChsYXRpbjEpIHtcbiAgICAgICAgdmFyIHIgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXQubGVuZ3RoOyBpICs9IDE2Mzg0KVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdC5zdWJhcnJheShpLCBpICsgMTYzODQpKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRkKVxuICAgICAgICByZXR1cm4gdGQuZGVjb2RlKGRhdCk7XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBfYSA9IGR1dGY4KGRhdCksIG91dCA9IF9hWzBdLCBleHQgPSBfYVsxXTtcbiAgICAgICAgaWYgKGV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB1dGYtOCBkYXRhJztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59XG47XG4vLyBkZWZsYXRlIGJpdCBmbGFnXG52YXIgZGJmID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwgPT0gMSA/IDMgOiBsIDwgNiA/IDIgOiBsID09IDkgPyAxIDogMDsgfTtcbi8vIHNraXAgbG9jYWwgemlwIGhlYWRlclxudmFyIHNsemggPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gYiArIDMwICsgYjIoZCwgYiArIDI2KSArIGIyKGQsIGIgKyAyOCk7IH07XG4vLyByZWFkIHppcCBoZWFkZXJcbnZhciB6aCA9IGZ1bmN0aW9uIChkLCBiLCB6KSB7XG4gICAgdmFyIGZubCA9IGIyKGQsIGIgKyAyOCksIGZuID0gc3RyRnJvbVU4KGQuc3ViYXJyYXkoYiArIDQ2LCBiICsgNDYgKyBmbmwpLCAhKGIyKGQsIGIgKyA4KSAmIDIwNDgpKSwgZXMgPSBiICsgNDYgKyBmbmwsIGJzID0gYjQoZCwgYiArIDIwKTtcbiAgICB2YXIgX2EgPSB6ICYmIGJzID09IDQyOTQ5NjcyOTUgPyB6NjRlKGQsIGVzKSA6IFticywgYjQoZCwgYiArIDI0KSwgYjQoZCwgYiArIDQyKV0sIHNjID0gX2FbMF0sIHN1ID0gX2FbMV0sIG9mZiA9IF9hWzJdO1xuICAgIHJldHVybiBbYjIoZCwgYiArIDEwKSwgc2MsIHN1LCBmbiwgZXMgKyBiMihkLCBiICsgMzApICsgYjIoZCwgYiArIDMyKSwgb2ZmXTtcbn07XG4vLyByZWFkIHppcDY0IGV4dHJhIGZpZWxkXG52YXIgejY0ZSA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICg7IGIyKGQsIGIpICE9IDE7IGIgKz0gNCArIGIyKGQsIGIgKyAyKSlcbiAgICAgICAgO1xuICAgIHJldHVybiBbYjgoZCwgYiArIDEyKSwgYjgoZCwgYiArIDQpLCBiOChkLCBiICsgMjApXTtcbn07XG4vLyBleHRyYSBmaWVsZCBsZW5ndGhcbnZhciBleGZsID0gZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIGxlID0gMDtcbiAgICBpZiAoZXgpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBleCkge1xuICAgICAgICAgICAgdmFyIGwgPSBleFtrXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobCA+IDY1NTM1KVxuICAgICAgICAgICAgICAgIHRocm93ICdleHRyYSBmaWVsZCB0b28gbG9uZyc7XG4gICAgICAgICAgICBsZSArPSBsICsgNDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGU7XG59O1xuLy8gd3JpdGUgemlwIGhlYWRlclxudmFyIHd6aCA9IGZ1bmN0aW9uIChkLCBiLCBmLCBmbiwgdSwgYywgY2UsIGNvKSB7XG4gICAgdmFyIGZsID0gZm4ubGVuZ3RoLCBleCA9IGYuZXh0cmEsIGNvbCA9IGNvICYmIGNvLmxlbmd0aDtcbiAgICB2YXIgZXhsID0gZXhmbChleCk7XG4gICAgd2J5dGVzKGQsIGIsIGNlICE9IG51bGwgPyAweDIwMTRCNTAgOiAweDQwMzRCNTApLCBiICs9IDQ7XG4gICAgaWYgKGNlICE9IG51bGwpXG4gICAgICAgIGRbYisrXSA9IDIwLCBkW2IrK10gPSBmLm9zO1xuICAgIGRbYl0gPSAyMCwgYiArPSAyOyAvLyBzcGVjIGNvbXBsaWFuY2U/IHdoYXQncyB0aGF0P1xuICAgIGRbYisrXSA9IChmLmZsYWcgPDwgMSkgfCAoYyA9PSBudWxsICYmIDgpLCBkW2IrK10gPSB1ICYmIDg7XG4gICAgZFtiKytdID0gZi5jb21wcmVzc2lvbiAmIDI1NSwgZFtiKytdID0gZi5jb21wcmVzc2lvbiA+PiA4O1xuICAgIHZhciBkdCA9IG5ldyBEYXRlKGYubXRpbWUgPT0gbnVsbCA/IERhdGUubm93KCkgOiBmLm10aW1lKSwgeSA9IGR0LmdldEZ1bGxZZWFyKCkgLSAxOTgwO1xuICAgIGlmICh5IDwgMCB8fCB5ID4gMTE5KVxuICAgICAgICB0aHJvdyAnZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5JztcbiAgICB3Ynl0ZXMoZCwgYiwgKHkgPDwgMjUpIHwgKChkdC5nZXRNb250aCgpICsgMSkgPDwgMjEpIHwgKGR0LmdldERhdGUoKSA8PCAxNikgfCAoZHQuZ2V0SG91cnMoKSA8PCAxMSkgfCAoZHQuZ2V0TWludXRlcygpIDw8IDUpIHwgKGR0LmdldFNlY29uZHMoKSA+Pj4gMSkpLCBiICs9IDQ7XG4gICAgaWYgKGMgIT0gbnVsbCkge1xuICAgICAgICB3Ynl0ZXMoZCwgYiwgZi5jcmMpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDQsIGMpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDgsIGYuc2l6ZSk7XG4gICAgfVxuICAgIHdieXRlcyhkLCBiICsgMTIsIGZsKTtcbiAgICB3Ynl0ZXMoZCwgYiArIDE0LCBleGwpLCBiICs9IDE2O1xuICAgIGlmIChjZSAhPSBudWxsKSB7XG4gICAgICAgIHdieXRlcyhkLCBiLCBjb2wpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDYsIGYuYXR0cnMpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDEwLCBjZSksIGIgKz0gMTQ7XG4gICAgfVxuICAgIGQuc2V0KGZuLCBiKTtcbiAgICBiICs9IGZsO1xuICAgIGlmIChleGwpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBleCkge1xuICAgICAgICAgICAgdmFyIGV4ZiA9IGV4W2tdLCBsID0gZXhmLmxlbmd0aDtcbiAgICAgICAgICAgIHdieXRlcyhkLCBiLCArayk7XG4gICAgICAgICAgICB3Ynl0ZXMoZCwgYiArIDIsIGwpO1xuICAgICAgICAgICAgZC5zZXQoZXhmLCBiICsgNCksIGIgKz0gNCArIGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbClcbiAgICAgICAgZC5zZXQoY28sIGIpLCBiICs9IGNvbDtcbiAgICByZXR1cm4gYjtcbn07XG4vLyB3cml0ZSB6aXAgZm9vdGVyIChlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkpXG52YXIgd3pmID0gZnVuY3Rpb24gKG8sIGIsIGMsIGQsIGUpIHtcbiAgICB3Ynl0ZXMobywgYiwgMHg2MDU0QjUwKTsgLy8gc2tpcCBkaXNrXG4gICAgd2J5dGVzKG8sIGIgKyA4LCBjKTtcbiAgICB3Ynl0ZXMobywgYiArIDEwLCBjKTtcbiAgICB3Ynl0ZXMobywgYiArIDEyLCBkKTtcbiAgICB3Ynl0ZXMobywgYiArIDE2LCBlKTtcbn07XG4vKipcbiAqIEEgcGFzcy10aHJvdWdoIHN0cmVhbSB0byBrZWVwIGRhdGEgdW5jb21wcmVzc2VkIGluIGEgWklQIGFyY2hpdmUuXG4gKi9cbnZhciBaaXBQYXNzVGhyb3VnaCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFzcy10aHJvdWdoIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBaaXBQYXNzVGhyb3VnaChmaWxlbmFtZSkge1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMuYyA9IGNyYygpO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGEgY2h1bmsgYW5kIHB1c2hlcyB0byB0aGUgb3V0cHV0IHN0cmVhbS4gWW91IGNhbiBvdmVycmlkZSB0aGlzXG4gICAgICogbWV0aG9kIGluIGEgc3ViY2xhc3MgZm9yIGN1c3RvbSBiZWhhdmlvciwgYnV0IGJ5IGRlZmF1bHQgdGhpcyBwYXNzZXNcbiAgICAgKiB0aGUgZGF0YSB0aHJvdWdoLiBZb3UgbXVzdCBjYWxsIHRoaXMub25kYXRhKGVyciwgY2h1bmssIGZpbmFsKSBhdCBzb21lXG4gICAgICogcG9pbnQgaW4gdGhpcyBtZXRob2QuXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwcm9jZXNzXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLm9uZGF0YShudWxsLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgYWRkZWQuIElmIHlvdSBhcmUgc3ViY2xhc3NpbmcgdGhpcyB3aXRoIGEgY3VzdG9tXG4gICAgICogY29tcHJlc3Npb24gYWxnb3JpdGhtLCBub3RlIHRoYXQgeW91IG11c3QgcHVzaCBkYXRhIGZyb20gdGhlIHNvdXJjZVxuICAgICAqIGZpbGUgb25seSwgcHJlLWNvbXByZXNzaW9uLlxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBaaXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayAtIGFkZCB0byBaSVAgYXJjaGl2ZSBiZWZvcmUgcHVzaGluZyc7XG4gICAgICAgIHRoaXMuYy5wKGNodW5rKTtcbiAgICAgICAgdGhpcy5zaXplICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGZpbmFsKVxuICAgICAgICAgICAgdGhpcy5jcmMgPSB0aGlzLmMuZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3MoY2h1bmssIGZpbmFsIHx8IGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBQYXNzVGhyb3VnaDtcbn0oKSk7XG5leHBvcnQgeyBaaXBQYXNzVGhyb3VnaCB9O1xuLy8gSSBkb24ndCBleHRlbmQgYmVjYXVzZSBUeXBlU2NyaXB0IGV4dGVuc2lvbiBhZGRzIDFrQiBvZiBydW50aW1lIGJsb2F0XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXMuIFByZWZlciB1c2luZyBBc3luY1ppcERlZmxhdGVcbiAqIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAqL1xudmFyIFppcERlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gWmlwRGVmbGF0ZShmaWxlbmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICghb3B0cylcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2guY2FsbCh0aGlzLCBmaWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZCA9IG5ldyBEZWZsYXRlKG9wdHMsIGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpc18xLm9uZGF0YShudWxsLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSA4O1xuICAgICAgICB0aGlzLmZsYWcgPSBkYmYob3B0cy5sZXZlbCk7XG4gICAgfVxuICAgIFppcERlZmxhdGUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmQucHVzaChjaHVuaywgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlLCBudWxsLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IFppcERlZmxhdGUgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXNcbiAqL1xudmFyIEFzeW5jWmlwRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBzdHJlYW0gdGhhdCBjYW4gYmUgYWRkZWQgdG8gWklQIGFyY2hpdmVzXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIFRoZSBmaWxlbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRhdGEgc3RyZWFtXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY1ppcERlZmxhdGUoZmlsZW5hbWUsIG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdHMpXG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLmNhbGwodGhpcywgZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmQgPSBuZXcgQXN5bmNEZWZsYXRlKG9wdHMsIGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzXzEub25kYXRhKGVyciwgZGF0LCBmaW5hbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uID0gODtcbiAgICAgICAgdGhpcy5mbGFnID0gZGJmKG9wdHMubGV2ZWwpO1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZSA9IHRoaXMuZC50ZXJtaW5hdGU7XG4gICAgfVxuICAgIEFzeW5jWmlwRGVmbGF0ZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5kLnB1c2goY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEFzeW5jWmlwRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jWmlwRGVmbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBBc3luY1ppcERlZmxhdGUgfTtcbi8vIFRPRE86IEJldHRlciB0cmVlIHNoYWtpbmdcbi8qKlxuICogQSB6aXBwYWJsZSBhcmNoaXZlIHRvIHdoaWNoIGZpbGVzIGNhbiBpbmNyZW1lbnRhbGx5IGJlIGFkZGVkXG4gKi9cbnZhciBaaXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlbXB0eSBaSVAgYXJjaGl2ZSB0byB3aGljaCBmaWxlcyBjYW4gYmUgYWRkZWRcbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBmb3IgdGhlIGdlbmVyYXRlZCBaSVAgYXJjaGl2ZVxuICAgICAqICAgICAgICAgICBpcyBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBaaXAoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgdGhpcy51ID0gW107XG4gICAgICAgIHRoaXMuZCA9IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmaWxlIHRvIHRoZSBaSVAgYXJjaGl2ZVxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBmaWxlIHN0cmVhbSB0byBhZGRcbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZCAmIDIpXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZpbGUuZmlsZW5hbWUpLCBmbCA9IGYubGVuZ3RoO1xuICAgICAgICB2YXIgY29tID0gZmlsZS5jb21tZW50LCBvID0gY29tICYmIHN0clRvVTgoY29tKTtcbiAgICAgICAgdmFyIHUgPSBmbCAhPSBmaWxlLmZpbGVuYW1lLmxlbmd0aCB8fCAobyAmJiAoY29tLmxlbmd0aCAhPSBvLmxlbmd0aCkpO1xuICAgICAgICB2YXIgaGwgPSBmbCArIGV4ZmwoZmlsZS5leHRyYSkgKyAzMDtcbiAgICAgICAgaWYgKGZsID4gNjU1MzUpXG4gICAgICAgICAgICB0aHJvdyAnZmlsZW5hbWUgdG9vIGxvbmcnO1xuICAgICAgICB2YXIgaGVhZGVyID0gbmV3IHU4KGhsKTtcbiAgICAgICAgd3poKGhlYWRlciwgMCwgZmlsZSwgZiwgdSk7XG4gICAgICAgIHZhciBjaGtzID0gW2hlYWRlcl07XG4gICAgICAgIHZhciBwQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjaGtzXzEgPSBjaGtzOyBfaSA8IGNoa3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hrID0gY2hrc18xW19pXTtcbiAgICAgICAgICAgICAgICBfdGhpc18xLm9uZGF0YShudWxsLCBjaGssIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoa3MgPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRyID0gdGhpcy5kO1xuICAgICAgICB0aGlzLmQgPSAwO1xuICAgICAgICB2YXIgaW5kID0gdGhpcy51Lmxlbmd0aDtcbiAgICAgICAgdmFyIHVmID0gbXJnKGZpbGUsIHtcbiAgICAgICAgICAgIGY6IGYsXG4gICAgICAgICAgICB1OiB1LFxuICAgICAgICAgICAgbzogbyxcbiAgICAgICAgICAgIHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS50ZXJtaW5hdGUpXG4gICAgICAgICAgICAgICAgICAgIGZpbGUudGVybWluYXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBBbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAodHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG54dCA9IF90aGlzXzEudVtpbmQgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG54dClcbiAgICAgICAgICAgICAgICAgICAgICAgIG54dC5yKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzXzEuZCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjbCA9IDA7XG4gICAgICAgIGZpbGUub25kYXRhID0gZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKGVyciwgZGF0LCBmaW5hbCk7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsICs9IGRhdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY2hrcy5wdXNoKGRhdCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZCA9IG5ldyB1OCgxNik7XG4gICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgMCwgMHg4MDc0QjUwKTtcbiAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCA0LCBmaWxlLmNyYyk7XG4gICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgOCwgY2wpO1xuICAgICAgICAgICAgICAgICAgICB3Ynl0ZXMoZGQsIDEyLCBmaWxlLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICBjaGtzLnB1c2goZGQpO1xuICAgICAgICAgICAgICAgICAgICB1Zi5jID0gY2wsIHVmLmIgPSBobCArIGNsICsgMTYsIHVmLmNyYyA9IGZpbGUuY3JjLCB1Zi5zaXplID0gZmlsZS5zaXplO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICAgICAgICAgICAgICB1Zi5yKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHIpXG4gICAgICAgICAgICAgICAgICAgIHBBbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51LnB1c2godWYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5kcyB0aGUgcHJvY2VzcyBvZiBhZGRpbmcgZmlsZXMgYW5kIHByZXBhcmVzIHRvIGVtaXQgdGhlIGZpbmFsIGNodW5rcy5cbiAgICAgKiBUaGlzICptdXN0KiBiZSBjYWxsZWQgYWZ0ZXIgYWRkaW5nIGFsbCBkZXNpcmVkIGZpbGVzIGZvciB0aGUgcmVzdWx0aW5nXG4gICAgICogWklQIGZpbGUgdG8gd29yayBwcm9wZXJseS5cbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kICYgMikge1xuICAgICAgICAgICAgaWYgKHRoaXMuZCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hpbmcnO1xuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgIHRoaXMuZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnUucHVzaCh7XG4gICAgICAgICAgICAgICAgcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShfdGhpc18xLmQgJiAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS51LnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzXzEuZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdDogZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kID0gMztcbiAgICB9O1xuICAgIFppcC5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ0ID0gMCwgbCA9IDAsIHRsID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMudTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gX2FbX2ldO1xuICAgICAgICAgICAgdGwgKz0gNDYgKyBmLmYubGVuZ3RoICsgZXhmbChmLmV4dHJhKSArIChmLm8gPyBmLm8ubGVuZ3RoIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IG5ldyB1OCh0bCArIDIyKTtcbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMudTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gX2NbX2JdO1xuICAgICAgICAgICAgd3poKG91dCwgYnQsIGYsIGYuZiwgZi51LCBmLmMsIGwsIGYubyk7XG4gICAgICAgICAgICBidCArPSA0NiArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpICsgKGYubyA/IGYuby5sZW5ndGggOiAwKSwgbCArPSBmLmI7XG4gICAgICAgIH1cbiAgICAgICAgd3pmKG91dCwgYnQsIHRoaXMudS5sZW5ndGgsIHRsLCBsKTtcbiAgICAgICAgdGhpcy5vbmRhdGEobnVsbCwgb3V0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5kID0gMjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWV0aG9kIHRvIHRlcm1pbmF0ZSBhbnkgaW50ZXJuYWwgd29ya2VycyB1c2VkIGJ5IHRoZSBzdHJlYW0uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byBhZGQoKSB3aWxsIGZhaWwuXG4gICAgICovXG4gICAgWmlwLnByb3RvdHlwZS50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnU7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9hW19pXTtcbiAgICAgICAgICAgIGYudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZCA9IDI7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwO1xufSgpKTtcbmV4cG9ydCB7IFppcCB9O1xuZXhwb3J0IGZ1bmN0aW9uIHppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICB2YXIgciA9IHt9O1xuICAgIGZsdG4oZGF0YSwgJycsIHIsIG9wdHMpO1xuICAgIHZhciBrID0gT2JqZWN0LmtleXMocik7XG4gICAgdmFyIGxmdCA9IGsubGVuZ3RoLCBvID0gMCwgdG90ID0gMDtcbiAgICB2YXIgc2xmdCA9IGxmdCwgZmlsZXMgPSBuZXcgQXJyYXkobGZ0KTtcbiAgICB2YXIgdGVybSA9IFtdO1xuICAgIHZhciB0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlcm0ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0ZXJtW2ldKCk7XG4gICAgfTtcbiAgICB2YXIgY2JmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IHU4KHRvdCArIDIyKSwgb2UgPSBvLCBjZGwgPSB0b3QgLSBvO1xuICAgICAgICB0b3QgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsZnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmaWxlc1tpXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBmLmMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHd6aChvdXQsIHRvdCwgZiwgZi5mLCBmLnUsIGwpO1xuICAgICAgICAgICAgICAgIHZhciBiYWRkID0gMzAgKyBmLmYubGVuZ3RoICsgZXhmbChmLmV4dHJhKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jID0gdG90ICsgYmFkZDtcbiAgICAgICAgICAgICAgICBvdXQuc2V0KGYuYywgbG9jKTtcbiAgICAgICAgICAgICAgICB3emgob3V0LCBvLCBmLCBmLmYsIGYudSwgbCwgdG90LCBmLm0pLCBvICs9IDE2ICsgYmFkZCArIChmLm0gPyBmLm0ubGVuZ3RoIDogMCksIHRvdCA9IGxvYyArIGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3emYob3V0LCBvLCBmaWxlcy5sZW5ndGgsIGNkbCwgb2UpO1xuICAgICAgICBjYihudWxsLCBvdXQpO1xuICAgIH07XG4gICAgaWYgKCFsZnQpXG4gICAgICAgIGNiZigpO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIGZuID0ga1tpXTtcbiAgICAgICAgdmFyIF9hID0gcltmbl0sIGZpbGUgPSBfYVswXSwgcCA9IF9hWzFdO1xuICAgICAgICB2YXIgYyA9IGNyYygpLCBzaXplID0gZmlsZS5sZW5ndGg7XG4gICAgICAgIGMucChmaWxlKTtcbiAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZuKSwgcyA9IGYubGVuZ3RoO1xuICAgICAgICB2YXIgY29tID0gcC5jb21tZW50LCBtID0gY29tICYmIHN0clRvVTgoY29tKSwgbXMgPSBtICYmIG0ubGVuZ3RoO1xuICAgICAgICB2YXIgZXhsID0gZXhmbChwLmV4dHJhKTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gcC5sZXZlbCA9PSAwID8gMCA6IDg7XG4gICAgICAgIHZhciBjYmwgPSBmdW5jdGlvbiAoZSwgZCkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICB0QWxsKCk7XG4gICAgICAgICAgICAgICAgY2IoZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZpbGVzW2ldID0gbXJnKHAsIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgY3JjOiBjLmQoKSxcbiAgICAgICAgICAgICAgICAgICAgYzogZCxcbiAgICAgICAgICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgICAgICAgICAgbTogbSxcbiAgICAgICAgICAgICAgICAgICAgdTogcyAhPSBmbi5sZW5ndGggfHwgKG0gJiYgKGNvbS5sZW5ndGggIT0gbXMpKSxcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb246IGNvbXByZXNzaW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbyArPSAzMCArIHMgKyBleGwgKyBsO1xuICAgICAgICAgICAgICAgIHRvdCArPSA3NiArIDIgKiAocyArIGV4bCkgKyAobXMgfHwgMCkgKyBsO1xuICAgICAgICAgICAgICAgIGlmICghLS1sZnQpXG4gICAgICAgICAgICAgICAgICAgIGNiZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAocyA+IDY1NTM1KVxuICAgICAgICAgICAgY2JsKCdmaWxlbmFtZSB0b28gbG9uZycsIG51bGwpO1xuICAgICAgICBpZiAoIWNvbXByZXNzaW9uKVxuICAgICAgICAgICAgY2JsKG51bGwsIGZpbGUpO1xuICAgICAgICBlbHNlIGlmIChzaXplIDwgMTYwMDAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNibChudWxsLCBkZWZsYXRlU3luYyhmaWxlLCBwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNibChlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ZXJtLnB1c2goZGVmbGF0ZShmaWxlLCBwLCBjYmwpKTtcbiAgICB9O1xuICAgIC8vIENhbm5vdCB1c2UgbGZ0IGJlY2F1c2UgaXQgY2FuIGRlY3JlYXNlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGZ0OyArK2kpIHtcbiAgICAgICAgX2xvb3BfMShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRBbGw7XG59XG4vKipcbiAqIFN5bmNocm9ub3VzbHkgY3JlYXRlcyBhIFpJUCBmaWxlLiBQcmVmZXIgdXNpbmcgYHppcGAgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICogd2l0aCBtb3JlIHRoYW4gb25lIGZpbGUuXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGlyZWN0b3J5IHN0cnVjdHVyZSBmb3IgdGhlIFpJUCBhcmNoaXZlXG4gKiBAcGFyYW0gb3B0cyBUaGUgbWFpbiBvcHRpb25zLCBtZXJnZWQgd2l0aCBwZXItZmlsZSBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIFpJUCBhcmNoaXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6aXBTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpXG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB2YXIgciA9IHt9O1xuICAgIHZhciBmaWxlcyA9IFtdO1xuICAgIGZsdG4oZGF0YSwgJycsIHIsIG9wdHMpO1xuICAgIHZhciBvID0gMDtcbiAgICB2YXIgdG90ID0gMDtcbiAgICBmb3IgKHZhciBmbiBpbiByKSB7XG4gICAgICAgIHZhciBfYSA9IHJbZm5dLCBmaWxlID0gX2FbMF0sIHAgPSBfYVsxXTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gcC5sZXZlbCA9PSAwID8gMCA6IDg7XG4gICAgICAgIHZhciBmID0gc3RyVG9VOChmbiksIHMgPSBmLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbSA9IHAuY29tbWVudCwgbSA9IGNvbSAmJiBzdHJUb1U4KGNvbSksIG1zID0gbSAmJiBtLmxlbmd0aDtcbiAgICAgICAgdmFyIGV4bCA9IGV4ZmwocC5leHRyYSk7XG4gICAgICAgIGlmIChzID4gNjU1MzUpXG4gICAgICAgICAgICB0aHJvdyAnZmlsZW5hbWUgdG9vIGxvbmcnO1xuICAgICAgICB2YXIgZCA9IGNvbXByZXNzaW9uID8gZGVmbGF0ZVN5bmMoZmlsZSwgcCkgOiBmaWxlLCBsID0gZC5sZW5ndGg7XG4gICAgICAgIHZhciBjID0gY3JjKCk7XG4gICAgICAgIGMucChmaWxlKTtcbiAgICAgICAgZmlsZXMucHVzaChtcmcocCwge1xuICAgICAgICAgICAgc2l6ZTogZmlsZS5sZW5ndGgsXG4gICAgICAgICAgICBjcmM6IGMuZCgpLFxuICAgICAgICAgICAgYzogZCxcbiAgICAgICAgICAgIGY6IGYsXG4gICAgICAgICAgICBtOiBtLFxuICAgICAgICAgICAgdTogcyAhPSBmbi5sZW5ndGggfHwgKG0gJiYgKGNvbS5sZW5ndGggIT0gbXMpKSxcbiAgICAgICAgICAgIG86IG8sXG4gICAgICAgICAgICBjb21wcmVzc2lvbjogY29tcHJlc3Npb25cbiAgICAgICAgfSkpO1xuICAgICAgICBvICs9IDMwICsgcyArIGV4bCArIGw7XG4gICAgICAgIHRvdCArPSA3NiArIDIgKiAocyArIGV4bCkgKyAobXMgfHwgMCkgKyBsO1xuICAgIH1cbiAgICB2YXIgb3V0ID0gbmV3IHU4KHRvdCArIDIyKSwgb2UgPSBvLCBjZGwgPSB0b3QgLSBvO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGYgPSBmaWxlc1tpXTtcbiAgICAgICAgd3poKG91dCwgZi5vLCBmLCBmLmYsIGYudSwgZi5jLmxlbmd0aCk7XG4gICAgICAgIHZhciBiYWRkID0gMzAgKyBmLmYubGVuZ3RoICsgZXhmbChmLmV4dHJhKTtcbiAgICAgICAgb3V0LnNldChmLmMsIGYubyArIGJhZGQpO1xuICAgICAgICB3emgob3V0LCBvLCBmLCBmLmYsIGYudSwgZi5jLmxlbmd0aCwgZi5vLCBmLm0pLCBvICs9IDE2ICsgYmFkZCArIChmLm0gPyBmLm0ubGVuZ3RoIDogMCk7XG4gICAgfVxuICAgIHd6ZihvdXQsIG8sIGZpbGVzLmxlbmd0aCwgY2RsLCBvZSk7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3RyZWFtaW5nIHBhc3MtdGhyb3VnaCBkZWNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXNcbiAqL1xudmFyIFVuemlwUGFzc1Rocm91Z2ggPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW56aXBQYXNzVGhyb3VnaCgpIHtcbiAgICB9XG4gICAgVW56aXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmaW5hbCkge1xuICAgICAgICB0aGlzLm9uZGF0YShudWxsLCBkYXRhLCBmaW5hbCk7XG4gICAgfTtcbiAgICBVbnppcFBhc3NUaHJvdWdoLmNvbXByZXNzaW9uID0gMDtcbiAgICByZXR1cm4gVW56aXBQYXNzVGhyb3VnaDtcbn0oKSk7XG5leHBvcnQgeyBVbnppcFBhc3NUaHJvdWdoIH07XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlcy4gUHJlZmVyIEFzeW5jWmlwSW5mbGF0ZSBmb3JcbiAqIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqL1xudmFyIFVuemlwSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBkZWNvbXByZXNzaW9uIHRoYXQgY2FuIGJlIHVzZWQgaW4gWklQIGFyY2hpdmVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gVW56aXBJbmZsYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIHRoaXMuaSA9IG5ldyBJbmZsYXRlKGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpc18xLm9uZGF0YShudWxsLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFVuemlwSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmaW5hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pLnB1c2goZGF0YSwgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlLCBkYXRhLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVuemlwSW5mbGF0ZS5jb21wcmVzc2lvbiA9IDg7XG4gICAgcmV0dXJuIFVuemlwSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBVbnppcEluZmxhdGUgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgQXN5bmNVbnppcEluZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgZGVjb21wcmVzc2lvbiB0aGF0IGNhbiBiZSB1c2VkIGluIFpJUCBhcmNoaXZlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jVW56aXBJbmZsYXRlKF8sIHN6KSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKHN6IDwgMzIwMDAwKSB7XG4gICAgICAgICAgICB0aGlzLmkgPSBuZXcgSW5mbGF0ZShmdW5jdGlvbiAoZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmkgPSBuZXcgQXN5bmNJbmZsYXRlKGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpc18xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSA9IHRoaXMuaS50ZXJtaW5hdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXN5bmNVbnppcEluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmluYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaS50ZXJtaW5hdGUpXG4gICAgICAgICAgICBkYXRhID0gc2xjKGRhdGEsIDApO1xuICAgICAgICB0aGlzLmkucHVzaChkYXRhLCBmaW5hbCk7XG4gICAgfTtcbiAgICBBc3luY1VuemlwSW5mbGF0ZS5jb21wcmVzc2lvbiA9IDg7XG4gICAgcmV0dXJuIEFzeW5jVW56aXBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jVW56aXBJbmZsYXRlIH07XG4vKipcbiAqIEEgWklQIGFyY2hpdmUgZGVjb21wcmVzc2lvbiBzdHJlYW0gdGhhdCBlbWl0cyBmaWxlcyBhcyB0aGV5IGFyZSBkaXNjb3ZlcmVkXG4gKi9cbnZhciBVbnppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgWklQIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGEgZmlsZSBpbiB0aGUgWklQIGFyY2hpdmUgaXMgZm91bmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnppcChjYikge1xuICAgICAgICB0aGlzLm9uZmlsZSA9IGNiO1xuICAgICAgICB0aGlzLmsgPSBbXTtcbiAgICAgICAgdGhpcy5vID0ge1xuICAgICAgICAgICAgMDogVW56aXBQYXNzVGhyb3VnaFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnAgPSBldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgdW56aXBwZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgVW56aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLm9uZmlsZSlcbiAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgICAgIGlmICghdGhpcy5wKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIGlmICh0aGlzLmMgPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4odGhpcy5jLCBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHRvQWRkID0gY2h1bmsuc3ViYXJyYXkoMCwgbGVuKTtcbiAgICAgICAgICAgIHRoaXMuYyAtPSBsZW47XG4gICAgICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgICAgIHRoaXMuZC5wdXNoKHRvQWRkLCAhdGhpcy5jKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmtbMF0ucHVzaCh0b0FkZCk7XG4gICAgICAgICAgICBjaHVuayA9IGNodW5rLnN1YmFycmF5KGxlbik7XG4gICAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2goY2h1bmssIGZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmID0gMCwgaSA9IDAsIGlzID0gdm9pZCAwLCBidWYgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoIXRoaXMucC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnVmID0gY2h1bms7XG4gICAgICAgICAgICBlbHNlIGlmICghY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJ1ZiA9IHRoaXMucDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZiA9IG5ldyB1OCh0aGlzLnAubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBidWYuc2V0KHRoaXMucCksIGJ1Zi5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGwgPSBidWYubGVuZ3RoLCBvYyA9IHRoaXMuYywgYWRkID0gb2MgJiYgdGhpcy5kO1xuICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHZhciBzaWcgPSBiNChidWYsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChzaWcgPT0gMHg0MDM0QjUwKSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSAxLCBpcyA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmYgPSBiMihidWYsIGkgKyA2KSwgY21wXzEgPSBiMihidWYsIGkgKyA4KSwgdSA9IGJmICYgMjA0OCwgZGQgPSBiZiAmIDgsIGZubCA9IGIyKGJ1ZiwgaSArIDI2KSwgZXMgPSBiMihidWYsIGkgKyAyOCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsID4gaSArIDMwICsgZm5sICsgZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGtzXzIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5rLnVuc2hpZnQoY2hrc18yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjXzEgPSBiNChidWYsIGkgKyAxOCksIHN1XzEgPSBiNChidWYsIGkgKyAyMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5fMSA9IHN0ckZyb21VOChidWYuc3ViYXJyYXkoaSArIDMwLCBpICs9IDMwICsgZm5sKSwgIXUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjXzEgPT0gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gZGQgPyBbLTJdIDogejY0ZShidWYsIGkpLCBzY18xID0gX2FbMF0sIHN1XzEgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjXzEgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYyA9IHNjXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVfMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmbl8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjbXBfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVfMS5vbmRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjXzEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlXzEub25kYXRhKG51bGwsIGV0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3RyID0gX3RoaXNfMS5vW2NtcF8xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3RyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNtcF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xID0gc2NfMSA8IDAgPyBuZXcgY3RyKGZuXzEpIDogbmV3IGN0cihmbl8xLCBzY18xLCBzdV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS5vbmRhdGEgPSBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7IGZpbGVfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY2hrc18zID0gY2hrc18yOyBfaSA8IGNoa3NfMy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0ID0gY2hrc18zW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEucHVzaChkYXQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpc18xLmtbMF0gPT0gY2hrc18yICYmIF90aGlzXzEuYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpc18xLmQgPSBkXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLnB1c2goZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRfMSAmJiBkXzEudGVybWluYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NfMSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfMS5zaXplID0gc2NfMSwgZmlsZV8xLm9yaWdpbmFsU2l6ZSA9IHN1XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEub25maWxlKGZpbGVfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZyA9PSAweDgwNzRCNTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzID0gaSArPSAxMiArIChvYyA9PSAtMiAmJiA4KSwgZiA9IDMsIHRoaXNfMS5jID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lnID09IDB4MjAxNEI1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXMgPSBpIC09IDQsIGYgPSAzLCB0aGlzXzEuYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsIC0gNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnAgPSBldDtcbiAgICAgICAgICAgIGlmIChvYyA8IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ID0gZiA/IGJ1Zi5zdWJhcnJheSgwLCBpcyAtIDEyIC0gKG9jID09IC0yICYmIDgpIC0gKGI0KGJ1ZiwgaXMgLSAxNikgPT0gMHg4MDc0QjUwICYmIDQpKSA6IGJ1Zi5zdWJhcnJheSgwLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkKVxuICAgICAgICAgICAgICAgICAgICBhZGQucHVzaChkYXQsICEhZik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmtbKyhmID09IDIpXS5wdXNoKGRhdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZiAmIDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaChidWYuc3ViYXJyYXkoaSksIGZpbmFsKTtcbiAgICAgICAgICAgIHRoaXMucCA9IGJ1Zi5zdWJhcnJheShpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmMpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgemlwIGZpbGUnO1xuICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZGVjb2RlciB3aXRoIHRoZSBzdHJlYW0sIGFsbG93aW5nIGZvciBmaWxlcyBjb21wcmVzc2VkIHdpdGhcbiAgICAgKiB0aGUgY29tcHJlc3Npb24gdHlwZSBwcm92aWRlZCB0byBiZSBleHBhbmRlZCBjb3JyZWN0bHlcbiAgICAgKiBAcGFyYW0gZGVjb2RlciBUaGUgZGVjb2RlciBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIFVuemlwLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChkZWNvZGVyKSB7XG4gICAgICAgIHRoaXMub1tkZWNvZGVyLmNvbXByZXNzaW9uXSA9IGRlY29kZXI7XG4gICAgfTtcbiAgICByZXR1cm4gVW56aXA7XG59KCkpO1xuZXhwb3J0IHsgVW56aXAgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzbHkgZGVjb21wcmVzc2VzIGEgWklQIGFyY2hpdmVcbiAqIEBwYXJhbSBkYXRhIFRoZSByYXcgY29tcHJlc3NlZCBaSVAgZmlsZVxuICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdpdGggdGhlIGRlY29tcHJlc3NlZCBmaWxlc1xuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGltbWVkaWF0ZWx5IHRlcm1pbmF0ZSB0aGUgdW56aXBwaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnppcChkYXRhLCBjYikge1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICB2YXIgdGVybSA9IFtdO1xuICAgIHZhciB0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlcm0ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0ZXJtW2ldKCk7XG4gICAgfTtcbiAgICB2YXIgZmlsZXMgPSB7fTtcbiAgICB2YXIgZSA9IGRhdGEubGVuZ3RoIC0gMjI7XG4gICAgZm9yICg7IGI0KGRhdGEsIGUpICE9IDB4NjA1NEI1MDsgLS1lKSB7XG4gICAgICAgIGlmICghZSB8fCBkYXRhLmxlbmd0aCAtIGUgPiA2NTU1OCkge1xuICAgICAgICAgICAgY2IoJ2ludmFsaWQgemlwIGZpbGUnLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgdmFyIGxmdCA9IGIyKGRhdGEsIGUgKyA4KTtcbiAgICBpZiAoIWxmdClcbiAgICAgICAgY2IobnVsbCwge30pO1xuICAgIHZhciBjID0gbGZ0O1xuICAgIHZhciBvID0gYjQoZGF0YSwgZSArIDE2KTtcbiAgICB2YXIgeiA9IG8gPT0gNDI5NDk2NzI5NTtcbiAgICBpZiAoeikge1xuICAgICAgICBlID0gYjQoZGF0YSwgZSAtIDEyKTtcbiAgICAgICAgaWYgKGI0KGRhdGEsIGUpICE9IDB4NjA2NEI1MCkge1xuICAgICAgICAgICAgY2IoJ2ludmFsaWQgemlwIGZpbGUnLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjID0gbGZ0ID0gYjQoZGF0YSwgZSArIDMyKTtcbiAgICAgICAgbyA9IGI0KGRhdGEsIGUgKyA0OCk7XG4gICAgfVxuICAgIHZhciBfbG9vcF8zID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIF9hID0gemgoZGF0YSwgbywgeiksIGNfMSA9IF9hWzBdLCBzYyA9IF9hWzFdLCBzdSA9IF9hWzJdLCBmbiA9IF9hWzNdLCBubyA9IF9hWzRdLCBvZmYgPSBfYVs1XSwgYiA9IHNsemgoZGF0YSwgb2ZmKTtcbiAgICAgICAgbyA9IG5vO1xuICAgICAgICB2YXIgY2JsID0gZnVuY3Rpb24gKGUsIGQpIHtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgdEFsbCgpO1xuICAgICAgICAgICAgICAgIGNiKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsZXNbZm5dID0gZDtcbiAgICAgICAgICAgICAgICBpZiAoIS0tbGZ0KVxuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBmaWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghY18xKVxuICAgICAgICAgICAgY2JsKG51bGwsIHNsYyhkYXRhLCBiLCBiICsgc2MpKTtcbiAgICAgICAgZWxzZSBpZiAoY18xID09IDgpIHtcbiAgICAgICAgICAgIHZhciBpbmZsID0gZGF0YS5zdWJhcnJheShiLCBiICsgc2MpO1xuICAgICAgICAgICAgaWYgKHNjIDwgMzIwMDAwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2JsKG51bGwsIGluZmxhdGVTeW5jKGluZmwsIG5ldyB1OChzdSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2JsKGUsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0ZXJtLnB1c2goaW5mbGF0ZShpbmZsLCB7IHNpemU6IHN1IH0sIGNibCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNibCgndW5rbm93biBjb21wcmVzc2lvbiB0eXBlICcgKyBjXzEsIG51bGwpO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyArK2kpIHtcbiAgICAgICAgX2xvb3BfMyhpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRBbGw7XG59XG4vKipcbiAqIFN5bmNocm9ub3VzbHkgZGVjb21wcmVzc2VzIGEgWklQIGFyY2hpdmUuIFByZWZlciB1c2luZyBgdW56aXBgIGZvciBiZXR0ZXJcbiAqIHBlcmZvcm1hbmNlIHdpdGggbW9yZSB0aGFuIG9uZSBmaWxlLlxuICogQHBhcmFtIGRhdGEgVGhlIHJhdyBjb21wcmVzc2VkIFpJUCBmaWxlXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIGZpbGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnppcFN5bmMoZGF0YSkge1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBlID0gZGF0YS5sZW5ndGggLSAyMjtcbiAgICBmb3IgKDsgYjQoZGF0YSwgZSkgIT0gMHg2MDU0QjUwOyAtLWUpIHtcbiAgICAgICAgaWYgKCFlIHx8IGRhdGEubGVuZ3RoIC0gZSA+IDY1NTU4KVxuICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgemlwIGZpbGUnO1xuICAgIH1cbiAgICA7XG4gICAgdmFyIGMgPSBiMihkYXRhLCBlICsgOCk7XG4gICAgaWYgKCFjKVxuICAgICAgICByZXR1cm4ge307XG4gICAgdmFyIG8gPSBiNChkYXRhLCBlICsgMTYpO1xuICAgIHZhciB6ID0gbyA9PSA0Mjk0OTY3Mjk1O1xuICAgIGlmICh6KSB7XG4gICAgICAgIGUgPSBiNChkYXRhLCBlIC0gMTIpO1xuICAgICAgICBpZiAoYjQoZGF0YSwgZSkgIT0gMHg2MDY0QjUwKVxuICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgemlwIGZpbGUnO1xuICAgICAgICBjID0gYjQoZGF0YSwgZSArIDMyKTtcbiAgICAgICAgbyA9IGI0KGRhdGEsIGUgKyA0OCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYzsgKytpKSB7XG4gICAgICAgIHZhciBfYSA9IHpoKGRhdGEsIG8sIHopLCBjXzIgPSBfYVswXSwgc2MgPSBfYVsxXSwgc3UgPSBfYVsyXSwgZm4gPSBfYVszXSwgbm8gPSBfYVs0XSwgb2ZmID0gX2FbNV0sIGIgPSBzbHpoKGRhdGEsIG9mZik7XG4gICAgICAgIG8gPSBubztcbiAgICAgICAgaWYgKCFjXzIpXG4gICAgICAgICAgICBmaWxlc1tmbl0gPSBzbGMoZGF0YSwgYiwgYiArIHNjKTtcbiAgICAgICAgZWxzZSBpZiAoY18yID09IDgpXG4gICAgICAgICAgICBmaWxlc1tmbl0gPSBpbmZsYXRlU3luYyhkYXRhLnN1YmFycmF5KGIsIGIgKyBzYyksIG5ldyB1OChzdSkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyAndW5rbm93biBjb21wcmVzc2lvbiB0eXBlICcgKyBjXzI7XG4gICAgfVxuICAgIHJldHVybiBmaWxlcztcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVSZXF1aXJlIiwicmVxdWlyZSIsIldvcmtlciIsIndvcmtlckFkZCIsImUiLCJ3ayIsImMiLCJfIiwibXNnIiwidHJhbnNmZXIiLCJjYiIsImRvbmUiLCJ3IiwiZXZhbCIsIm9uIiwibSIsIkVycm9yIiwicG9zdE1lc3NhZ2UiLCJ0ZXJtaW5hdGUiLCJwcm90b3R5cGUiLCJjYWxsIiwiX18iLCJfX18iLCJfX19fIiwic2V0SW1tZWRpYXRlIiwiTk9QIiwidTgiLCJVaW50OEFycmF5IiwidTE2IiwiVWludDE2QXJyYXkiLCJ1MzIiLCJVaW50MzJBcnJheSIsImZsZWIiLCJmZGViIiwiY2xpbSIsImZyZWIiLCJlYiIsInN0YXJ0IiwiYiIsImkiLCJyIiwiaiIsIl9hIiwiZmwiLCJyZXZmbCIsIl9iIiwiZmQiLCJyZXZmZCIsInJldiIsIngiLCJoTWFwIiwiY2QiLCJtYiIsInMiLCJsZW5ndGgiLCJsIiwibGUiLCJjbyIsInJ2YiIsInN2Iiwicl8xIiwidiIsImZsdCIsImZkdCIsImZsbSIsImZscm0iLCJmZG0iLCJmZHJtIiwibWF4IiwiYSIsImJpdHMiLCJkIiwicCIsIm8iLCJiaXRzMTYiLCJzaGZ0Iiwic2xjIiwibiIsInNldCIsInN1YmFycmF5IiwiaW5mbHQiLCJkYXQiLCJidWYiLCJzdCIsInNsIiwibm9CdWYiLCJub1N0IiwiY2J1ZiIsImJsIiwibmJ1ZiIsIk1hdGgiLCJmaW5hbCIsImYiLCJwb3MiLCJidCIsImxtIiwiZG0iLCJsYnQiLCJkYnQiLCJ0YnRzIiwidHlwZSIsInQiLCJoTGl0IiwiaGNMZW4iLCJ0bCIsImxkdCIsImNsdCIsImNsYiIsImNsYm1zayIsImNsbSIsImx0IiwiZHQiLCJsbXMiLCJkbXMiLCJscG9zIiwic3ltIiwiYWRkIiwiZHN5bSIsImVuZCIsIndiaXRzIiwid2JpdHMxNiIsImhUcmVlIiwicHVzaCIsInQyIiwic2xpY2UiLCJldCIsInNvcnQiLCJpMCIsImkxIiwiaTIiLCJtYXhTeW0iLCJ0ciIsIm1idCIsImxuIiwibGZ0IiwiY3N0IiwiaTJfMSIsImkyXzIiLCJpMl8zIiwibGMiLCJjbCIsImNsaSIsImNsbiIsImNscyIsImNsZW4iLCJjZiIsIndmYmxrIiwib3V0Iiwid2JsayIsInN5bXMiLCJsZiIsImRmIiwibGkiLCJicyIsImRsdCIsIm1sYiIsImRkdCIsIm1kYiIsIl9jIiwibGNsdCIsIm5sYyIsIl9kIiwibGNkdCIsIm5kYyIsImxjZnJlcSIsIl9lIiwibGN0IiwibWxjYiIsIm5sY2MiLCJmbGVuIiwiZnRsZW4iLCJkdGxlbiIsImxsIiwiZGwiLCJsbG0iLCJsY3RzIiwiaXQiLCJjbGN0IiwibGVuIiwiZHN0IiwiZGVvIiwiZGZsdCIsImx2bCIsInBsdmwiLCJwcmUiLCJwb3N0IiwibHN0IiwiY2VpbCIsIm9wdCIsIm1za18xIiwicHJldiIsImhlYWQiLCJiczFfMSIsImJzMl8xIiwiaHNoIiwibGNfMSIsIndpIiwiaHYiLCJpbW9kIiwicGltb2QiLCJyZW0iLCJjaF8xIiwiZGlmIiwibWF4biIsIm1pbiIsIm1heGQiLCJtbCIsIm5sIiwibW1kIiwibWQiLCJ0aSIsInB0aSIsImxpbiIsImRpbiIsImNyY3QiLCJJbnQzMkFycmF5IiwiayIsImNyYyIsImNyIiwiYWRsZXIiLCJkb3B0IiwibGV2ZWwiLCJtZW0iLCJsb2ciLCJtcmciLCJ3Y2xuIiwiZm4iLCJmblN0ciIsInRkIiwidG9TdHJpbmciLCJrcyIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsInJlcGxhY2UiLCJzcGxpdCIsInN0XzEiLCJzcEluZCIsImNoIiwiY2JmcyIsImNvbnN0cnVjdG9yIiwiYnVmZmVyIiwid3JrciIsImZucyIsImluaXQiLCJpZCIsInRkXzEiLCJiSW5mbHQiLCJpbmZsYXRlU3luYyIsInBiZiIsImd1OCIsImJEZmx0IiwiZGVmbGF0ZVN5bmMiLCJnemUiLCJnemgiLCJnemhsIiwid2J5dGVzIiwiZ3V6ZSIsImd6cyIsImd6bCIsInpsZSIsInpsaCIsInp1bGUiLCJ6bHYiLCJzaXplIiwiY2JpZnkiLCJvcHRzIiwiZXJyIiwiY29uc3VtZSIsImFzdHJtIiwic3RybSIsIm9uZGF0YSIsImV2IiwiZGF0YSIsImFzdHJtaWZ5IiwiYjIiLCJiNCIsImI4IiwiZmlsZW5hbWUiLCJtdGltZSIsImZsb29yIiwiRGF0ZSIsIm5vdyIsImNoYXJDb2RlQXQiLCJmbGciLCJ6cyIsImx2IiwiQXN5bmNDbXBTdHJtIiwiRGVmbGF0ZSIsImNodW5rIiwiQXN5bmNEZWZsYXRlIiwib25tZXNzYWdlIiwiZGVmbGF0ZSIsIkluZmxhdGUiLCJidHMiLCJBc3luY0luZmxhdGUiLCJpbmZsYXRlIiwiR3ppcCIsInJhdyIsIkFzeW5jR3ppcCIsImd6aXAiLCJnemlwU3luYyIsIkd1bnppcCIsIkFzeW5jR3VuemlwIiwiZ3VuemlwIiwiZ3VuemlwU3luYyIsIlpsaWIiLCJBc3luY1psaWIiLCJ6bGliIiwiemxpYlN5bmMiLCJVbnpsaWIiLCJBc3luY1VuemxpYiIsInVuemxpYiIsInVuemxpYlN5bmMiLCJjb21wcmVzcyIsIkFzeW5jQ29tcHJlc3MiLCJjb21wcmVzc1N5bmMiLCJDb21wcmVzcyIsIkRlY29tcHJlc3MiLCJHIiwiSSIsIloiLCJfdGhpc18xIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJBc3luY0RlY29tcHJlc3MiLCJkZWNvbXByZXNzIiwiZGVjb21wcmVzc1N5bmMiLCJmbHRuIiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwidGUiLCJUZXh0RW5jb2RlciIsIlRleHREZWNvZGVyIiwidGRzIiwiZGVjb2RlIiwic3RyZWFtIiwiZHV0ZjgiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJEZWNvZGVVVEY4IiwibnAiLCJFbmNvZGVVVEY4Iiwic3RyVG9VOCIsInN0ciIsImxhdGluMSIsImFyXzEiLCJlbmNvZGUiLCJhciIsImFpIiwic3RyRnJvbVU4IiwiZXh0IiwiZGJmIiwic2x6aCIsInpoIiwieiIsImZubCIsImVzIiwiejY0ZSIsInNjIiwic3UiLCJvZmYiLCJleGZsIiwiZXgiLCJ3emgiLCJ1IiwiY2UiLCJleHRyYSIsImNvbCIsImV4bCIsIm9zIiwiZmxhZyIsImNvbXByZXNzaW9uIiwieSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImF0dHJzIiwiZXhmIiwid3pmIiwiWmlwUGFzc1Rocm91Z2giLCJwcm9jZXNzIiwiWmlwRGVmbGF0ZSIsIkFzeW5jWmlwRGVmbGF0ZSIsIlppcCIsImZpbGUiLCJjb20iLCJjb21tZW50IiwiaGwiLCJoZWFkZXIiLCJjaGtzIiwicEFsbCIsIl9pIiwiY2hrc18xIiwiY2hrIiwiaW5kIiwidWYiLCJueHQiLCJkZCIsInNwbGljZSIsInppcCIsIk9iamVjdCIsImtleXMiLCJ0b3QiLCJzbGZ0IiwiZmlsZXMiLCJ0ZXJtIiwidEFsbCIsImNiZiIsIm9lIiwiY2RsIiwiYmFkZCIsImxvYyIsIl9sb29wXzEiLCJtcyIsImNibCIsInppcFN5bmMiLCJVbnppcFBhc3NUaHJvdWdoIiwiVW56aXBJbmZsYXRlIiwiQXN5bmNVbnppcEluZmxhdGUiLCJzeiIsIlVuemlwIiwib25maWxlIiwidG9BZGQiLCJpcyIsIm9jIiwiX2xvb3BfMiIsInNpZyIsInRoaXNfMSIsImJmIiwiY21wXzEiLCJjaGtzXzIiLCJ1bnNoaWZ0Iiwic2NfMSIsInN1XzEiLCJmbl8xIiwiZF8xIiwiZmlsZV8xIiwibmFtZSIsImN0ciIsImNoa3NfMyIsIm9yaWdpbmFsU2l6ZSIsInN0YXRlXzEiLCJyZWdpc3RlciIsImRlY29kZXIiLCJ1bnppcCIsIl9sb29wXzMiLCJjXzEiLCJubyIsImluZmwiLCJ1bnppcFN5bmMiLCJjXzIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-stdlib/objects/GroundProjectedEnv.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroundProjectedEnv: () => (/* binding */ GroundProjectedEnv)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst isCubeTexture = (def)=>def && def.isCubeTexture;\nclass GroundProjectedEnv extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n    constructor(texture, options){\n        var _a, _b;\n        const isCubeMap = isCubeTexture(texture);\n        const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n        const cubeSize = w / 4;\n        const _lodMax = Math.floor(Math.log2(cubeSize));\n        const _cubeSize = Math.pow(2, _lodMax);\n        const width = 3 * Math.max(_cubeSize, 16 * 7);\n        const height = 4 * _cubeSize;\n        const defines = [\n            isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n            `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n            `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n            `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n        ];\n        const vertexShader = /* glsl */ `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `;\n        const fragmentShader = defines.join(\"\\n\") + /* glsl */ `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n        const uniforms = {\n            map: {\n                value: texture\n            },\n            height: {\n                value: (options == null ? void 0 : options.height) || 15\n            },\n            radius: {\n                value: (options == null ? void 0 : options.radius) || 100\n            }\n        };\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(1, 16);\n        const material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n            uniforms,\n            fragmentShader,\n            vertexShader,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n        });\n        super(geometry, material);\n    }\n    set radius(radius) {\n        this.material.uniforms.radius.value = radius;\n    }\n    get radius() {\n        return this.material.uniforms.radius.value;\n    }\n    set height(height) {\n        this.material.uniforms.height.value = height;\n    }\n    get height() {\n        return this.material.uniforms.height.value;\n    }\n}\n //# sourceMappingURL=GroundProjectedEnv.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL29iamVjdHMvR3JvdW5kUHJvamVjdGVkRW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdGO0FBQ3hGLE1BQU1LLGdCQUFnQixDQUFDQyxNQUFRQSxPQUFPQSxJQUFJRCxhQUFhO0FBQ3ZELE1BQU1FLDJCQUEyQlAsdUNBQUlBO0lBQ25DUSxZQUFZQyxPQUFPLEVBQUVDLE9BQU8sQ0FBRTtRQUM1QixJQUFJQyxJQUFJQztRQUNSLE1BQU1DLFlBQVlSLGNBQWNJO1FBQ2hDLE1BQU1LLElBQUksQ0FBQ0YsS0FBS0MsWUFBWSxDQUFDRixLQUFLRixRQUFRTSxLQUFLLENBQUMsRUFBRSxLQUFLLE9BQU8sS0FBSyxJQUFJSixHQUFHSyxLQUFLLEdBQUdQLFFBQVFNLEtBQUssQ0FBQ0MsS0FBSyxLQUFLLE9BQU9KLEtBQUs7UUFDdEgsTUFBTUssV0FBV0gsSUFBSTtRQUNyQixNQUFNSSxVQUFVQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLElBQUksQ0FBQ0o7UUFDckMsTUFBTUssWUFBWUgsS0FBS0ksR0FBRyxDQUFDLEdBQUdMO1FBQzlCLE1BQU1GLFFBQVEsSUFBSUcsS0FBS0ssR0FBRyxDQUFDRixXQUFXLEtBQUs7UUFDM0MsTUFBTUcsU0FBUyxJQUFJSDtRQUNuQixNQUFNSSxVQUFVO1lBQ2RiLFlBQVksNkJBQTZCO1lBQ3pDLENBQUMsMkJBQTJCLEVBQUUsSUFBSUcsTUFBTSxDQUFDO1lBQ3pDLENBQUMsNEJBQTRCLEVBQUUsSUFBSVMsT0FBTyxDQUFDO1lBQzNDLENBQUMsdUJBQXVCLEVBQUVQLFFBQVEsRUFBRSxDQUFDO1NBQ3RDO1FBQ0QsTUFBTVMsZUFDSixRQUFRLEdBQ1IsQ0FBQzs7Ozs7Ozs7O1FBU0MsQ0FBQztRQUVMLE1BQU1DLGlCQUFpQkYsUUFBUUcsSUFBSSxDQUFDLFFBQVEsUUFBUSxHQUNwRCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBcUVpQixFQUFFQyxTQUFTN0IsMkNBQVFBLENBQUM4QixPQUFPLENBQUMsUUFBUSxRQUFRLE1BQU0sd0JBQXdCLHFCQUFxQjs7UUFFN0csQ0FBQztRQUNMLE1BQU1DLFdBQVc7WUFDZkMsS0FBSztnQkFBRUMsT0FBT3pCO1lBQVE7WUFDdEJnQixRQUFRO2dCQUFFUyxPQUFPLENBQUN4QixXQUFXLE9BQU8sS0FBSyxJQUFJQSxRQUFRZSxNQUFNLEtBQUs7WUFBRztZQUNuRVUsUUFBUTtnQkFBRUQsT0FBTyxDQUFDeEIsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUXlCLE1BQU0sS0FBSztZQUFJO1FBQ3RFO1FBQ0EsTUFBTUMsV0FBVyxJQUFJbEMsc0RBQW1CQSxDQUFDLEdBQUc7UUFDNUMsTUFBTW1DLFdBQVcsSUFBSWxDLGlEQUFjQSxDQUFDO1lBQ2xDNkI7WUFDQUo7WUFDQUQ7WUFDQVcsTUFBTWxDLDZDQUFVQTtRQUNsQjtRQUNBLEtBQUssQ0FBQ2dDLFVBQVVDO0lBQ2xCO0lBQ0EsSUFBSUYsT0FBT0EsTUFBTSxFQUFFO1FBQ2pCLElBQUksQ0FBQ0UsUUFBUSxDQUFDTCxRQUFRLENBQUNHLE1BQU0sQ0FBQ0QsS0FBSyxHQUFHQztJQUN4QztJQUNBLElBQUlBLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ0UsUUFBUSxDQUFDTCxRQUFRLENBQUNHLE1BQU0sQ0FBQ0QsS0FBSztJQUM1QztJQUNBLElBQUlULE9BQU9BLE1BQU0sRUFBRTtRQUNqQixJQUFJLENBQUNZLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDUCxNQUFNLENBQUNTLEtBQUssR0FBR1Q7SUFDeEM7SUFDQSxJQUFJQSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUNZLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDUCxNQUFNLENBQUNTLEtBQUs7SUFDNUM7QUFDRjtBQUdFLENBQ0YsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNyZWF0aXZlLXBvcnRmb2xpby1zdGFydGVyLWNvZGUtZmlsZXMvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL29iamVjdHMvR3JvdW5kUHJvamVjdGVkRW52LmpzPzYwYjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVzaCwgUkVWSVNJT04sIEljb3NhaGVkcm9uR2VvbWV0cnksIFNoYWRlck1hdGVyaWFsLCBEb3VibGVTaWRlIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCBpc0N1YmVUZXh0dXJlID0gKGRlZikgPT4gZGVmICYmIGRlZi5pc0N1YmVUZXh0dXJlO1xuY2xhc3MgR3JvdW5kUHJvamVjdGVkRW52IGV4dGVuZHMgTWVzaCB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGlzQ3ViZU1hcCA9IGlzQ3ViZVRleHR1cmUodGV4dHVyZSk7XG4gICAgY29uc3QgdyA9IChfYiA9IGlzQ3ViZU1hcCA/IChfYSA9IHRleHR1cmUuaW1hZ2VbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS53aWR0aCA6IHRleHR1cmUuaW1hZ2Uud2lkdGgpICE9IG51bGwgPyBfYiA6IDEwMjQ7XG4gICAgY29uc3QgY3ViZVNpemUgPSB3IC8gNDtcbiAgICBjb25zdCBfbG9kTWF4ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIoY3ViZVNpemUpKTtcbiAgICBjb25zdCBfY3ViZVNpemUgPSBNYXRoLnBvdygyLCBfbG9kTWF4KTtcbiAgICBjb25zdCB3aWR0aCA9IDMgKiBNYXRoLm1heChfY3ViZVNpemUsIDE2ICogNyk7XG4gICAgY29uc3QgaGVpZ2h0ID0gNCAqIF9jdWJlU2l6ZTtcbiAgICBjb25zdCBkZWZpbmVzID0gW1xuICAgICAgaXNDdWJlTWFwID8gXCIjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVcIiA6IFwiXCIsXG4gICAgICBgI2RlZmluZSBDVUJFVVZfVEVYRUxfV0lEVEggJHsxIC8gd2lkdGh9YCxcbiAgICAgIGAjZGVmaW5lIENVQkVVVl9URVhFTF9IRUlHSFQgJHsxIC8gaGVpZ2h0fWAsXG4gICAgICBgI2RlZmluZSBDVUJFVVZfTUFYX01JUCAke19sb2RNYXh9LjBgXG4gICAgXTtcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcbiAgICAgICAgdm9pZCBtYWluKCkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlYzQgd29ybGRQb3NpdGlvbiA9ICggbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICkgKTtcbiAgICAgICAgICAgIHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcbiAgICAgICAgfVxuICAgICAgICBgXG4gICAgKTtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGRlZmluZXMuam9pbihcIlxcblwiKSArIC8qIGdsc2wgKi9cbiAgICBgXG4gICAgICAgICNkZWZpbmUgRU5WTUFQX1RZUEVfQ1VCRV9VVlxuICAgICAgICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IGhlaWdodDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBhbmdsZTtcbiAgICAgICAgI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlckN1YmUgbWFwO1xuICAgICAgICAjZWxzZVxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xuICAgICAgICAjZW5kaWZcbiAgICAgICAgLy8gRnJvbTogaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3LzR0c0JEN1xuICAgICAgICBmbG9hdCBkaXNrSW50ZXJzZWN0V2l0aEJhY2tGYWNlQ3VsbGluZyggdmVjMyBybywgdmVjMyByZCwgdmVjMyBjLCB2ZWMzIG4sIGZsb2F0IHIgKSBcbiAgICAgICAge1xuICAgICAgICAgICAgZmxvYXQgZCA9IGRvdCAoIHJkLCBuICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBkID4gMC4wICkgeyByZXR1cm4gMWU2OyB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZlYzMgIG8gPSBybyAtIGM7XG4gICAgICAgICAgICBmbG9hdCB0ID0gLSBkb3QoIG4sIG8gKSAvIGQ7XG4gICAgICAgICAgICB2ZWMzICBxID0gbyArIHJkICogdDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuICggZG90KCBxLCBxICkgPCByICogciApID8gdCA6IDFlNjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGcm9tOiBodHRwczovL3d3dy5pcXVpbGV6bGVzLm9yZy93d3cvYXJ0aWNsZXMvaW50ZXJzZWN0b3JzL2ludGVyc2VjdG9ycy5odG1cbiAgICAgICAgZmxvYXQgc3BoZXJlSW50ZXJzZWN0KCB2ZWMzIHJvLCB2ZWMzIHJkLCB2ZWMzIGNlLCBmbG9hdCByYSApIFxuICAgICAgICB7XG4gICAgICAgICAgICB2ZWMzIG9jID0gcm8gLSBjZTtcbiAgICAgICAgICAgIGZsb2F0IGIgPSBkb3QoIG9jLCByZCApO1xuICAgICAgICAgICAgZmxvYXQgYyA9IGRvdCggb2MsIG9jICkgLSByYSAqIHJhO1xuICAgICAgICAgICAgZmxvYXQgaCA9IGIgKiBiIC0gYztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIGggPCAwLjAgKSB7IHJldHVybiAtMS4wOyB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGggPSBzcXJ0KCBoICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAtIGIgKyBoO1xuICAgICAgICB9XG4gICAgICAgIHZlYzMgcHJvamVjdCgpIFxuICAgICAgICB7XG4gICAgICAgICAgICB2ZWMzIHAgPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uICk7XG4gICAgICAgICAgICB2ZWMzIGNhbVBvcyA9IGNhbWVyYVBvc2l0aW9uO1xuICAgICAgICAgICAgY2FtUG9zLnkgLT0gaGVpZ2h0O1xuICAgICAgICAgICAgZmxvYXQgaW50ZXJzZWN0aW9uID0gc3BoZXJlSW50ZXJzZWN0KCBjYW1Qb3MsIHAsIHZlYzMoIDAuMCApLCByYWRpdXMgKTtcbiAgICAgICAgICAgIGlmKCBpbnRlcnNlY3Rpb24gPiAwLjAgKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmVjMyBoID0gdmVjMyggMC4wLCAtIGhlaWdodCwgMC4wICk7XG4gICAgICAgICAgICAgICAgZmxvYXQgaW50ZXJzZWN0aW9uMiA9IGRpc2tJbnRlcnNlY3RXaXRoQmFja0ZhY2VDdWxsaW5nKCBjYW1Qb3MsIHAsIGgsIHZlYzMoIDAuMCwgMS4wLCAwLjAgKSwgcmFkaXVzICk7XG4gICAgICAgICAgICAgICAgcCA9ICggY2FtUG9zICsgbWluKCBpbnRlcnNlY3Rpb24sIGludGVyc2VjdGlvbjIgKSAqIHAgKSAvIHJhZGl1cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHZlYzMoIDAuMCwgMS4wLCAwLjAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICAgICNpbmNsdWRlIDxjb21tb24+XG4gICAgICAgICNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XG4gICAgICAgIHZvaWQgbWFpbigpIFxuICAgICAgICB7XG4gICAgICAgICAgICB2ZWMzIHByb2plY3RlZFdvcmxkUG9zaXRpb24gPSBwcm9qZWN0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXG4gICAgICAgICAgICAgICAgdmVjMyBvdXRjb2xvciA9IHRleHR1cmVDdWJlKCBtYXAsIHByb2plY3RlZFdvcmxkUG9zaXRpb24gKS5yZ2I7XG4gICAgICAgICAgICAjZWxzZVxuICAgICAgICAgICAgICAgIHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCBwcm9qZWN0ZWRXb3JsZFBvc2l0aW9uICk7XG4gICAgICAgICAgICAgICAgdmVjMiB1diA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xuICAgICAgICAgICAgICAgIHZlYzMgb3V0Y29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdXYgKS5yZ2I7XG4gICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGNvbG9yLCAxLjAgKTtcbiAgICAgICAgICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cbiAgICAgICAgICAgICNpbmNsdWRlIDwke3BhcnNlSW50KFJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZywgXCJcIikpID49IDE1NCA/IFwiY29sb3JzcGFjZV9mcmFnbWVudFwiIDogXCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIG1hcDogeyB2YWx1ZTogdGV4dHVyZSB9LFxuICAgICAgaGVpZ2h0OiB7IHZhbHVlOiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWlnaHQpIHx8IDE1IH0sXG4gICAgICByYWRpdXM6IHsgdmFsdWU6IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnJhZGl1cykgfHwgMTAwIH1cbiAgICB9O1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEljb3NhaGVkcm9uR2VvbWV0cnkoMSwgMTYpO1xuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICB2ZXJ0ZXhTaGFkZXIsXG4gICAgICBzaWRlOiBEb3VibGVTaWRlXG4gICAgfSk7XG4gICAgc3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgfVxuICBzZXQgcmFkaXVzKHJhZGl1cykge1xuICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMucmFkaXVzLnZhbHVlID0gcmFkaXVzO1xuICB9XG4gIGdldCByYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMucmFkaXVzLnZhbHVlO1xuICB9XG4gIHNldCBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5oZWlnaHQudmFsdWUgPSBoZWlnaHQ7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5oZWlnaHQudmFsdWU7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEdyb3VuZFByb2plY3RlZEVudlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyb3VuZFByb2plY3RlZEVudi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJNZXNoIiwiUkVWSVNJT04iLCJJY29zYWhlZHJvbkdlb21ldHJ5IiwiU2hhZGVyTWF0ZXJpYWwiLCJEb3VibGVTaWRlIiwiaXNDdWJlVGV4dHVyZSIsImRlZiIsIkdyb3VuZFByb2plY3RlZEVudiIsImNvbnN0cnVjdG9yIiwidGV4dHVyZSIsIm9wdGlvbnMiLCJfYSIsIl9iIiwiaXNDdWJlTWFwIiwidyIsImltYWdlIiwid2lkdGgiLCJjdWJlU2l6ZSIsIl9sb2RNYXgiLCJNYXRoIiwiZmxvb3IiLCJsb2cyIiwiX2N1YmVTaXplIiwicG93IiwibWF4IiwiaGVpZ2h0IiwiZGVmaW5lcyIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwiam9pbiIsInBhcnNlSW50IiwicmVwbGFjZSIsInVuaWZvcm1zIiwibWFwIiwidmFsdWUiLCJyYWRpdXMiLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwic2lkZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key)=>obj[key];\n //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGFBQWEsQ0FBQ0MsS0FBS0MsTUFBUUQsR0FBRyxDQUFDQyxJQUFJO0FBR3ZDLENBQ0YsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNyZWF0aXZlLXBvcnRmb2xpby1zdGFydGVyLWNvZGUtZmlsZXMvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanM/MmY0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBnZXRXaXRoS2V5ID0gKG9iaiwga2V5KSA9PiBvYmpba2V5XTtcbmV4cG9ydCB7XG4gIGdldFdpdGhLZXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbImdldFdpdGhLZXkiLCJvYmoiLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups)=>{\n    const isIndexed = geometries[0].index !== null;\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    const attributes = {};\n    const morphAttributes = {};\n    const morphTargetsRelative = geometries[0].morphTargetsRelative;\n    const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    let offset = 0;\n    geometries.forEach((geom, i)=>{\n        let attributesCount = 0;\n        if (isIndexed !== (geom.index !== null)) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n            return null;\n        }\n        for(let name in geom.attributes){\n            if (!attributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n                return null;\n            }\n            if (attributes[name] === void 0) {\n                attributes[name] = [];\n            }\n            attributes[name].push(geom.attributes[name]);\n            attributesCount++;\n        }\n        if (attributesCount !== attributesUsed.size) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n            return null;\n        }\n        if (morphTargetsRelative !== geom.morphTargetsRelative) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n            return null;\n        }\n        for(let name in geom.morphAttributes){\n            if (!morphAttributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n                return null;\n            }\n            if (morphAttributes[name] === void 0) morphAttributes[name] = [];\n            morphAttributes[name].push(geom.morphAttributes[name]);\n        }\n        mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n        mergedGeometry.userData.mergedUserData.push(geom.userData);\n        if (useGroups) {\n            let count;\n            if (geom.index) {\n                count = geom.index.count;\n            } else if (geom.attributes.position !== void 0) {\n                count = geom.attributes.position.count;\n            } else {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n                return null;\n            }\n            mergedGeometry.addGroup(offset, count, i);\n            offset += count;\n        }\n    });\n    if (isIndexed) {\n        let indexOffset = 0;\n        const mergedIndex = [];\n        geometries.forEach((geom)=>{\n            const index = geom.index;\n            for(let j = 0; j < index.count; ++j){\n                mergedIndex.push(index.getX(j) + indexOffset);\n            }\n            indexOffset += geom.attributes.position.count;\n        });\n        mergedGeometry.setIndex(mergedIndex);\n    }\n    for(let name in attributes){\n        const mergedAttribute = mergeBufferAttributes(attributes[name]);\n        if (!mergedAttribute) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\");\n            return null;\n        }\n        mergedGeometry.setAttribute(name, mergedAttribute);\n    }\n    for(let name in morphAttributes){\n        const numMorphTargets = morphAttributes[name][0].length;\n        if (numMorphTargets === 0) break;\n        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n        mergedGeometry.morphAttributes[name] = [];\n        for(let i = 0; i < numMorphTargets; ++i){\n            const morphAttributesToMerge = [];\n            for(let j = 0; j < morphAttributes[name].length; ++j){\n                morphAttributesToMerge.push(morphAttributes[name][j][i]);\n            }\n            const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n            if (!mergedMorphAttribute) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n                return null;\n            }\n            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n        }\n    }\n    return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let itemSize = void 0;\n    let normalized = void 0;\n    let arrayLength = 0;\n    attributes.forEach((attr)=>{\n        if (TypedArray === void 0) {\n            TypedArray = attr.array.constructor;\n        }\n        if (TypedArray !== attr.array.constructor) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n            return null;\n        }\n        if (itemSize === void 0) itemSize = attr.itemSize;\n        if (itemSize !== attr.itemSize) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n            return null;\n        }\n        if (normalized === void 0) normalized = attr.normalized;\n        if (normalized !== attr.normalized) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n            return null;\n        }\n        arrayLength += attr.array.length;\n    });\n    if (TypedArray && itemSize) {\n        const array = new TypedArray(arrayLength);\n        let offset = 0;\n        attributes.forEach((attr)=>{\n            array.set(attr.array, offset);\n            offset += attr.array.length;\n        });\n        return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n    }\n};\nconst interleaveAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let arrayLength = 0;\n    let stride = 0;\n    for(let i = 0, l = attributes.length; i < l; ++i){\n        const attribute = attributes[i];\n        if (TypedArray === void 0) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n            console.error(\"AttributeBuffers of different types cannot be interleaved\");\n            return null;\n        }\n        arrayLength += attribute.array.length;\n        stride += attribute.itemSize;\n    }\n    const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n    let offset = 0;\n    const res = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    const setters = [\n        \"setX\",\n        \"setY\",\n        \"setZ\",\n        \"setW\"\n    ];\n    for(let j = 0, l = attributes.length; j < l; j++){\n        const attribute = attributes[j];\n        const itemSize = attribute.itemSize;\n        const count = attribute.count;\n        const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n        res.push(iba);\n        offset += itemSize;\n        for(let c = 0; c < count; c++){\n            for(let k = 0; k < itemSize; k++){\n                const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n                const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n                set(c, get(c));\n            }\n        }\n    }\n    return res;\n};\nfunction estimateBytesUsed(geometry) {\n    let mem = 0;\n    for(let name in geometry.attributes){\n        const attr = geometry.getAttribute(name);\n        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n    const indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n    tolerance = Math.max(tolerance, Number.EPSILON);\n    const hashToIndex = {};\n    const indices = geometry.getIndex();\n    const positions = geometry.getAttribute(\"position\");\n    const vertexCount = indices ? indices.count : positions.count;\n    let nextIndex = 0;\n    const attributeNames = Object.keys(geometry.attributes);\n    const attrArrays = {};\n    const morphAttrsArrays = {};\n    const newIndices = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        attrArrays[name] = [];\n        const morphAttr = geometry.morphAttributes[name];\n        if (morphAttr) {\n            morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(()=>[]);\n        }\n    }\n    const decimalShift = Math.log10(1 / tolerance);\n    const shiftMultiplier = Math.pow(10, decimalShift);\n    for(let i = 0; i < vertexCount; i++){\n        const index = indices ? indices.getX(i) : i;\n        let hash = \"\";\n        for(let j = 0, l = attributeNames.length; j < l; j++){\n            const name = attributeNames[j];\n            const attribute = geometry.getAttribute(name);\n            const itemSize = attribute.itemSize;\n            for(let k = 0; k < itemSize; k++){\n                hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n            }\n        }\n        if (hash in hashToIndex) {\n            newIndices.push(hashToIndex[hash]);\n        } else {\n            for(let j = 0, l = attributeNames.length; j < l; j++){\n                const name = attributeNames[j];\n                const attribute = geometry.getAttribute(name);\n                const morphAttr = geometry.morphAttributes[name];\n                const itemSize = attribute.itemSize;\n                const newarray = attrArrays[name];\n                const newMorphArrays = morphAttrsArrays[name];\n                for(let k = 0; k < itemSize; k++){\n                    const getterFunc = getters[k];\n                    newarray.push(attribute[getterFunc](index));\n                    if (morphAttr) {\n                        for(let m = 0, ml = morphAttr.length; m < ml; m++){\n                            newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n                        }\n                    }\n                }\n            }\n            hashToIndex[hash] = nextIndex;\n            newIndices.push(nextIndex);\n            nextIndex++;\n        }\n    }\n    const result = geometry.clone();\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        const oldAttribute = geometry.getAttribute(name);\n        const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n        const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n        result.setAttribute(name, attribute);\n        if (name in morphAttrsArrays) {\n            for(let j = 0; j < morphAttrsArrays[name].length; j++){\n                const oldMorphAttribute = geometry.morphAttributes[name][j];\n                const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n                const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n                result.morphAttributes[name][j] = morphAttribute;\n            }\n        }\n    }\n    result.setIndex(newIndices);\n    return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n        console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n        return geometry;\n    }\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n        let index = geometry.getIndex();\n        if (index === null) {\n            const indices = [];\n            const position = geometry.getAttribute(\"position\");\n            if (position !== void 0) {\n                for(let i = 0; i < position.count; i++){\n                    indices.push(i);\n                }\n                geometry.setIndex(indices);\n                index = geometry.getIndex();\n            } else {\n                console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n                return geometry;\n            }\n        }\n        const numberOfTriangles = index.count - 2;\n        const newIndices = [];\n        if (index) {\n            if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n                for(let i = 1; i <= numberOfTriangles; i++){\n                    newIndices.push(index.getX(0));\n                    newIndices.push(index.getX(i));\n                    newIndices.push(index.getX(i + 1));\n                }\n            } else {\n                for(let i = 0; i < numberOfTriangles; i++){\n                    if (i % 2 === 0) {\n                        newIndices.push(index.getX(i));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i + 2));\n                    } else {\n                        newIndices.push(index.getX(i + 2));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i));\n                    }\n                }\n            }\n        }\n        if (newIndices.length / 3 !== numberOfTriangles) {\n            console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n        }\n        const newGeometry = geometry.clone();\n        newGeometry.setIndex(newIndices);\n        newGeometry.clearGroups();\n        return newGeometry;\n    } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n        return geometry;\n    }\n}\nfunction computeMorphedAttributes(object) {\n    if (object.geometry.isBufferGeometry !== true) {\n        console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n        return null;\n    }\n    const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n        _vA.fromBufferAttribute(attribute, a2);\n        _vB.fromBufferAttribute(attribute, b2);\n        _vC.fromBufferAttribute(attribute, c2);\n        const morphInfluences = object2.morphTargetInfluences;\n        if (// @ts-ignore\n        material2.morphTargets && morphAttribute && morphInfluences) {\n            _morphA.set(0, 0, 0);\n            _morphB.set(0, 0, 0);\n            _morphC.set(0, 0, 0);\n            for(let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++){\n                const influence = morphInfluences[i2];\n                const morph = morphAttribute[i2];\n                if (influence === 0) continue;\n                _tempA.fromBufferAttribute(morph, a2);\n                _tempB.fromBufferAttribute(morph, b2);\n                _tempC.fromBufferAttribute(morph, c2);\n                if (morphTargetsRelative2) {\n                    _morphA.addScaledVector(_tempA, influence);\n                    _morphB.addScaledVector(_tempB, influence);\n                    _morphC.addScaledVector(_tempC, influence);\n                } else {\n                    _morphA.addScaledVector(_tempA.sub(_vA), influence);\n                    _morphB.addScaledVector(_tempB.sub(_vB), influence);\n                    _morphC.addScaledVector(_tempC.sub(_vC), influence);\n                }\n            }\n            _vA.add(_morphA);\n            _vB.add(_morphB);\n            _vC.add(_morphC);\n        }\n        if (object2.isSkinnedMesh) {\n            object2.boneTransform(a2, _vA);\n            object2.boneTransform(b2, _vB);\n            object2.boneTransform(c2, _vC);\n        }\n        modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n        modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n        modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n        modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n        modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n        modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n        modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n        modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n        modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n    }\n    const geometry = object.geometry;\n    const material = object.material;\n    let a, b, c;\n    const index = geometry.index;\n    const positionAttribute = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const normalAttribute = geometry.attributes.normal;\n    const morphNormal = geometry.morphAttributes.position;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    let i, j, il, jl;\n    let group, groupMaterial;\n    let start, end;\n    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n    if (index !== null) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = index.getX(j);\n                    b = index.getX(j + 1);\n                    c = index.getX(j + 2);\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(index.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = index.getX(i);\n                b = index.getX(i + 1);\n                c = index.getX(i + 2);\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    } else if (positionAttribute !== void 0) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = j;\n                    b = j + 1;\n                    c = j + 2;\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = i;\n                b = i + 1;\n                c = i + 2;\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    }\n    const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n    const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n    return {\n        positionAttribute,\n        normalAttribute,\n        morphedPositionAttribute,\n        morphedNormalAttribute\n    };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n    const creaseDot = Math.cos(creaseAngle);\n    const hashMultiplier = (1 + 1e-10) * 100;\n    const verts = [\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n    ];\n    const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function hashVertex(v) {\n        const x = ~~(v.x * hashMultiplier);\n        const y = ~~(v.y * hashMultiplier);\n        const z = ~~(v.z * hashMultiplier);\n        return `${x},${y},${z}`;\n    }\n    const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n    const posAttr = resultGeometry.attributes.position;\n    const vertexMap = {};\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            if (!(hash in vertexMap)) {\n                vertexMap[hash] = [];\n            }\n            vertexMap[hash].push(normal);\n        }\n    }\n    const normalArray = new Float32Array(posAttr.count * 3);\n    const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            const otherNormals = vertexMap[hash];\n            tempNorm2.set(0, 0, 0);\n            for(let k = 0, lk = otherNormals.length; k < lk; k++){\n                const otherNorm = otherNormals[k];\n                if (tempNorm.dot(otherNorm) > creaseDot) {\n                    tempNorm2.add(otherNorm);\n                }\n            }\n            tempNorm2.normalize();\n            normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n        }\n    }\n    resultGeometry.setAttribute(\"normal\", normAttr);\n    return resultGeometry;\n}\n //# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRCxNQUFNVSx3QkFBd0IsQ0FBQ0MsWUFBWUM7SUFDekMsTUFBTUMsWUFBWUYsVUFBVSxDQUFDLEVBQUUsQ0FBQ0csS0FBSyxLQUFLO0lBQzFDLE1BQU1DLGlCQUFpQixJQUFJQyxJQUFJQyxPQUFPQyxJQUFJLENBQUNQLFVBQVUsQ0FBQyxFQUFFLENBQUNRLFVBQVU7SUFDbkUsTUFBTUMsc0JBQXNCLElBQUlKLElBQUlDLE9BQU9DLElBQUksQ0FBQ1AsVUFBVSxDQUFDLEVBQUUsQ0FBQ1UsZUFBZTtJQUM3RSxNQUFNRixhQUFhLENBQUM7SUFDcEIsTUFBTUUsa0JBQWtCLENBQUM7SUFDekIsTUFBTUMsdUJBQXVCWCxVQUFVLENBQUMsRUFBRSxDQUFDVyxvQkFBb0I7SUFDL0QsTUFBTUMsaUJBQWlCLElBQUl2QixpREFBY0E7SUFDekMsSUFBSXdCLFNBQVM7SUFDYmIsV0FBV2MsT0FBTyxDQUFDLENBQUNDLE1BQU1DO1FBQ3hCLElBQUlDLGtCQUFrQjtRQUN0QixJQUFJZixjQUFlYSxDQUFBQSxLQUFLWixLQUFLLEtBQUssSUFBRyxHQUFJO1lBQ3ZDZSxRQUFRQyxLQUFLLENBQ1gsdUZBQXVGSCxJQUFJO1lBRTdGLE9BQU87UUFDVDtRQUNBLElBQUssSUFBSUksUUFBUUwsS0FBS1AsVUFBVSxDQUFFO1lBQ2hDLElBQUksQ0FBQ0osZUFBZWlCLEdBQUcsQ0FBQ0QsT0FBTztnQkFDN0JGLFFBQVFDLEtBQUssQ0FDWCx1RkFBdUZILElBQUksa0VBQWtFSSxPQUFPO2dCQUV0SyxPQUFPO1lBQ1Q7WUFDQSxJQUFJWixVQUFVLENBQUNZLEtBQUssS0FBSyxLQUFLLEdBQUc7Z0JBQy9CWixVQUFVLENBQUNZLEtBQUssR0FBRyxFQUFFO1lBQ3ZCO1lBQ0FaLFVBQVUsQ0FBQ1ksS0FBSyxD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c3RhcnRlci1jb2RlLWZpbGVzLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi91dGlscy9CdWZmZXJHZW9tZXRyeVV0aWxzLmpzPzEyZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckF0dHJpYnV0ZSwgSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBUcmlhbmdsZXNEcmF3TW9kZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBWZWN0b3IzLCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyBnZXRXaXRoS2V5IH0gZnJvbSBcIi4uL3R5cGVzL2hlbHBlcnMuanNcIjtcbmNvbnN0IG1lcmdlQnVmZmVyR2VvbWV0cmllcyA9IChnZW9tZXRyaWVzLCB1c2VHcm91cHMpID0+IHtcbiAgY29uc3QgaXNJbmRleGVkID0gZ2VvbWV0cmllc1swXS5pbmRleCAhPT0gbnVsbDtcbiAgY29uc3QgYXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGdlb21ldHJpZXNbMF0uYXR0cmlidXRlcykpO1xuICBjb25zdCBtb3JwaEF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhnZW9tZXRyaWVzWzBdLm1vcnBoQXR0cmlidXRlcykpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJpZXNbMF0ubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gIGNvbnN0IG1lcmdlZEdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20sIGkpID0+IHtcbiAgICBsZXQgYXR0cmlidXRlc0NvdW50ID0gMDtcbiAgICBpZiAoaXNJbmRleGVkICE9PSAoZ2VvbS5pbmRleCAhPT0gbnVsbCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgaW5kZXggYXR0cmlidXRlIGV4aXN0cyBhbW9uZyBhbGwgZ2VvbWV0cmllcywgb3IgaW4gbm9uZSBvZiB0aGVtLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IG5hbWUgaW4gZ2VvbS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIWF0dHJpYnV0ZXNVc2VkLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArICcuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBcIicgKyBuYW1lICsgJ1wiIGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZXNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzW25hbWVdLnB1c2goZ2VvbS5hdHRyaWJ1dGVzW25hbWVdKTtcbiAgICAgIGF0dHJpYnV0ZXNDb3VudCsrO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlc0NvdW50ICE9PSBhdHRyaWJ1dGVzVXNlZC5zaXplKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gTWFrZSBzdXJlIGFsbCBnZW9tZXRyaWVzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlICE9PSBnZW9tLm1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gLm1vcnBoVGFyZ2V0c1JlbGF0aXZlIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IG5hbWUgaW4gZ2VvbS5tb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghbW9ycGhBdHRyaWJ1dGVzVXNlZC5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gIC5tb3JwaEF0dHJpYnV0ZXMgbXVzdCBiZSBjb25zaXN0ZW50IHRocm91Z2hvdXQgYWxsIGdlb21ldHJpZXMuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobW9ycGhBdHRyaWJ1dGVzW25hbWVdID09PSB2b2lkIDApXG4gICAgICAgIG1vcnBoQXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgICAgbW9ycGhBdHRyaWJ1dGVzW25hbWVdLnB1c2goZ2VvbS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIH1cbiAgICBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YSA9IG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhIHx8IFtdO1xuICAgIG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhLnB1c2goZ2VvbS51c2VyRGF0YSk7XG4gICAgaWYgKHVzZUdyb3Vwcykge1xuICAgICAgbGV0IGNvdW50O1xuICAgICAgaWYgKGdlb20uaW5kZXgpIHtcbiAgICAgICAgY291bnQgPSBnZW9tLmluZGV4LmNvdW50O1xuICAgICAgfSBlbHNlIGlmIChnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBjb3VudCA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIFRoZSBnZW9tZXRyeSBtdXN0IGhhdmUgZWl0aGVyIGFuIGluZGV4IG9yIGEgcG9zaXRpb24gYXR0cmlidXRlXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtZXJnZWRHZW9tZXRyeS5hZGRHcm91cChvZmZzZXQsIGNvdW50LCBpKTtcbiAgICAgIG9mZnNldCArPSBjb3VudDtcbiAgICB9XG4gIH0pO1xuICBpZiAoaXNJbmRleGVkKSB7XG4gICAgbGV0IGluZGV4T2Zmc2V0ID0gMDtcbiAgICBjb25zdCBtZXJnZWRJbmRleCA9IFtdO1xuICAgIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBnZW9tLmluZGV4O1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmRleC5jb3VudDsgKytqKSB7XG4gICAgICAgIG1lcmdlZEluZGV4LnB1c2goaW5kZXguZ2V0WChqKSArIGluZGV4T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGluZGV4T2Zmc2V0ICs9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICB9KTtcbiAgICBtZXJnZWRHZW9tZXRyeS5zZXRJbmRleChtZXJnZWRJbmRleCk7XG4gIH1cbiAgZm9yIChsZXQgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbWVyZ2VkQXR0cmlidXRlID0gbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKGF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIGlmICghbWVyZ2VkQXR0cmlidXRlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2hpbGUgdHJ5aW5nIHRvIG1lcmdlIHRoZSBcIiArIG5hbWUgKyBcIiBhdHRyaWJ1dGUuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbWVyZ2VkR2VvbWV0cnkuc2V0QXR0cmlidXRlKG5hbWUsIG1lcmdlZEF0dHJpYnV0ZSk7XG4gIH1cbiAgZm9yIChsZXQgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaEF0dHJpYnV0ZXNbbmFtZV1bMF0ubGVuZ3RoO1xuICAgIGlmIChudW1Nb3JwaFRhcmdldHMgPT09IDApXG4gICAgICBicmVhaztcbiAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgPSBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgfHwge307XG4gICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7ICsraSkge1xuICAgICAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZS5wdXNoKG1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXVtpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXJnZWRNb3JwaEF0dHJpYnV0ZSA9IG1lcmdlQnVmZmVyQXR0cmlidXRlcyhtb3JwaEF0dHJpYnV0ZXNUb01lcmdlKTtcbiAgICAgIGlmICghbWVyZ2VkTW9ycGhBdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2hpbGUgdHJ5aW5nIHRvIG1lcmdlIHRoZSBcIiArIG5hbWUgKyBcIiBtb3JwaEF0dHJpYnV0ZS5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXS5wdXNoKG1lcmdlZE1vcnBoQXR0cmlidXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZEdlb21ldHJ5O1xufTtcbmNvbnN0IG1lcmdlQnVmZmVyQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzKSA9PiB7XG4gIGxldCBUeXBlZEFycmF5ID0gdm9pZCAwO1xuICBsZXQgaXRlbVNpemUgPSB2b2lkIDA7XG4gIGxldCBub3JtYWxpemVkID0gdm9pZCAwO1xuICBsZXQgYXJyYXlMZW5ndGggPSAwO1xuICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICBpZiAoVHlwZWRBcnJheSA9PT0gdm9pZCAwKSB7XG4gICAgICBUeXBlZEFycmF5ID0gYXR0ci5hcnJheS5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgaWYgKFR5cGVkQXJyYXkgIT09IGF0dHIuYXJyYXkuY29uc3RydWN0b3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLmFycmF5IG11c3QgYmUgb2YgY29uc2lzdGVudCBhcnJheSB0eXBlcyBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXRlbVNpemUgPT09IHZvaWQgMClcbiAgICAgIGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcbiAgICBpZiAoaXRlbVNpemUgIT09IGF0dHIuaXRlbVNpemUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLml0ZW1TaXplIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZCA9PT0gdm9pZCAwKVxuICAgICAgbm9ybWFsaXplZCA9IGF0dHIubm9ybWFsaXplZDtcbiAgICBpZiAobm9ybWFsaXplZCAhPT0gYXR0ci5ub3JtYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5ub3JtYWxpemVkIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhcnJheUxlbmd0aCArPSBhdHRyLmFycmF5Lmxlbmd0aDtcbiAgfSk7XG4gIGlmIChUeXBlZEFycmF5ICYmIGl0ZW1TaXplKSB7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhcnJheUxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBhcnJheS5zZXQoYXR0ci5hcnJheSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBhdHRyLmFycmF5Lmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICB9XG59O1xuY29uc3QgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgVHlwZWRBcnJheSA9IHZvaWQgMDtcbiAgbGV0IGFycmF5TGVuZ3RoID0gMDtcbiAgbGV0IHN0cmlkZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuICAgIGlmIChUeXBlZEFycmF5ID09PSB2b2lkIDApXG4gICAgICBUeXBlZEFycmF5ID0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yO1xuICAgIGlmIChUeXBlZEFycmF5ICE9PSBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBdHRyaWJ1dGVCdWZmZXJzIG9mIGRpZmZlcmVudCB0eXBlcyBjYW5ub3QgYmUgaW50ZXJsZWF2ZWRcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJyYXlMZW5ndGggKz0gYXR0cmlidXRlLmFycmF5Lmxlbmd0aDtcbiAgICBzdHJpZGUgKz0gYXR0cmlidXRlLml0ZW1TaXplO1xuICB9XG4gIGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEludGVybGVhdmVkQnVmZmVyKG5ldyBUeXBlZEFycmF5KGFycmF5TGVuZ3RoKSwgc3RyaWRlKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCBnZXR0ZXJzID0gW1wiZ2V0WFwiLCBcImdldFlcIiwgXCJnZXRaXCIsIFwiZ2V0V1wiXTtcbiAgY29uc3Qgc2V0dGVycyA9IFtcInNldFhcIiwgXCJzZXRZXCIsIFwic2V0WlwiLCBcInNldFdcIl07XG4gIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2pdO1xuICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgIGNvbnN0IGNvdW50ID0gYXR0cmlidXRlLmNvdW50O1xuICAgIGNvbnN0IGliYSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCwgYXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgIHJlcy5wdXNoKGliYSk7XG4gICAgb2Zmc2V0ICs9IGl0ZW1TaXplO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGdldFdpdGhLZXkoaWJhLCBzZXR0ZXJzW2tdKTtcbiAgICAgICAgY29uc3QgZ2V0ID0gZ2V0V2l0aEtleShhdHRyaWJ1dGUsIGdldHRlcnNba10pO1xuICAgICAgICBzZXQoYywgZ2V0KGMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBlc3RpbWF0ZUJ5dGVzVXNlZChnZW9tZXRyeSkge1xuICBsZXQgbWVtID0gMDtcbiAgZm9yIChsZXQgbmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0ciA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBtZW0gKz0gYXR0ci5jb3VudCAqIGF0dHIuaXRlbVNpemUgKiBhdHRyLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICB9XG4gIGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICBtZW0gKz0gaW5kaWNlcyA/IGluZGljZXMuY291bnQgKiBpbmRpY2VzLml0ZW1TaXplICogaW5kaWNlcy5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCA6IDA7XG4gIHJldHVybiBtZW07XG59XG5mdW5jdGlvbiBtZXJnZVZlcnRpY2VzKGdlb21ldHJ5LCB0b2xlcmFuY2UgPSAxZS00KSB7XG4gIHRvbGVyYW5jZSA9IE1hdGgubWF4KHRvbGVyYW5jZSwgTnVtYmVyLkVQU0lMT04pO1xuICBjb25zdCBoYXNoVG9JbmRleCA9IHt9O1xuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgY29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gIGNvbnN0IHZlcnRleENvdW50ID0gaW5kaWNlcyA/IGluZGljZXMuY291bnQgOiBwb3NpdGlvbnMuY291bnQ7XG4gIGxldCBuZXh0SW5kZXggPSAwO1xuICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKGdlb21ldHJ5LmF0dHJpYnV0ZXMpO1xuICBjb25zdCBhdHRyQXJyYXlzID0ge307XG4gIGNvbnN0IG1vcnBoQXR0cnNBcnJheXMgPSB7fTtcbiAgY29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuICBjb25zdCBnZXR0ZXJzID0gW1wiZ2V0WFwiLCBcImdldFlcIiwgXCJnZXRaXCIsIFwiZ2V0V1wiXTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgYXR0ckFycmF5c1tuYW1lXSA9IFtdO1xuICAgIGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXTtcbiAgICBpZiAobW9ycGhBdHRyKSB7XG4gICAgICBtb3JwaEF0dHJzQXJyYXlzW25hbWVdID0gbmV3IEFycmF5KG1vcnBoQXR0ci5sZW5ndGgpLmZpbGwoMCkubWFwKCgpID0+IFtdKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjaW1hbFNoaWZ0ID0gTWF0aC5sb2cxMCgxIC8gdG9sZXJhbmNlKTtcbiAgY29uc3Qgc2hpZnRNdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIGRlY2ltYWxTaGlmdCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgIGNvbnN0IGluZGV4ID0gaW5kaWNlcyA/IGluZGljZXMuZ2V0WChpKSA6IGk7XG4gICAgbGV0IGhhc2ggPSBcIlwiO1xuICAgIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbal07XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICBoYXNoICs9IGAke35+KGF0dHJpYnV0ZVtnZXR0ZXJzW2tdXShpbmRleCkgKiBzaGlmdE11bHRpcGxpZXIpfSxgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzaCBpbiBoYXNoVG9JbmRleCkge1xuICAgICAgbmV3SW5kaWNlcy5wdXNoKGhhc2hUb0luZGV4W2hhc2hdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2pdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICAgIGNvbnN0IG5ld2FycmF5ID0gYXR0ckFycmF5c1tuYW1lXTtcbiAgICAgICAgY29uc3QgbmV3TW9ycGhBcnJheXMgPSBtb3JwaEF0dHJzQXJyYXlzW25hbWVdO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBnZXR0ZXJGdW5jID0gZ2V0dGVyc1trXTtcbiAgICAgICAgICBuZXdhcnJheS5wdXNoKGF0dHJpYnV0ZVtnZXR0ZXJGdW5jXShpbmRleCkpO1xuICAgICAgICAgIGlmIChtb3JwaEF0dHIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0ci5sZW5ndGg7IG0gPCBtbDsgbSsrKSB7XG4gICAgICAgICAgICAgIG5ld01vcnBoQXJyYXlzW21dLnB1c2gobW9ycGhBdHRyW21dW2dldHRlckZ1bmNdKGluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYXNoVG9JbmRleFtoYXNoXSA9IG5leHRJbmRleDtcbiAgICAgIG5ld0luZGljZXMucHVzaChuZXh0SW5kZXgpO1xuICAgICAgbmV4dEluZGV4Kys7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGdlb21ldHJ5LmNsb25lKCk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgIGNvbnN0IG9sZEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgb2xkQXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKGF0dHJBcnJheXNbbmFtZV0pO1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYnVmZmVyLCBvbGRBdHRyaWJ1dGUuaXRlbVNpemUsIG9sZEF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICByZXN1bHQuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZSk7XG4gICAgaWYgKG5hbWUgaW4gbW9ycGhBdHRyc0FycmF5cykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtb3JwaEF0dHJzQXJyYXlzW25hbWVdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG9sZE1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdO1xuICAgICAgICBjb25zdCBidWZmZXIyID0gbmV3IG9sZE1vcnBoQXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKG1vcnBoQXR0cnNBcnJheXNbbmFtZV1bal0pO1xuICAgICAgICBjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYnVmZmVyMiwgb2xkTW9ycGhBdHRyaWJ1dGUuaXRlbVNpemUsIG9sZE1vcnBoQXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgICAgICByZXN1bHQubW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdID0gbW9ycGhBdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc3VsdC5zZXRJbmRleChuZXdJbmRpY2VzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvVHJpYW5nbGVzRHJhd01vZGUoZ2VvbWV0cnksIGRyYXdNb2RlKSB7XG4gIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVzRHJhd01vZGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogR2VvbWV0cnkgYWxyZWFkeSBkZWZpbmVkIGFzIHRyaWFuZ2xlcy5cIik7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSB8fCBkcmF3TW9kZSA9PT0gVHJpYW5nbGVTdHJpcERyYXdNb2RlKSB7XG4gICAgbGV0IGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gICAgICBpZiAocG9zaXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uLmNvdW50OyBpKyspIHtcbiAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgoaW5kaWNlcyk7XG4gICAgICAgIGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5kZWZpbmVkIHBvc2l0aW9uIGF0dHJpYnV0ZS4gUHJvY2Vzc2luZyBub3QgcG9zc2libGUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBudW1iZXJPZlRyaWFuZ2xlcyA9IGluZGV4LmNvdW50IC0gMjtcbiAgICBjb25zdCBuZXdJbmRpY2VzID0gW107XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtYmVyT2ZUcmlhbmdsZXM7IGkrKykge1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKDApKTtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRyaWFuZ2xlczsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDIpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdJbmRpY2VzLmxlbmd0aCAvIDMgIT09IG51bWJlck9mVHJpYW5nbGVzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuYWJsZSB0byBnZW5lcmF0ZSBjb3JyZWN0IGFtb3VudCBvZiB0cmlhbmdsZXMuXCIpO1xuICAgIH1cbiAgICBjb25zdCBuZXdHZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCk7XG4gICAgbmV3R2VvbWV0cnkuc2V0SW5kZXgobmV3SW5kaWNlcyk7XG4gICAgbmV3R2VvbWV0cnkuY2xlYXJHcm91cHMoKTtcbiAgICByZXR1cm4gbmV3R2VvbWV0cnk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmtub3duIGRyYXcgbW9kZTpcIiwgZHJhd01vZGUpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzKG9iamVjdCkge1xuICBpZiAob2JqZWN0Lmdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgIT09IHRydWUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogR2VvbWV0cnkgaXMgbm90IG9mIHR5cGUgQnVmZmVyR2VvbWV0cnkuXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IF92QSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF92QiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF92QyA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQyA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQyA9IG5ldyBWZWN0b3IzKCk7XG4gIGZ1bmN0aW9uIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShvYmplY3QyLCBtYXRlcmlhbDIsIGF0dHJpYnV0ZSwgbW9ycGhBdHRyaWJ1dGUsIG1vcnBoVGFyZ2V0c1JlbGF0aXZlMiwgYTIsIGIyLCBjMiwgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheSkge1xuICAgIF92QS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYTIpO1xuICAgIF92Qi5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYjIpO1xuICAgIF92Qy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYzIpO1xuICAgIGNvbnN0IG1vcnBoSW5mbHVlbmNlcyA9IG9iamVjdDIubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuICAgIGlmIChcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG1hdGVyaWFsMi5tb3JwaFRhcmdldHMgJiYgbW9ycGhBdHRyaWJ1dGUgJiYgbW9ycGhJbmZsdWVuY2VzXG4gICAgKSB7XG4gICAgICBfbW9ycGhBLnNldCgwLCAwLCAwKTtcbiAgICAgIF9tb3JwaEIuc2V0KDAsIDAsIDApO1xuICAgICAgX21vcnBoQy5zZXQoMCwgMCwgMCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDAsIGlsMiA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaTIgPCBpbDI7IGkyKyspIHtcbiAgICAgICAgY29uc3QgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzW2kyXTtcbiAgICAgICAgY29uc3QgbW9ycGggPSBtb3JwaEF0dHJpYnV0ZVtpMl07XG4gICAgICAgIGlmIChpbmZsdWVuY2UgPT09IDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIF90ZW1wQS5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBhMik7XG4gICAgICAgIF90ZW1wQi5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBiMik7XG4gICAgICAgIF90ZW1wQy5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBjMik7XG4gICAgICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZTIpIHtcbiAgICAgICAgICBfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEsIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEMuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQywgaW5mbHVlbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEuc3ViKF92QSksIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLnN1YihfdkIpLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEMuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQy5zdWIoX3ZDKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3ZBLmFkZChfbW9ycGhBKTtcbiAgICAgIF92Qi5hZGQoX21vcnBoQik7XG4gICAgICBfdkMuYWRkKF9tb3JwaEMpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0Mi5pc1NraW5uZWRNZXNoKSB7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYTIsIF92QSk7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYjIsIF92Qik7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYzIsIF92Qyk7XG4gICAgfVxuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMF0gPSBfdkEueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDFdID0gX3ZBLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAyXSA9IF92QS56O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMF0gPSBfdkIueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDFdID0gX3ZCLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAyXSA9IF92Qi56O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMF0gPSBfdkMueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDFdID0gX3ZDLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAyXSA9IF92Qy56O1xuICB9XG4gIGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuICBjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcbiAgbGV0IGEsIGIsIGM7XG4gIGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgY29uc3Qgbm9ybWFsQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG4gIGNvbnN0IG1vcnBoTm9ybWFsID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG4gIGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcbiAgbGV0IGksIGosIGlsLCBqbDtcbiAgbGV0IGdyb3VwLCBncm91cE1hdGVyaWFsO1xuICBsZXQgc3RhcnQsIGVuZDtcbiAgY29uc3QgbW9kaWZpZWRQb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25BdHRyaWJ1dGUuY291bnQgKiBwb3NpdGlvbkF0dHJpYnV0ZS5pdGVtU2l6ZSk7XG4gIGNvbnN0IG1vZGlmaWVkTm9ybWFsID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWxBdHRyaWJ1dGUuY291bnQgKiBub3JtYWxBdHRyaWJ1dGUuaXRlbVNpemUpO1xuICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgICAgZm9yIChqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgIGEgPSBpbmRleC5nZXRYKGopO1xuICAgICAgICAgIGIgPSBpbmRleC5nZXRYKGogKyAxKTtcbiAgICAgICAgICBjID0gaW5kZXguZ2V0WChqICsgMik7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4oaW5kZXguY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzKSB7XG4gICAgICAgIGEgPSBpbmRleC5nZXRYKGkpO1xuICAgICAgICBiID0gaW5kZXguZ2V0WChpICsgMSk7XG4gICAgICAgIGMgPSBpbmRleC5nZXRYKGkgKyAyKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocG9zaXRpb25BdHRyaWJ1dGUgIT09IHZvaWQgMCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgZm9yIChpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuICAgICAgICBzdGFydCA9IE1hdGgubWF4KGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihncm91cC5zdGFydCArIGdyb3VwLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgICBmb3IgKGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzKSB7XG4gICAgICAgICAgYSA9IGo7XG4gICAgICAgICAgYiA9IGogKyAxO1xuICAgICAgICAgIGMgPSBqICsgMjtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICBlbmQgPSBNYXRoLm1pbihwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMpIHtcbiAgICAgICAgYSA9IGk7XG4gICAgICAgIGIgPSBpICsgMTtcbiAgICAgICAgYyA9IGkgKyAyO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShtb2RpZmllZFBvc2l0aW9uLCAzKTtcbiAgY29uc3QgbW9ycGhlZE5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG1vZGlmaWVkTm9ybWFsLCAzKTtcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgbW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlLFxuICAgIG1vcnBoZWROb3JtYWxBdHRyaWJ1dGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ3JlYXNlZE5vcm1hbHMoZ2VvbWV0cnksIGNyZWFzZUFuZ2xlID0gTWF0aC5QSSAvIDMpIHtcbiAgY29uc3QgY3JlYXNlRG90ID0gTWF0aC5jb3MoY3JlYXNlQW5nbGUpO1xuICBjb25zdCBoYXNoTXVsdGlwbGllciA9ICgxICsgMWUtMTApICogMTAwO1xuICBjb25zdCB2ZXJ0cyA9IFtuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpXTtcbiAgY29uc3QgdGVtcFZlYzEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wVmVjMiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBOb3JtID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcE5vcm0yID0gbmV3IFZlY3RvcjMoKTtcbiAgZnVuY3Rpb24gaGFzaFZlcnRleCh2KSB7XG4gICAgY29uc3QgeCA9IH5+KHYueCAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICBjb25zdCB5ID0gfn4odi55ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIGNvbnN0IHogPSB+fih2LnogKiBoYXNoTXVsdGlwbGllcik7XG4gICAgcmV0dXJuIGAke3h9LCR7eX0sJHt6fWA7XG4gIH1cbiAgY29uc3QgcmVzdWx0R2VvbWV0cnkgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpIDogZ2VvbWV0cnk7XG4gIGNvbnN0IHBvc0F0dHIgPSByZXN1bHRHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCB2ZXJ0ZXhNYXAgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwb3NBdHRyLmNvdW50IC8gMzsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGkzID0gMyAqIGk7XG4gICAgY29uc3QgYSA9IHZlcnRzWzBdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAwKTtcbiAgICBjb25zdCBiID0gdmVydHNbMV0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDEpO1xuICAgIGNvbnN0IGMgPSB2ZXJ0c1syXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMik7XG4gICAgdGVtcFZlYzEuc3ViVmVjdG9ycyhjLCBiKTtcbiAgICB0ZW1wVmVjMi5zdWJWZWN0b3JzKGEsIGIpO1xuICAgIGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgaWYgKCEoaGFzaCBpbiB2ZXJ0ZXhNYXApKSB7XG4gICAgICAgIHZlcnRleE1hcFtoYXNoXSA9IFtdO1xuICAgICAgfVxuICAgICAgdmVydGV4TWFwW2hhc2hdLnB1c2gobm9ybWFsKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgbm9ybWFsQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHBvc0F0dHIuY291bnQgKiAzKTtcbiAgY29uc3Qgbm9ybUF0dHIgPSBuZXcgQnVmZmVyQXR0cmlidXRlKG5vcm1hbEFycmF5LCAzLCBmYWxzZSk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICB0ZW1wTm9ybS5jcm9zc1ZlY3RvcnModGVtcFZlYzEsIHRlbXBWZWMyKS5ub3JtYWxpemUoKTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IDM7IG4rKykge1xuICAgICAgY29uc3QgdmVydCA9IHZlcnRzW25dO1xuICAgICAgY29uc3QgaGFzaCA9IGhhc2hWZXJ0ZXgodmVydCk7XG4gICAgICBjb25zdCBvdGhlck5vcm1hbHMgPSB2ZXJ0ZXhNYXBbaGFzaF07XG4gICAgICB0ZW1wTm9ybTIuc2V0KDAsIDAsIDApO1xuICAgICAgZm9yIChsZXQgayA9IDAsIGxrID0gb3RoZXJOb3JtYWxzLmxlbmd0aDsgayA8IGxrOyBrKyspIHtcbiAgICAgICAgY29uc3Qgb3RoZXJOb3JtID0gb3RoZXJOb3JtYWxzW2tdO1xuICAgICAgICBpZiAodGVtcE5vcm0uZG90KG90aGVyTm9ybSkgPiBjcmVhc2VEb3QpIHtcbiAgICAgICAgICB0ZW1wTm9ybTIuYWRkKG90aGVyTm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBOb3JtMi5ub3JtYWxpemUoKTtcbiAgICAgIG5vcm1BdHRyLnNldFhZWihpMyArIG4sIHRlbXBOb3JtMi54LCB0ZW1wTm9ybTIueSwgdGVtcE5vcm0yLnopO1xuICAgIH1cbiAgfVxuICByZXN1bHRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbm9ybUF0dHIpO1xuICByZXR1cm4gcmVzdWx0R2VvbWV0cnk7XG59XG5leHBvcnQge1xuICBjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMsXG4gIGVzdGltYXRlQnl0ZXNVc2VkLFxuICBpbnRlcmxlYXZlQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzLFxuICBtZXJnZUJ1ZmZlckdlb21ldHJpZXMsXG4gIG1lcmdlVmVydGljZXMsXG4gIHRvQ3JlYXNlZE5vcm1hbHMsXG4gIHRvVHJpYW5nbGVzRHJhd01vZGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXJHZW9tZXRyeVV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkJ1ZmZlckdlb21ldHJ5IiwiQnVmZmVyQXR0cmlidXRlIiwiSW50ZXJsZWF2ZWRCdWZmZXIiLCJJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSIsIlRyaWFuZ2xlc0RyYXdNb2RlIiwiVHJpYW5nbGVGYW5EcmF3TW9kZSIsIlRyaWFuZ2xlU3RyaXBEcmF3TW9kZSIsIlZlY3RvcjMiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwiZ2V0V2l0aEtleSIsIm1lcmdlQnVmZmVyR2VvbWV0cmllcyIsImdlb21ldHJpZXMiLCJ1c2VHcm91cHMiLCJpc0luZGV4ZWQiLCJpbmRleCIsImF0dHJpYnV0ZXNVc2VkIiwiU2V0IiwiT2JqZWN0Iiwia2V5cyIsImF0dHJpYnV0ZXMiLCJtb3JwaEF0dHJpYnV0ZXNVc2VkIiwibW9ycGhBdHRyaWJ1dGVzIiwibW9ycGhUYXJnZXRzUmVsYXRpdmUiLCJtZXJnZWRHZW9tZXRyeSIsIm9mZnNldCIsImZvckVhY2giLCJnZW9tIiwiaSIsImF0dHJpYnV0ZXNDb3VudCIsImNvbnNvbGUiLCJlcnJvciIsIm5hbWUiLCJoYXMiLCJwdXNoIiwic2l6ZSIsInVzZXJEYXRhIiwibWVyZ2VkVXNlckRhdGEiLCJjb3VudCIsInBvc2l0aW9uIiwiYWRkR3JvdXAiLCJpbmRleE9mZnNldCIsIm1lcmdlZEluZGV4IiwiaiIsImdldFgiLCJzZXRJbmRleCIsIm1lcmdlZEF0dHJpYnV0ZSIsIm1lcmdlQnVmZmVyQXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsIm51bU1vcnBoVGFyZ2V0cyIsImxlbmd0aCIsIm1vcnBoQXR0cmlidXRlc1RvTWVyZ2UiLCJtZXJnZWRNb3JwaEF0dHJpYnV0ZSIsIlR5cGVkQXJyYXkiLCJpdGVtU2l6ZSIsIm5vcm1hbGl6ZWQiLCJhcnJheUxlbmd0aCIsImF0dHIiLCJhcnJheSIsImNvbnN0cnVjdG9yIiwic2V0IiwiaW50ZXJsZWF2ZUF0dHJpYnV0ZXMiLCJzdHJpZGUiLCJsIiwiYXR0cmlidXRlIiwiaW50ZXJsZWF2ZWRCdWZmZXIiLCJyZXMiLCJnZXR0ZXJzIiwic2V0dGVycyIsImliYSIsImMiLCJrIiwiZ2V0IiwiZXN0aW1hdGVCeXRlc1VzZWQiLCJnZW9tZXRyeSIsIm1lbSIsImdldEF0dHJpYnV0ZSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiaW5kaWNlcyIsImdldEluZGV4IiwibWVyZ2VWZXJ0aWNlcyIsInRvbGVyYW5jZSIsIk1hdGgiLCJtYXgiLCJOdW1iZXIiLCJFUFNJTE9OIiwiaGFzaFRvSW5kZXgiLCJwb3NpdGlvbnMiLCJ2ZXJ0ZXhDb3VudCIsIm5leHRJbmRleCIsImF0dHJpYnV0ZU5hbWVzIiwiYXR0ckFycmF5cyIsIm1vcnBoQXR0cnNBcnJheXMiLCJuZXdJbmRpY2VzIiwibW9ycGhBdHRyIiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiZGVjaW1hbFNoaWZ0IiwibG9nMTAiLCJzaGlmdE11bHRpcGxpZXIiLCJwb3ciLCJoYXNoIiwibmV3YXJyYXkiLCJuZXdNb3JwaEFycmF5cyIsImdldHRlckZ1bmMiLCJtIiwibWwiLCJyZXN1bHQiLCJjbG9uZSIsIm9sZEF0dHJpYnV0ZSIsImJ1ZmZlciIsIm9sZE1vcnBoQXR0cmlidXRlIiwiYnVmZmVyMiIsIm1vcnBoQXR0cmlidXRlIiwidG9UcmlhbmdsZXNEcmF3TW9kZSIsImRyYXdNb2RlIiwid2FybiIsIm51bWJlck9mVHJpYW5nbGVzIiwibmV3R2VvbWV0cnkiLCJjbGVhckdyb3VwcyIsImNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyIsIm9iamVjdCIsImlzQnVmZmVyR2VvbWV0cnkiLCJfdkEiLCJfdkIiLCJfdkMiLCJfdGVtcEEiLCJfdGVtcEIiLCJfdGVtcEMiLCJfbW9ycGhBIiwiX21vcnBoQiIsIl9tb3JwaEMiLCJfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEiLCJvYmplY3QyIiwibWF0ZXJpYWwyIiwibW9ycGhUYXJnZXRzUmVsYXRpdmUyIiwiYTIiLCJiMiIsImMyIiwibW9kaWZpZWRBdHRyaWJ1dGVBcnJheSIsImZyb21CdWZmZXJBdHRyaWJ1dGUiLCJtb3JwaEluZmx1ZW5jZXMiLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLCJtb3JwaFRhcmdldHMiLCJpMiIsImlsMiIsImluZmx1ZW5jZSIsIm1vcnBoIiwiYWRkU2NhbGVkVmVjdG9yIiwic3ViIiwiYWRkIiwiaXNTa2lubmVkTWVzaCIsImJvbmVUcmFuc2Zvcm0iLCJ4IiwieSIsInoiLCJtYXRlcmlhbCIsImEiLCJiIiwicG9zaXRpb25BdHRyaWJ1dGUiLCJtb3JwaFBvc2l0aW9uIiwibm9ybWFsQXR0cmlidXRlIiwibm9ybWFsIiwibW9ycGhOb3JtYWwiLCJncm91cHMiLCJkcmF3UmFuZ2UiLCJpbCIsImpsIiwiZ3JvdXAiLCJncm91cE1hdGVyaWFsIiwic3RhcnQiLCJlbmQiLCJtb2RpZmllZFBvc2l0aW9uIiwiRmxvYXQzMkFycmF5IiwibW9kaWZpZWROb3JtYWwiLCJpc0FycmF5IiwibWF0ZXJpYWxJbmRleCIsIm1pbiIsIm1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSIsIm1vcnBoZWROb3JtYWxBdHRyaWJ1dGUiLCJ0b0NyZWFzZWROb3JtYWxzIiwiY3JlYXNlQW5nbGUiLCJQSSIsImNyZWFzZURvdCIsImNvcyIsImhhc2hNdWx0aXBsaWVyIiwidmVydHMiLCJ0ZW1wVmVjMSIsInRlbXBWZWMyIiwidGVtcE5vcm0iLCJ0ZW1wTm9ybTIiLCJoYXNoVmVydGV4IiwidiIsInJlc3VsdEdlb21ldHJ5IiwidG9Ob25JbmRleGVkIiwicG9zQXR0ciIsInZlcnRleE1hcCIsImkzIiwic3ViVmVjdG9ycyIsImNyb3NzVmVjdG9ycyIsIm5vcm1hbGl6ZSIsIm4iLCJ2ZXJ0Iiwibm9ybWFsQXJyYXkiLCJub3JtQXR0ciIsIm90aGVyTm9ybWFscyIsImxrIiwib3RoZXJOb3JtIiwiZG90Iiwic2V0WFlaIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/utils/SkeletonUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SkeletonUtils: () => (/* binding */ SkeletonUtils)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nfunction retarget(target, source, options = {}) {\n    const pos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(), scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), bindBoneMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), relativeMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), globalMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n    options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n    options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n    options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n    options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n    options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n    options.names = options.names || {};\n    const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source), bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n    let bindBones, bone, name, boneTo, bonesPosition;\n    if (target.isObject3D) {\n        target.skeleton.pose();\n    } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n    }\n    if (options.preservePosition) {\n        bonesPosition = [];\n        for(let i = 0; i < bones.length; i++){\n            bonesPosition.push(bones[i].position.clone());\n        }\n    }\n    if (options.preserveMatrix) {\n        target.updateMatrixWorld();\n        target.matrixWorld.identity();\n        for(let i = 0; i < target.children.length; ++i){\n            target.children[i].updateMatrixWorld(true);\n        }\n    }\n    if (options.offsets) {\n        bindBones = [];\n        for(let i = 0; i < bones.length; ++i){\n            bone = bones[i];\n            name = options.names[bone.name] || bone.name;\n            if (options.offsets[name]) {\n                bone.matrix.multiply(options.offsets[name]);\n                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n                bone.updateMatrixWorld();\n            }\n            bindBones.push(bone.matrixWorld.clone());\n        }\n    }\n    for(let i = 0; i < bones.length; ++i){\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n        if (boneTo) {\n            boneTo.updateMatrixWorld();\n            if (options.useTargetMatrix) {\n                relativeMatrix.copy(boneTo.matrixWorld);\n            } else {\n                relativeMatrix.copy(target.matrixWorld).invert();\n                relativeMatrix.multiply(boneTo.matrixWorld);\n            }\n            scale.setFromMatrixScale(relativeMatrix);\n            relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n            globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n            if (target.isObject3D) {\n                const boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n                globalMatrix.multiply(wBindMatrix);\n            }\n            globalMatrix.copyPosition(relativeMatrix);\n        }\n        if (bone.parent && bone.parent.isBone) {\n            bone.matrix.copy(bone.parent.matrixWorld).invert();\n            bone.matrix.multiply(globalMatrix);\n        } else {\n            bone.matrix.copy(globalMatrix);\n        }\n        if (options.preserveHipPosition && name === options.hip) {\n            bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n    }\n    if (options.preservePosition) {\n        for(let i = 0; i < bones.length; ++i){\n            bone = bones[i];\n            name = options.names[bone.name] || bone.name;\n            if (name !== options.hip) {\n                bone.position.copy(bonesPosition[i]);\n            }\n        }\n    }\n    if (options.preserveMatrix) {\n        target.updateMatrixWorld(true);\n    }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n    options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== void 0 ? options.fps : 30;\n    options.names = options.names || [];\n    if (!source.isObject3D) {\n        source = getHelperFromSkeleton(source);\n    }\n    const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new three__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(source), bones = getBones(target.skeleton), boneDatas = [];\n    let positionOffset, bone, boneTo, boneData, name;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n    for(let i = 0; i < numFrames; ++i){\n        const time = i * delta;\n        retarget(target, source, options);\n        for(let j = 0; j < bones.length; ++j){\n            name = options.names[bones[j].name] || bones[j].name;\n            boneTo = getBoneByName(name, source.skeleton);\n            if (boneTo) {\n                bone = bones[j];\n                boneData = boneDatas[j] = boneDatas[j] || {\n                    bone\n                };\n                if (options.hip === name) {\n                    if (!boneData.pos) {\n                        boneData.pos = {\n                            times: new Float32Array(numFrames),\n                            values: new Float32Array(numFrames * 3)\n                        };\n                    }\n                    if (options.useFirstFramePosition) {\n                        if (i === 0) {\n                            positionOffset = bone.position.clone();\n                        }\n                        bone.position.sub(positionOffset);\n                    }\n                    boneData.pos.times[i] = time;\n                    bone.position.toArray(boneData.pos.values, i * 3);\n                }\n                if (!boneData.quat) {\n                    boneData.quat = {\n                        times: new Float32Array(numFrames),\n                        values: new Float32Array(numFrames * 4)\n                    };\n                }\n                boneData.quat.times[i] = time;\n                bone.quaternion.toArray(boneData.quat.values, i * 4);\n            }\n        }\n        mixer.update(delta);\n        source.updateMatrixWorld();\n    }\n    for(let i = 0; i < boneDatas.length; ++i){\n        boneData = boneDatas[i];\n        if (boneData) {\n            if (boneData.pos) {\n                convertedTracks.push(new three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack(\".bones[\" + boneData.bone.name + \"].position\", boneData.pos.times, boneData.pos.values));\n            }\n            convertedTracks.push(new three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack(\".bones[\" + boneData.bone.name + \"].quaternion\", boneData.quat.times, boneData.quat.values));\n        }\n    }\n    mixer.uncacheAction(clip);\n    return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n    const sourceLookup = /* @__PURE__ */ new Map();\n    const cloneLookup = /* @__PURE__ */ new Map();\n    const clone2 = source.clone();\n    parallelTraverse(source, clone2, function(sourceNode, clonedNode) {\n        sourceLookup.set(clonedNode, sourceNode);\n        cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone2.traverse(function(node) {\n        if (!node.isSkinnedMesh) return;\n        const clonedMesh = node;\n        const sourceMesh = sourceLookup.get(node);\n        const sourceBones = sourceMesh.skeleton.bones;\n        clonedMesh.skeleton = sourceMesh.skeleton.clone();\n        clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n        clonedMesh.skeleton.bones = sourceBones.map(function(bone) {\n            return cloneLookup.get(bone);\n        });\n        clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n    for(let i = 0, bones = getBones(skeleton); i < bones.length; i++){\n        if (name === bones[i].name) return bones[i];\n    }\n}\nfunction getBones(skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n    const source = new three__WEBPACK_IMPORTED_MODULE_0__.SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n}\nfunction parallelTraverse(a, b, callback) {\n    callback(a, b);\n    for(let i = 0; i < a.children.length; i++){\n        parallelTraverse(a.children[i], b.children[i], callback);\n    }\n}\nconst SkeletonUtils = {\n    retarget,\n    retargetClip,\n    clone\n};\n //# sourceMappingURL=SkeletonUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL1NrZWxldG9uVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0o7QUFDbEosU0FBU1EsU0FBU0MsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzVDLE1BQU1DLE1BQU0sSUFBSVosMENBQU9BLElBQUlhLE9BQU8sSUFBSVosNkNBQVVBLElBQUlhLFFBQVEsSUFBSWQsMENBQU9BLElBQUllLGlCQUFpQixJQUFJYiwwQ0FBT0EsSUFBSWMsaUJBQWlCLElBQUlkLDBDQUFPQSxJQUFJZSxlQUFlLElBQUlmLDBDQUFPQTtJQUNyS1MsUUFBUU8sY0FBYyxHQUFHUCxRQUFRTyxjQUFjLEtBQUssS0FBSyxJQUFJUCxRQUFRTyxjQUFjLEdBQUc7SUFDdEZQLFFBQVFRLGdCQUFnQixHQUFHUixRQUFRUSxnQkFBZ0IsS0FBSyxLQUFLLElBQUlSLFFBQVFRLGdCQUFnQixHQUFHO0lBQzVGUixRQUFRUyxtQkFBbUIsR0FBR1QsUUFBUVMsbUJBQW1CLEtBQUssS0FBSyxJQUFJVCxRQUFRUyxtQkFBbUIsR0FBRztJQUNyR1QsUUFBUVUsZUFBZSxHQUFHVixRQUFRVSxlQUFlLEtBQUssS0FBSyxJQUFJVixRQUFRVSxlQUFlLEdBQUc7SUFDekZWLFFBQVFXLEdBQUcsR0FBR1gsUUFBUVcsR0FBRyxLQUFLLEtBQUssSUFBSVgsUUFBUVcsR0FBRyxHQUFHO0lBQ3JEWCxRQUFRWSxLQUFLLEdBQUdaLFFBQVFZLEtBQUssSUFBSSxDQUFDO0lBQ2xDLE1BQU1DLGNBQWNkLE9BQU9lLFVBQVUsR0FBR2YsT0FBT2dCLFFBQVEsQ0FBQ0MsS0FBSyxHQUFHQyxTQUFTbEIsU0FBU2lCLFFBQVFsQixPQUFPZ0IsVUFBVSxHQUFHaEIsT0FBT2lCLFFBQVEsQ0FBQ0MsS0FBSyxHQUFHQyxTQUFTbkI7SUFDL0ksSUFBSW9CLFdBQVdDLE1BQU1DLE1BQU1DLFFBQVFDO0lBQ25DLElBQUl4QixPQUFPZ0Is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RSxFQUFFNkUsRUFBRXJFLFFBQVEsQ0FBQ1IsRUFBRSxFQUFFOEU7SUFDakQ7QUFDRjtBQUNBLE1BQU1DLGdCQUFnQjtJQUFFMUc7SUFBVTJEO0lBQWM1QjtBQUFNO0FBR3BELENBQ0YseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNyZWF0aXZlLXBvcnRmb2xpby1zdGFydGVyLWNvZGUtZmlsZXMvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL1NrZWxldG9uVXRpbHMuanM/Yjk2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWN0b3IzLCBRdWF0ZXJuaW9uLCBNYXRyaXg0LCBBbmltYXRpb25NaXhlciwgVmVjdG9yS2V5ZnJhbWVUcmFjaywgUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIEFuaW1hdGlvbkNsaXAsIFNrZWxldG9uSGVscGVyIH0gZnJvbSBcInRocmVlXCI7XG5mdW5jdGlvbiByZXRhcmdldCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHBvcyA9IG5ldyBWZWN0b3IzKCksIHF1YXQgPSBuZXcgUXVhdGVybmlvbigpLCBzY2FsZSA9IG5ldyBWZWN0b3IzKCksIGJpbmRCb25lTWF0cml4ID0gbmV3IE1hdHJpeDQoKSwgcmVsYXRpdmVNYXRyaXggPSBuZXcgTWF0cml4NCgpLCBnbG9iYWxNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICBvcHRpb25zLnByZXNlcnZlTWF0cml4ID0gb3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCAhPT0gdm9pZCAwID8gb3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCA6IHRydWU7XG4gIG9wdGlvbnMucHJlc2VydmVQb3NpdGlvbiA9IG9wdGlvbnMucHJlc2VydmVQb3NpdGlvbiAhPT0gdm9pZCAwID8gb3B0aW9ucy5wcmVzZXJ2ZVBvc2l0aW9uIDogdHJ1ZTtcbiAgb3B0aW9ucy5wcmVzZXJ2ZUhpcFBvc2l0aW9uID0gb3B0aW9ucy5wcmVzZXJ2ZUhpcFBvc2l0aW9uICE9PSB2b2lkIDAgPyBvcHRpb25zLnByZXNlcnZlSGlwUG9zaXRpb24gOiBmYWxzZTtcbiAgb3B0aW9ucy51c2VUYXJnZXRNYXRyaXggPSBvcHRpb25zLnVzZVRhcmdldE1hdHJpeCAhPT0gdm9pZCAwID8gb3B0aW9ucy51c2VUYXJnZXRNYXRyaXggOiBmYWxzZTtcbiAgb3B0aW9ucy5oaXAgPSBvcHRpb25zLmhpcCAhPT0gdm9pZCAwID8gb3B0aW9ucy5oaXAgOiBcImhpcFwiO1xuICBvcHRpb25zLm5hbWVzID0gb3B0aW9ucy5uYW1lcyB8fCB7fTtcbiAgY29uc3Qgc291cmNlQm9uZXMgPSBzb3VyY2UuaXNPYmplY3QzRCA/IHNvdXJjZS5za2VsZXRvbi5ib25lcyA6IGdldEJvbmVzKHNvdXJjZSksIGJvbmVzID0gdGFyZ2V0LmlzT2JqZWN0M0QgPyB0YXJnZXQuc2tlbGV0b24uYm9uZXMgOiBnZXRCb25lcyh0YXJnZXQpO1xuICBsZXQgYmluZEJvbmVzLCBib25lLCBuYW1lLCBib25lVG8sIGJvbmVzUG9zaXRpb247XG4gIGlmICh0YXJnZXQuaXNPYmplY3QzRCkge1xuICAgIHRhcmdldC5za2VsZXRvbi5wb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy51c2VUYXJnZXRNYXRyaXggPSB0cnVlO1xuICAgIG9wdGlvbnMucHJlc2VydmVNYXRyaXggPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5wcmVzZXJ2ZVBvc2l0aW9uKSB7XG4gICAgYm9uZXNQb3NpdGlvbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJvbmVzUG9zaXRpb24ucHVzaChib25lc1tpXS5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJlc2VydmVNYXRyaXgpIHtcbiAgICB0YXJnZXQudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICB0YXJnZXQubWF0cml4V29ybGQuaWRlbnRpdHkoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgdGFyZ2V0LmNoaWxkcmVuW2ldLnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5vZmZzZXRzKSB7XG4gICAgYmluZEJvbmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7ICsraSkge1xuICAgICAgYm9uZSA9IGJvbmVzW2ldO1xuICAgICAgbmFtZSA9IG9wdGlvbnMubmFtZXNbYm9uZS5uYW1lXSB8fCBib25lLm5hbWU7XG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXRzW25hbWVdKSB7XG4gICAgICAgIGJvbmUubWF0cml4Lm11bHRpcGx5KG9wdGlvbnMub2Zmc2V0c1tuYW1lXSk7XG4gICAgICAgIGJvbmUubWF0cml4LmRlY29tcG9zZShib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUpO1xuICAgICAgICBib25lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICB9XG4gICAgICBiaW5kQm9uZXMucHVzaChib25lLm1hdHJpeFdvcmxkLmNsb25lKCkpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgYm9uZSA9IGJvbmVzW2ldO1xuICAgIG5hbWUgPSBvcHRpb25zLm5hbWVzW2JvbmUubmFtZV0gfHwgYm9uZS5uYW1lO1xuICAgIGJvbmVUbyA9IGdldEJvbmVCeU5hbWUobmFtZSwgc291cmNlQm9uZXMpO1xuICAgIGdsb2JhbE1hdHJpeC5jb3B5KGJvbmUubWF0cml4V29ybGQpO1xuICAgIGlmIChib25lVG8pIHtcbiAgICAgIGJvbmVUby51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgaWYgKG9wdGlvbnMudXNlVGFyZ2V0TWF0cml4KSB7XG4gICAgICAgIHJlbGF0aXZlTWF0cml4LmNvcHkoYm9uZVRvLm1hdHJpeFdvcmxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbGF0aXZlTWF0cml4LmNvcHkodGFyZ2V0Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICAgICAgcmVsYXRpdmVNYXRyaXgubXVsdGlwbHkoYm9uZVRvLm1hdHJpeFdvcmxkKTtcbiAgICAgIH1cbiAgICAgIHNjYWxlLnNldEZyb21NYXRyaXhTY2FsZShyZWxhdGl2ZU1hdHJpeCk7XG4gICAgICByZWxhdGl2ZU1hdHJpeC5zY2FsZShzY2FsZS5zZXQoMSAvIHNjYWxlLngsIDEgLyBzY2FsZS55LCAxIC8gc2NhbGUueikpO1xuICAgICAgZ2xvYmFsTWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHF1YXQuc2V0RnJvbVJvdGF0aW9uTWF0cml4KHJlbGF0aXZlTWF0cml4KSk7XG4gICAgICBpZiAodGFyZ2V0LmlzT2JqZWN0M0QpIHtcbiAgICAgICAgY29uc3QgYm9uZUluZGV4ID0gYm9uZXMuaW5kZXhPZihib25lKSwgd0JpbmRNYXRyaXggPSBiaW5kQm9uZXMgPyBiaW5kQm9uZXNbYm9uZUluZGV4XSA6IGJpbmRCb25lTWF0cml4LmNvcHkodGFyZ2V0LnNrZWxldG9uLmJvbmVJbnZlcnNlc1tib25lSW5kZXhdKS5pbnZlcnQoKTtcbiAgICAgICAgZ2xvYmFsTWF0cml4Lm11bHRpcGx5KHdCaW5kTWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGdsb2JhbE1hdHJpeC5jb3B5UG9zaXRpb24ocmVsYXRpdmVNYXRyaXgpO1xuICAgIH1cbiAgICBpZiAoYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lKSB7XG4gICAgICBib25lLm1hdHJpeC5jb3B5KGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICAgIGJvbmUubWF0cml4Lm11bHRpcGx5KGdsb2JhbE1hdHJpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvbmUubWF0cml4LmNvcHkoZ2xvYmFsTWF0cml4KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJlc2VydmVIaXBQb3NpdGlvbiAmJiBuYW1lID09PSBvcHRpb25zLmhpcCkge1xuICAgICAgYm9uZS5tYXRyaXguc2V0UG9zaXRpb24ocG9zLnNldCgwLCBib25lLnBvc2l0aW9uLnksIDApKTtcbiAgICB9XG4gICAgYm9uZS5tYXRyaXguZGVjb21wb3NlKGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSk7XG4gICAgYm9uZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICB9XG4gIGlmIChvcHRpb25zLnByZXNlcnZlUG9zaXRpb24pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBib25lID0gYm9uZXNbaV07XG4gICAgICBuYW1lID0gb3B0aW9ucy5uYW1lc1tib25lLm5hbWVdIHx8IGJvbmUubmFtZTtcbiAgICAgIGlmIChuYW1lICE9PSBvcHRpb25zLmhpcCkge1xuICAgICAgICBib25lLnBvc2l0aW9uLmNvcHkoYm9uZXNQb3NpdGlvbltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLnByZXNlcnZlTWF0cml4KSB7XG4gICAgdGFyZ2V0LnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiByZXRhcmdldENsaXAodGFyZ2V0LCBzb3VyY2UsIGNsaXAsIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zLnVzZUZpcnN0RnJhbWVQb3NpdGlvbiA9IG9wdGlvbnMudXNlRmlyc3RGcmFtZVBvc2l0aW9uICE9PSB2b2lkIDAgPyBvcHRpb25zLnVzZUZpcnN0RnJhbWVQb3NpdGlvbiA6IGZhbHNlO1xuICBvcHRpb25zLmZwcyA9IG9wdGlvbnMuZnBzICE9PSB2b2lkIDAgPyBvcHRpb25zLmZwcyA6IDMwO1xuICBvcHRpb25zLm5hbWVzID0gb3B0aW9ucy5uYW1lcyB8fCBbXTtcbiAgaWYgKCFzb3VyY2UuaXNPYmplY3QzRCkge1xuICAgIHNvdXJjZSA9IGdldEhlbHBlckZyb21Ta2VsZXRvbihzb3VyY2UpO1xuICB9XG4gIGNvbnN0IG51bUZyYW1lcyA9IE1hdGgucm91bmQoY2xpcC5kdXJhdGlvbiAqIChvcHRpb25zLmZwcyAvIDFlMykgKiAxZTMpLCBkZWx0YSA9IDEgLyBvcHRpb25zLmZwcywgY29udmVydGVkVHJhY2tzID0gW10sIG1peGVyID0gbmV3IEFuaW1hdGlvbk1peGVyKHNvdXJjZSksIGJvbmVzID0gZ2V0Qm9uZXModGFyZ2V0LnNrZWxldG9uKSwgYm9uZURhdGFzID0gW107XG4gIGxldCBwb3NpdGlvbk9mZnNldCwgYm9uZSwgYm9uZVRvLCBib25lRGF0YSwgbmFtZTtcbiAgbWl4ZXIuY2xpcEFjdGlvbihjbGlwKS5wbGF5KCk7XG4gIG1peGVyLnVwZGF0ZSgwKTtcbiAgc291cmNlLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRnJhbWVzOyArK2kpIHtcbiAgICBjb25zdCB0aW1lID0gaSAqIGRlbHRhO1xuICAgIHJldGFyZ2V0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJvbmVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBuYW1lID0gb3B0aW9ucy5uYW1lc1tib25lc1tqXS5uYW1lXSB8fCBib25lc1tqXS5uYW1lO1xuICAgICAgYm9uZVRvID0gZ2V0Qm9uZUJ5TmFtZShuYW1lLCBzb3VyY2Uuc2tlbGV0b24pO1xuICAgICAgaWYgKGJvbmVUbykge1xuICAgICAgICBib25lID0gYm9uZXNbal07XG4gICAgICAgIGJvbmVEYXRhID0gYm9uZURhdGFzW2pdID0gYm9uZURhdGFzW2pdIHx8IHsgYm9uZSB9O1xuICAgICAgICBpZiAob3B0aW9ucy5oaXAgPT09IG5hbWUpIHtcbiAgICAgICAgICBpZiAoIWJvbmVEYXRhLnBvcykge1xuICAgICAgICAgICAgYm9uZURhdGEucG9zID0ge1xuICAgICAgICAgICAgICB0aW1lczogbmV3IEZsb2F0MzJBcnJheShudW1GcmFtZXMpLFxuICAgICAgICAgICAgICB2YWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkobnVtRnJhbWVzICogMylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLnVzZUZpcnN0RnJhbWVQb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25PZmZzZXQgPSBib25lLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib25lLnBvc2l0aW9uLnN1Yihwb3NpdGlvbk9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvbmVEYXRhLnBvcy50aW1lc1tpXSA9IHRpbWU7XG4gICAgICAgICAgYm9uZS5wb3NpdGlvbi50b0FycmF5KGJvbmVEYXRhLnBvcy52YWx1ZXMsIGkgKiAzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJvbmVEYXRhLnF1YXQpIHtcbiAgICAgICAgICBib25lRGF0YS5xdWF0ID0ge1xuICAgICAgICAgICAgdGltZXM6IG5ldyBGbG9hdDMyQXJyYXkobnVtRnJhbWVzKSxcbiAgICAgICAgICAgIHZhbHVlczogbmV3IEZsb2F0MzJBcnJheShudW1GcmFtZXMgKiA0KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYm9uZURhdGEucXVhdC50aW1lc1tpXSA9IHRpbWU7XG4gICAgICAgIGJvbmUucXVhdGVybmlvbi50b0FycmF5KGJvbmVEYXRhLnF1YXQudmFsdWVzLCBpICogNCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1peGVyLnVwZGF0ZShkZWx0YSk7XG4gICAgc291cmNlLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBib25lRGF0YXMubGVuZ3RoOyArK2kpIHtcbiAgICBib25lRGF0YSA9IGJvbmVEYXRhc1tpXTtcbiAgICBpZiAoYm9uZURhdGEpIHtcbiAgICAgIGlmIChib25lRGF0YS5wb3MpIHtcbiAgICAgICAgY29udmVydGVkVHJhY2tzLnB1c2goXG4gICAgICAgICAgbmV3IFZlY3RvcktleWZyYW1lVHJhY2soXG4gICAgICAgICAgICBcIi5ib25lc1tcIiArIGJvbmVEYXRhLmJvbmUubmFtZSArIFwiXS5wb3NpdGlvblwiLFxuICAgICAgICAgICAgYm9uZURhdGEucG9zLnRpbWVzLFxuICAgICAgICAgICAgYm9uZURhdGEucG9zLnZhbHVlc1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnZlcnRlZFRyYWNrcy5wdXNoKFxuICAgICAgICBuZXcgUXVhdGVybmlvbktleWZyYW1lVHJhY2soXG4gICAgICAgICAgXCIuYm9uZXNbXCIgKyBib25lRGF0YS5ib25lLm5hbWUgKyBcIl0ucXVhdGVybmlvblwiLFxuICAgICAgICAgIGJvbmVEYXRhLnF1YXQudGltZXMsXG4gICAgICAgICAgYm9uZURhdGEucXVhdC52YWx1ZXNcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbWl4ZXIudW5jYWNoZUFjdGlvbihjbGlwKTtcbiAgcmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKGNsaXAubmFtZSwgLTEsIGNvbnZlcnRlZFRyYWNrcyk7XG59XG5mdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgY29uc3Qgc291cmNlTG9va3VwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY2xvbmVMb29rdXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBjbG9uZTIgPSBzb3VyY2UuY2xvbmUoKTtcbiAgcGFyYWxsZWxUcmF2ZXJzZShzb3VyY2UsIGNsb25lMiwgZnVuY3Rpb24oc291cmNlTm9kZSwgY2xvbmVkTm9kZSkge1xuICAgIHNvdXJjZUxvb2t1cC5zZXQoY2xvbmVkTm9kZSwgc291cmNlTm9kZSk7XG4gICAgY2xvbmVMb29rdXAuc2V0KHNvdXJjZU5vZGUsIGNsb25lZE5vZGUpO1xuICB9KTtcbiAgY2xvbmUyLnRyYXZlcnNlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuaXNTa2lubmVkTWVzaClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjbG9uZWRNZXNoID0gbm9kZTtcbiAgICBjb25zdCBzb3VyY2VNZXNoID0gc291cmNlTG9va3VwLmdldChub2RlKTtcbiAgICBjb25zdCBzb3VyY2VCb25lcyA9IHNvdXJjZU1lc2guc2tlbGV0b24uYm9uZXM7XG4gICAgY2xvbmVkTWVzaC5za2VsZXRvbiA9IHNvdXJjZU1lc2guc2tlbGV0b24uY2xvbmUoKTtcbiAgICBjbG9uZWRNZXNoLmJpbmRNYXRyaXguY29weShzb3VyY2VNZXNoLmJpbmRNYXRyaXgpO1xuICAgIGNsb25lZE1lc2guc2tlbGV0b24uYm9uZXMgPSBzb3VyY2VCb25lcy5tYXAoZnVuY3Rpb24oYm9uZSkge1xuICAgICAgcmV0dXJuIGNsb25lTG9va3VwLmdldChib25lKTtcbiAgICB9KTtcbiAgICBjbG9uZWRNZXNoLmJpbmQoY2xvbmVkTWVzaC5za2VsZXRvbiwgY2xvbmVkTWVzaC5iaW5kTWF0cml4KTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTI7XG59XG5mdW5jdGlvbiBnZXRCb25lQnlOYW1lKG5hbWUsIHNrZWxldG9uKSB7XG4gIGZvciAobGV0IGkgPSAwLCBib25lcyA9IGdldEJvbmVzKHNrZWxldG9uKTsgaSA8IGJvbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbWUgPT09IGJvbmVzW2ldLm5hbWUpXG4gICAgICByZXR1cm4gYm9uZXNbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEJvbmVzKHNrZWxldG9uKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHNrZWxldG9uKSA/IHNrZWxldG9uIDogc2tlbGV0b24uYm9uZXM7XG59XG5mdW5jdGlvbiBnZXRIZWxwZXJGcm9tU2tlbGV0b24oc2tlbGV0b24pIHtcbiAgY29uc3Qgc291cmNlID0gbmV3IFNrZWxldG9uSGVscGVyKHNrZWxldG9uLmJvbmVzWzBdKTtcbiAgc291cmNlLnNrZWxldG9uID0gc2tlbGV0b247XG4gIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiBwYXJhbGxlbFRyYXZlcnNlKGEsIGIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKGEsIGIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJhbGxlbFRyYXZlcnNlKGEuY2hpbGRyZW5baV0sIGIuY2hpbGRyZW5baV0sIGNhbGxiYWNrKTtcbiAgfVxufVxuY29uc3QgU2tlbGV0b25VdGlscyA9IHsgcmV0YXJnZXQsIHJldGFyZ2V0Q2xpcCwgY2xvbmUgfTtcbmV4cG9ydCB7XG4gIFNrZWxldG9uVXRpbHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ta2VsZXRvblV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJRdWF0ZXJuaW9uIiwiTWF0cml4NCIsIkFuaW1hdGlvbk1peGVyIiwiVmVjdG9yS2V5ZnJhbWVUcmFjayIsIlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrIiwiQW5pbWF0aW9uQ2xpcCIsIlNrZWxldG9uSGVscGVyIiwicmV0YXJnZXQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJvcHRpb25zIiwicG9zIiwicXVhdCIsInNjYWxlIiwiYmluZEJvbmVNYXRyaXgiLCJyZWxhdGl2ZU1hdHJpeCIsImdsb2JhbE1hdHJpeCIsInByZXNlcnZlTWF0cml4IiwicHJlc2VydmVQb3NpdGlvbiIsInByZXNlcnZlSGlwUG9zaXRpb24iLCJ1c2VUYXJnZXRNYXRyaXgiLCJoaXAiLCJuYW1lcyIsInNvdXJjZUJvbmVzIiwiaXNPYmplY3QzRCIsInNrZWxldG9uIiwiYm9uZXMiLCJnZXRCb25lcyIsImJpbmRCb25lcyIsImJvbmUiLCJuYW1lIiwiYm9uZVRvIiwiYm9uZXNQb3NpdGlvbiIsInBvc2UiLCJpIiwibGVuZ3RoIiwicHVzaCIsInBvc2l0aW9uIiwiY2xvbmUiLCJ1cGRhdGVNYXRyaXhXb3JsZCIsIm1hdHJpeFdvcmxkIiwiaWRlbnRpdHkiLCJjaGlsZHJlbiIsIm9mZnNldHMiLCJtYXRyaXgiLCJtdWx0aXBseSIsImRlY29tcG9zZSIsInF1YXRlcm5pb24iLCJnZXRCb25lQnlOYW1lIiwiY29weSIsImludmVydCIsInNldEZyb21NYXRyaXhTY2FsZSIsInNldCIsIngiLCJ5IiwieiIsIm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uIiwic2V0RnJvbVJvdGF0aW9uTWF0cml4IiwiYm9uZUluZGV4IiwiaW5kZXhPZiIsIndCaW5kTWF0cml4IiwiYm9uZUludmVyc2VzIiwiY29weVBvc2l0aW9uIiwicGFyZW50IiwiaXNCb25lIiwic2V0UG9zaXRpb24iLCJyZXRhcmdldENsaXAiLCJjbGlwIiwidXNlRmlyc3RGcmFtZVBvc2l0aW9uIiwiZnBzIiwiZ2V0SGVscGVyRnJvbVNrZWxldG9uIiwibnVtRnJhbWVzIiwiTWF0aCIsInJvdW5kIiwiZHVyYXRpb24iLCJkZWx0YSIsImNvbnZlcnRlZFRyYWNrcyIsIm1peGVyIiwiYm9uZURhdGFzIiwicG9zaXRpb25PZmZzZXQiLCJib25lRGF0YSIsImNsaXBBY3Rpb24iLCJwbGF5IiwidXBkYXRlIiwidGltZSIsImoiLCJ0aW1lcyIsIkZsb2F0MzJBcnJheSIsInZhbHVlcyIsInN1YiIsInRvQXJyYXkiLCJ1bmNhY2hlQWN0aW9uIiwic291cmNlTG9va3VwIiwiTWFwIiwiY2xvbmVMb29rdXAiLCJjbG9uZTIiLCJwYXJhbGxlbFRyYXZlcnNlIiwic291cmNlTm9kZSIsImNsb25lZE5vZGUiLCJ0cmF2ZXJzZSIsIm5vZGUiLCJpc1NraW5uZWRNZXNoIiwiY2xvbmVkTWVzaCIsInNvdXJjZU1lc2giLCJnZXQiLCJiaW5kTWF0cml4IiwibWFwIiwiYmluZCIsIkFycmF5IiwiaXNBcnJheSIsImEiLCJiIiwiY2FsbGJhY2siLCJTa2VsZXRvblV0aWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js\n");

/***/ })

};
;